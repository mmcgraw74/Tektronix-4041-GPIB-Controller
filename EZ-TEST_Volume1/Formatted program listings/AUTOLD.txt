    4   !  *************************************************************    8   !  **                                                         **   12   !  **                  TEK EZ-TEST VOLUME I                   **   16   !  **                 TEST PROGRAM GENERATOR                  **   20   !  **            4100 SERIES COLOR GRAPHIC TERMINAL           **   24   !  **                      Version 5.0                        **   28   !  **                                                         **   32   !  **                       * * * * *                         **   36   !  **                                                         **   40   !  **          COPYRIGHT (c) 1984 by TEKTRONIX, INC.          **   44   !  **                   ALL RIGHTS RESERVED                   **   48   !  **                                                         **   52   !  **                       * * * * *                         **   56   !  **                                                         **   60   !  **   This  software may not be  copied, in  whole or in    **   64   !  **   part, without written permission of Tektronix, Inc.,  **   68   !  **   except for back-up and  archive  purposes.  Removal   **   72   !  **   of this Copyright and Disclaimer  statement will be   **   76   !  **   violation of the Copyright.                           **   80   !  **                                                         **   84   !  *************************************************************  100 Clr_mem:     delete var all  105     Init all  110     Integer grph,plot,sgpr,utl1,term,baud,wipe,termid,verflag  115     Dim page$ to 16,pagem$ to 16,pagew$ to 16,bell$ to 1  120     Select "gpib0:"  125     Open #102:"FRTP:"  130     Open #200:"PRIN:"  135     Open #300:"gpib0:"  140     Open #700:"COMM:"  145     If pos(ask$("driver"),"COMM1",1) then set driver "COMM1(bau=9600):"  150     If pos(ask$("driver"),"COMM1",1) then open #800:"COMM1(tim=2,tms=5):"  155     If pos(ask$("driver"),"GPIB1",1) then open #400:"gpib1:" else open #400:"gpib0:"  160     On abort then call abormenu  165     On error(1 to 999) then call all_errs  170     On error(1200 to 1495) then call disk_err  175     On error(114) then call compr  180     On error(815 to 818) then call pollerrs  185     On error(554) then call timerr  190     On error(811) then call timout  195     On error(842) then call taperr1  200     On error(1207) then call taperr1  205     On error(843) then call taperr2  210     On error(850) then call file_is  215     On error(1204) then call file_is  220     On error(851) then call taperr4  225     On error(1202) then call taperr4  230     On error(853) then call taperr3  235     On error(1205) then call taperr3  240     On error(855) then call file_eof  245     On error(1206) then call file_eof  250     On error(888) then call err_888  255     On error(1000) then call exitest  260     Bell$=chr$(7)  265     Print #102:"TEK EZ-TEST"  270     If pos(ask$("rompack"),"GRPH",1) then grph=1 else grph=0  275     If pos(ask$("rompack"),"PLOT",1) then plot=1 else plot=0  280     If pos(ask$("rompack"),"SGPR",1) then sgpr=1 else sgpr=0  285     If pos(ask$("rompack"),"UTL1",1) then utl1=1 else utl1=0  290     If pos(ask$("id"),"2.0",1) then verflag=1 else verflag=0  295     Term=1  300     Call autobaud(baud,termid)  305     If fail=0 then goto init4100  310 Set_baud:     input #102 prompt "TERMINAL BAUD ":baud  315 Set_driv:     set driver "COMM0(BAU="&str$(baud)&",EDIT=RAS,fla=bid,stop=1):"  320 Init4100:     call initerm(baud,termid)  325     Pagew$=""&chr$(12)  330     Pagem$="LZ"  335     Page$=pagew$&pagem$  340     Call map_key  345     Wipe=1  350 Termrdy:     print #102:"TERMINAL IS READY"  355     Print "TG1400C2F4";  360     Print "TF410F40TF42I6A>F4LI122";  365     Print "KA0LV0MT5"&page$;  370     Wait 0.5  375     Print using "//=73A/":"MCD9H2B=LTA;TEK  EZ-TEST  "&str$(termid)  380     Print using "=80A":"MCD9F4B=LT<Version 5.0"  385     Print using "///2(=80a)":"TEKTRONIX TEST and MEASUREMENT Software","4100 SERIES TERMINAL"  390     Print using "/=80a/=80a3/":"Copyright (c) 1984,  TEKTRONIX Inc.","ALL RIGHTS RESERVED"  395     Print using "=79a//////////":"*     *     *"  400     Call commrbyt  405     Print pagew$  410     Dim lolmt$ to 20,hilmt$ to 20,out$ to 2,unitspc$ to 20,cgdata$ to 20,i$ to 40,delay$ to 10,log_unt$ to 10,old_lu$ to 200,wfpre$ to 200,count$ to 3,cmap$ to 150,revcmap$ to 150,bmap$ to 150,map$ to 150  415     Dim acqblok$ to 10000,blokbuf$ to 10000,tape$ to 100,timdate$ to 18,t_dev$ to 25,khead$ to 30,answer$ to 2,error$ to 30,ty$ to 2,blocklu$ to 300,outdev$ to 1,gptmout$ to 10,outadd$ to 200  420     Long loop(10,5),rdata,low,up,fntest,rdtemp,xplt,yplt  425     Dim c$ to 2,ret2prt$ to 200,gpib$ to 30,id$ to 25,key$ to 3,fsav$ to 15,finish$ to 20,start$ to 20,ret$ to 4,step$ to 20,typ$ to 12,l$ to 10,rdata$ to 30,u_d$ to 10,set1$ to 550,styp$ to 1  430     Dim answer$ to 1,plab$ to 20,lab$ to 16,label$ to 27,unit$ to 5,id$ to 30,path$ to 50,phypar$ to 140,logpar$ to 120,com$ to 120,phy$ to 160,line$ to 82,mode$ to 20,memnum$ to 15,date$ to 18  435     Dim outdata$ to 8,outset$ to 1,keylab1$(8) to 9,keylab2$(8) to 9,keylab3$(8) to 9,keylab4$(8) to 9,p_f$ to 6,cnt$ to 20,suffix$ to 5,delay$ to 8,stimset$ to 10,metemp$ to 80,tnam$ to 25  440     Dim inslab1$(8) to 9,inslab2$(8) to 9,inslab3$(8) to 9,inslab4$(8) to 9  445     Integer inskey(16)  450     Dim newprcd$(100) to 600,loop$(10,2) to 600,instr$(28) to 16,actcod$ to 6,iocode$ to 4,proc$ to 600,lset$ to 550,kset$ to 550,binprpt$ to 100,bstep$ to 16,proctmp$ to 600,strem$ to 300,filelnk$ to 200,unlok$ to 8,null$ to 20,n$ to 1  455     Integer fn_num,brchnxt,brchfail,iterates,brchstrt,ret_rn,lg_lin,incr,lstrt,lstop,lstpitr,l_par,llog,lacqr  460     Data 1,2,3,4,5,6,7,1,2,3,4,5,1,2  465     Restore  470     Read brchnxt,brchfail,iterates,brchstrt,ret_rn,lg_lin,incr,lstrt,lstop,lstpitr,l_par,llog,lstim,lacqr  475     Integer ins1,ins2,i,logd,err,typos,data_lu,datlutmp,cr1,cr0,oldfil,eof_err,eompos,commapos,memnum,filsiz,ebranch,nxstp,begstp,endstp,keyfl,nxstp,o_count,count1,count2,kk,ret_stak(20),stak_pt,substp,count9  480     Integer i,log_unit,outadd,prt,address,status,count,ins_cnt,mecount,me_max,f,keyflag,workspac,test,validkey(16),gport0,gport1,xrfrnc(100),newrfrnc(100),sequence(100,7),stp_ptr(100),log_all,stp,cntr,seqr(100)  495     Dim filed$ to 50,filex$ to 50,me_data$(3000) to 58,ftype$ to 8,helpfil$ to 6,opname$ to 25,f_flag$ to 3,sgn$ to 1,low$ to 20,up$ to 20  500     Integer try,stb,pri,port,bus,prim,err818,sec,err812,dsp_flg,wfpts,sel_cnt,secondry  505     Init var count,err,workspac,out$,count9,mbranch,delay,low,up,loops,start,endval,stepval,str_len,filesize,b,j,fn,v,linelen,outchr,sequence  510     N$=chr$(0)  515     Null$=n$&n$&n$&"0"&n$&"0"&n$&"0"&n$&n$&n$&"0"&n$&"10"&n$&n$  520     Newprcd$=null$  525     Loop$=null$  530     Init var log_unit,jump_out,flg1,newf,out$,lab$,n,m,q,mis_ins,mis,s_tep,stp,fntest,repeat,mecount,rdtemp,avg,done,bgn,e_nd,base,top,perlvl  535     Init var offset,u_d,range,n_pk,p_pk,space1,semicol,ty,typos,typdel,strt,xx,delay  540     Cmap$="TG140R<B80TG141J:C2F4TG142M2C2D;TG143R<C<C2TG144E:C2D;TG145J:B8F4TG146L8C2D;TG147E:E:F4"  545     Revcmap$="TG140R<00TG141G8C2F4TG142P4A>F4TG1430C2F4TG144G8C2F4TG145I6C<F4TG146P4C2F4TG147E:E:F4TF42000TF47O0C2F4"  550     Bmap$="TF410E:F4TF40G8C2F4TF42J:A>F4TF46G8E0F4LI122TG140R<A>F4TG1410A4F4TG142G8E0F4TG143O0C2C4TG1440C2C4TG145R<C2C4TG146C<C2C4TG147K4C2C4"  555     Map$=bmap$  560     Key$="N/A"  565     Data_lu=100  570     Datlutmp=100  575     Print "KA1LV1"  580     Sysdev$=seg$(ask$("sysdev"),1,4)  585     If sysdev$="TAPE" then dim filen$ to 6 else dim filen$ to 12  590     If pos(ask$("time"),"01-JAN-81",1) then print page$ else goto 615  595     Print "
Enter date and time."  600     Print "
Day-Month-Year Hour:Minute:Second  e.g...25-MAY-84 10:45:10"  605     Input timdate$  610     Set time timdate$  615     If not(pos(ask$("driver"),"GPIB1",1)) then goto 630  620     On srq(400) then call prt1  625     Enable srq(400)  630     On srq(300) then call prt0  635     Enable srq(300)  640 Main_lab:     print pagem$  645     Call sdc_all  650     Init var path$  655     Print #102:"SELECT MENU KEY"  660     On key(1) then call keyfla1  665     On key(2) then call keyfla2  670     On key(3) then call keyfla3  675     On key(4) then call keyfla4  680     On key(5) then call keyfla5  685     On key(6) then call keyfla6  690     On key(7) then call keyfla7  695     On key(8) then call keyfla8  700     On key(9) then call keyfla9  705     On key(10) then call keyfla10  710     On key(11) then call keyfla11  715     On key(12) then call keyfla12  720     On key(13) then call keyfla13  725     On key(14) then call keyfla14  730     On key(15) then call keyfla15  735     On key(16) then call keyfla16  740     On key(20) then call copyscrn  745     Khead$="MAIN MENU KEYS"  750     Data "","",""," SYS","","","",""  755     Data "","",""," DEV","","","",""  760     Data "","","","","","","",""  765     Data "","","","","","","",""  770     Data "EDIT ","GET","SAVE","FILE ","NEW","TERMN","HELP ","EXEC "  775     Data "PROCD","PROCD","PROCD","UTIL ","PROCD","PROGM","","PROCD"  780     Init var keylab3$,keylab4$,keylab1$,keylab2$,mbranch  785     If pos(ask$("driver"),"DISK",1) then restore 750 else restore 760  790     Read keylab1$,keylab2$  795 Restr:     restore 770  800     Read keylab3$,keylab4$  805     Call gkeydisp  810     Workspac=1  815     Enable keys  820     Print pagem$  825     Print "Press a function key"  830     On abort then call abort2mn  835     Enable abort  840     Keyflag=0  845     Wait  850     Gosub keyflag of changek,infilek,storek,filutil,restart,endit,helpmain,runit,deadkey,deadkey,deadkey,sysdev,deadkey,deadkey,deadkey,deadkey  855     If keyflag=0 then goto 820  860     Goto 745  865 Changek:     call change  870     Return  875 Infilek:     cnt$=""  880     Path$=" GET PROCEDURE FROM "&sysdev$  885     Key$="F2"  890     Filelnk$=chr$(13)  895     Call path_lab  900     Print "
WARNING:  Any procedure that is in memory will be destroyed."  905     Print "          Are you sure this is what you want to do?
"  910     Call y_nanswr  915     If answer$="n" then return  920     Call infile  925     Return  930 Storek:     cnt$=""  935     Path$=" STORE PROCEDURE ON "&sysdev$  940     Key$="F3"  945     Call path_lab  950     Call store  955     Return  960 Restart:     print pagem$  965     Cnt$=""  970     Path$=" CLEAR FOR NEW PROCEDURE"  975     Key$="F5"  980     Call path_lab  985     Print using "3l=72a":"This function clears all previous procedure generation."  990     Input prompt "    
Enter ""OK"" to proceed or press <RETURN> to go back to MAIN MENU : ":ret$  995     If ret$<>"OK" and ret$<>"" then goto 960 1000     If ret$="OK" then call re_start else return 1005     Call change 1010     Return 1015 Helpmain:     path$=" DISPLAY HELP INFORMATION" 1020     Key$="F7" 1025     Cnt$="" 1030     Call path_lab 1035     Helpfil$="HMAIN" 1040     Call prinhelp 1045     Keyflag=0 1050     Path$="" 1055     Return 1060 Runit:     cnt$="" 1065     Path$=" TEST EXECUTION" 1070     Key$="F8" 1075     Call path_lab 1080     Filelnk$="" 1085     Call r_main 1090     Return 1095 Sysdev:     if not(pos(ask$("driver"),"DISK",1)) then return 1100     Cnt$="" 1105     Path$=" SET SYSTEM DEVICE" 1110     Key$="S4" 1115     Call path_lab 1120     Call sys_dev 1125     Return 1130 Endit:     print page$&ll$ 1135     Print using "2l=79a":"Are you sure you are ready to leave the program?" 1140     Print using "2l=79a":"You get one more chance !!!!!!" 1145     Print using "2l=79a":"Press <RETURN> to continue or ""EXIT"" to terminate the program." 1150     Input prompt "


                       I'm waiting for your response: ":ret$ 1155     If ret$="EXIT" then goto 1405 else wipe=1 1160     Mbranch=1 1165     Return 1170 Deadkey:     keyflag=0 1175     Return 1180 Filutil:     path$=" FILE UTILITIES" 1185     Cnt$="" 1190     Key$="F4" 1195     Call path_lab 1200     Print path$ 1205 Choice:     print using "/4(20t40a//)":"""X"" = DELETE a file","""R"" = RENAME a file","""F"" = FORMAT a "&sysdev$&" (or re-format)","""D"" = DIRECTORY of "&sysdev$ 1210     Input prompt "Enter choice of  X, R, F, D or press <RETURN> for none : ":ret$ 1215     Print using "//": 1220     If ret$="" then goto no_choic 1225     If ret$="X" then gosub del_fil 1230     If ret$="R" then gosub rena_fil 1235     If ret$="F" then gosub form_tap 1240     If ret$<>"D" then goto choice 1245     Print "
NOTE:  See MANUAL for a description of wild card search character entry.
" 1250     If pos(ask$("sysdev"),"DISK",1) then input prompt "
Enter wild card search characters (e.g.; test.*, master.*)                      or Press <RETURN> for entire directory.  : ":ans$ else ans$="" 1255     If ans$="" then dir else dir ans$ 1260     Print "
DIRECTORY to 4041 printer?" 1265     Call y_nanswr 1270     If answer$="Y" then dir to "PRIN:" 1275     Goto choice 1280 No_choic:     return 1285 Del_fil:     input prompt "Enter filename to delete :":filen$ 1290     If not(len(filen$)) then return 1295     Print "Delete file :"&filen$&" ?" 1300     Call y_nanswr 1305     If answer$="Y" then delete file filen$ 1310     Print pagem$ 1315     Return 1320 Rena_fil:     dir "(lon=yes)" 1325     Input prompt "
RENAME a file - enter OLD file name : ":filen$ 1330     Renamerr=0 1335     If not(len(filen$)) then return 1340     Input prompt "
Enter NEW file name : ":fsav$ 1345     Rename filen$ to fsav$ 1350     If renamerr then goto rena_fil 1355     Print pagem$ 1360     Return 1365 Form_tap:     print "
WARNING :  FORMAT will destroy ALL files on the "&sysdev$&" !!!!!" 1370     Print "
Are you sure this is what you want to do?" 1375     Call y_nanswr 1380     If answer$<>"y" then return 1385     Input prompt "FORMAT the  "&sysdev$&" - enter the Volume label : ":filen$ 1390     Format filen$ 1395     Print pagem$ 1400     Return 1405     Call sdc_all 1410     Call initerm(baud,termid) 1415     Print "KDG#0" 1420     Print using "=72a":"Memory Clean-up In Progress" 1425     Delete var all 1430     Compress all 1435     Print using "=72a":"Tek EZ-TEST Program Terminated" 1440     Print #"frtp:":"Program Terminated" 1445     End 1500 Sub keyfla1 1505     Keyflag=1 1510     Resume 1515     End 1600 Sub keyfla2 1605     Keyflag=2 1610     Resume 1615     End 1700 Sub keyfla3 1705     Keyflag=3 1710     Resume 1715     End 1800 Sub keyfla4 1805     Keyflag=4 1810     Resume 1815     End 1900 Sub keyfla5 1905     Keyflag=5 1910     Resume 1915     End 2000 Sub keyfla6 2005     Keyflag=6 2010     Resume 2015     End 2100 Sub keyfla7 2105     Keyflag=7 2110     Resume 2115     End 2200 Sub keyfla8 2205     Keyflag=8 2210     Resume 2215     End 2300 Sub keyfla9 2305     Keyflag=9 2310     Resume 2315     End 2400 Sub keyfla10 2405     Keyflag=10 2410     Resume 2415     End 2500 Sub keyfla11 2505     Keyflag=11 2510     Resume 2515     End 2600 Sub keyfla12 2605     Keyflag=12 2610     Resume 2615     End 2700 Sub keyfla13 2705     Keyflag=13 2710     Resume 2715     End 2800 Sub keyfla14 2805     Keyflag=14 2810     Resume 2815     End 2900 Sub prt0 2905     Disable srq(400) 2910     Prt=0 2915     Select "gpib0(spe=.1,tim=.2):" 2920     If not(pos(ask$("lu",400),"ENA=0",1)) then goto 2905 2925     Call getstaby 2930     Enable srq(400) 2935     Resume 2940     End 3000 Sub keyfla15 3005     Keyflag=15 3010     Resume 3015     End 3100 Sub keyfla16 3105     Keyflag=16 3110     Resume 3115     End 3200 Sub copyscrn 3205     Print revcmap$ 3210     Print "KH1" 3215     Wait 1 3220     Print map$ 3225     Answer$="z" 3230     Resume 3235     End 3300 Sub prt1 3305     Disable srq(300) 3310     Prt=1 3315     Select "gpib1(spe=.1,tim=.2):" 3320     If not(pos(ask$("lu",300),"ENA=0",1)) then goto 3305 3325     Call getstaby 3330     Enable srq(300) 3335     Resume 3340     End 3400 Sub re_start local begin 3405 Begin:     init var loop,stp_ptr,count,mis,cntr 3410     Newprcd$=null$ 3415     Loop$=null$ 3420     Key$="" 3425     Sequence=0 3430     Print using "2l=72a":"**** Start new setup procedure ****." 3435     Cnt$="" 3440     Path$=" RE-CONFIGURE GPIB" 3445     Call path_lab 3450     Call tm_conf 3455     If cntr>14 then goto begin else return 3460     End 3500 Sub getstaby local err_815 3505     On error(815) then gosub err_815 3510     Init var error$,err,status,address,secondry 3515     Poll status,address,secondry 3520     If pos(ask$("path"),"TM_CONF",1) then return 3525     If pos(ask$("path"),"change",1) and (status=67 or status=83) or (status=65 or status=81) or (status=64 or status=80) or status=0 then goto 3590 else goto 3530 3530     If (status=67 or status=83) or (status=65 or status=81) or (status=64 or status=80) or (status=66 or status=82) or status=0 then goto 3590 3535     If status=65 or status=81 then error$="POWER ON INTERRUPT" 3540     If status=66 or status=82 then error$="OPC INTERRUPT" 3545     If status=67 or status=83 then error$="USER INTERRUPT" 3550     If status=97 or status=113 then error$="COMMAND ERROR" 3555     If status=98 or status=114 then error$="EXECUTION ERROR" 3560     If status=99 or status=115 then error$="INTERNAL ERROR" 3565     If status=102 or status=118 then error$="INTERNAL WARNING" 3570     If status>=120 or status>=120+16 then error$="DEVICE DEP INTERRUPT" 3575     Err=1 3580     Print chr$(13)&"
-- INSTRUMENT at address ";address;";";secondry;" on port ";prt;" reported "&error$&" status ";status;" -- " 3585     Print #200 using "/<8A2D1a2d1X5A1D/<20A<18A/8A3D/12A3D":"Address: ",address,";",secondry,"Port: ",prt,"reported: ",error$,"Status: ",status,"Step # ",stp 3590     Return 3595 Err_815:     advance 3600     End 3700 Sub instru(wipe,key_mes$,lp_again) local unused,i,ii,inst_lab,sel_dc9,sel_dc10,sel_dm,sel_fg,sel_ps04,sel_ps,sel_si,sel_mi,sel_cg,sel_aa,sel_sg,sel_7d20,help_ins,textkk,sel_xx 3705     Enable abort 3710 Inst_lab:     khead$="INSTRUMENT SELECTION MENU" 3715     Init var ebranch 3720     Validkey=inskey 3725     Keylab1$=inslab1$ 3730     Keylab2$=inslab2$ 3735     Keylab3$=inslab3$ 3740     Keylab4$=inslab4$ 3745     If pos(ask$("path"),"fornxt",1) then validkey(15)=0 else goto 3760 3750     Keylab1$(7)="" 3755     Keylab2$(7)="" 3760     Call gkeydisp 3765     Key$="" 3770     Call path_lab 3775     Print pagem$ 3780     Print key_mes$&" or"&chr$(13)&"<Crtl C> to abort step and RETURN to EDIT menu." 3785     Init var keyflag 3790     If count<=100 then goto 3810 else print "
The maximum of 100 steps has been generated." 3795     Wait 6 3800     Keyflag=8 3805     Return 3810     Wait 3815     If keyflag=0 then goto 3810 3820     Print pagem$ 3825     Keyfl=keyflag 3830     Gosub validkey(keyflag) of sel_dc10,sel_2465,sel_dm,sel_fg,sel_ps,sel_mi,sel_si,unused,sel_aa,sel_sg,sel_cg,sel_ps04,sel_7d20,sel_xx,textkk,help_ins 3835     If ebranch then return 3840     If validkey(keyfl)=0 then goto 3780 3845     If pos(ask$("path"),"fornxt",1) then return 3850     If lp_again then goto inst_lab else return 3855 Sel_dc10:     dc_cnt$="" 3860     For i=1 to count9 3865       If pos("DC5009 DC5010",seg$(instr$(i),1,6),1) then dc_cnt$=dc_cnt$&seg$(instr$(i),1,6) 3870       Next i 3875     If len(dc_cnt$)=6 then call set_up(dc_cnt$,"USER") else goto 3885 3880     Return 3885     Print "
     Select COUNTER type:

" 3890     Print "              1. DC5010" 3895     Print "              2. DC5009" 3900     Input prompt "
     Enter choice : ":ans$ 3905     If ans$<>"1" and ans$<>"2" then goto 3900 3910     If ans$="1" then dc_cnt$="DC5010" else dc_cnt$="DC5009" 3915     Call set_up(dc_cnt$,"USER") 3920     Return 3925 Sel_2465:     dc_cnt$="" 3930     Init var t1,t2 3935     For i=1 to count9 3940       If pos(instr$(i),"2445  ",1) then t2=1 3945       If pos(instr$(i),"2465  ",1) then t1=1 3950       Next i 3955     If t1 and t2 then goto 3970 3960     If t1 then call set_up("2465  ","") else call set_up("2445  ","") 3965     Return 3970     Print "
     Select SCOPE type:

" 3975     Print "              1. 2465" 3980     Print "              2. 2445" 3985     Input prompt "
     Enter choice : ":ans$ 3990     If ans$<>"1" and ans$<>"2" then goto 3985 3995     If ans$="1" then dc_cnt$="2465" else dc_cnt$="2445" 4000     Call set_up(dc_cnt$,"") 4005     Return 4010 Sel_dm:     call set_up("DM5010","USER") 4015     Return 4020 Sel_fg:     call set_up("FG5010","USER") 4025     Return 4030 Sel_ps04:     call set_up("PS5004","USER") 4035     Return 4040 Sel_ps:     call set_up("PS5010","USER") 4045     Return 4050 Sel_si:     call set_up("SI5010","USER") 4055     Return 4060 Sel_mi:     call set_up("MI5010","USER") 4065     Return 4070 Sel_cg:     call set_up("CG5001","REM") 4075     Return 4080 Sel_aa:     call set_up("AA5001","") 4085     Return 4090 Sel_sg:     call set_up("SG5010","USER") 4095     Return 4100 Sel_7d20:     call set_up("7D20  ","USER") 4105     Return 4110 Help_ins:     path$=" HELP for SELECTION MENU" 4115     Key$="S8" 4120     Call path_lab 4125     Helpfil$="HSELIN" 4130     Path$="" 4135     Call prinhelp 4140     Keyflag=0 4145     Return 4150 Unused:     return 4155 Textkk:     key$="S7" 4160     Call path_lab 4165     Call text 4170     Ebranch=1 4175     Return 4180 Sel_xx:     call set_up("XX","") 4185     Return 4190     End 4200 Sub set_up(sel_ins$,useron$) local iden$,to_main,deadkey,nxt_i,set_lab,tsignal,unlok,setdlay,keybrd,lrnit,tak_meas,to_edit,acq_blk,acq_wfm,toolong,tlk_lsn 4205     On error(64) then gosub toolong 4210     Iden$=seg$(sel_ins$,1,2) 4215     Ins_cnt=count9 4220     Sel_cnt=0 4225     For i=1 to count9 4230       If pos(instr$(i),sel_ins$,1) then sel_cnt=sel_cnt+1 else goto 4240 4235       Log_unit=i 4240       Next i 4245     If sel_cnt=1 then goto 4325 4250     Print pagem$ 4255     Print using "27TFA/":"Active "&sel_ins$&"(s):" 4260     Print using "10T8A6X12A6X4A6X7A/10T'--------'6X'------------'6X'----'6X'-------'":"DEVICE #","DEVICE NAME","PORT","ADDRESS" 4265     For i=1 to count9 4270       If pos(instr$(i),sel_ins$,1) then goto 4280 else ins_cnt=ins_cnt-1 4275       Goto nxt_i 4280       If seg$(instr$(i),10,2)="32" then print using "13T2D12XFA11XFA10XFA":i,seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2) 4285       If seg$(instr$(i),10,2)<>"32" then print using "13T2D12XFA11XFA8XFA":i,seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2)&";"&seg$(instr$(i),10,2) 4290 Nxt_i:       next i 4295     Print "
                     Select one (DEVICE #): "; 4300     Input log_unit 4305     If (log_unit>count9 or log_unit<=0) then print using "/22TFA":"Invalid number for the "&sel_ins$ else goto 4315 4310     Goto 4295 4315     If not(pos(instr$(log_unit),sel_ins$,1)) then print using "/22tfa":"Invalid number for the "&sel_ins$ else goto 4325 4320     Goto 4295 4325     If log_unit<=9 then log_unt$="0"&str$(log_unit) else log_unt$=str$(log_unit) 4330     Iocode$=iden$ 4335     Actcod$="NR" 4340     Init var lset$,kset$,label$,unit$,delay,low,up 4345     Delay$="0" 4350     Gptmout$="10" 4355     Unlok$="LOCKOUT" 4360     Proc$=null$ 4365     If flg1 then return 4370     Wipe=1 4375 Set_lab:     init var keylab1$,keylab2$,keylab3$,keylab4$ 4380     Key$="" 4385     Khead$=seg$(instr$(log_unit),1,6)&" OPERATING MODES" 4390     Data "LEARN","KEYBD","SET","MAKE ","ACQR","UNLOK","TALK/","EDIT " 4395     Data "SETNG","INPUT","DELAY","MEAS ","BLOCK","PANEL","LISTEN","MENU " 4400     Restore 4390 4405     Read keylab3$,keylab4$ 4410     If unlok$="LOCKOUT" then keylab3$(6)="UNLOK" else keylab3$(6)="LOCK" 4415     If pos(iden$,"7D",1) then keylab4$(5)="WVFRM" 4420     Call gkeydisp 4425     Print pagem$ 4430     Call path_lab 4435     Print "
Press a function key" 4440     Keyflag=0 4445     Wait 4450     If keyflag=0 then goto 4445 4455     If iden$="7D" then gosub keyflag of lrnit,keybrd,setdlay,tak_meas,acq_wfm,unlok,tlk_lsn,to_edit,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey else goto 4465 4460     Goto 4470 4465     Gosub keyflag of lrnit,keybrd,setdlay,tak_meas,acq_blk,unlok,tlk_lsn,to_edit,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey 4470     If keyflag=0 then goto 4445 4475     If keyflag=7 then goto 4430 4480     If keyflag=1 then goto 4430 4485     If jump_out then jump_out=0 else goto set_lab 4490     Ebranch=1 4495     Return 4500 Unlok:     if unlok$="LOCAL" then unlok$="LOCKOUT" else unlok$="LOCAL" 4505     Print "
The ";sel_ins$;" will be in ";unlok$ 4510     Return 4515 Setdlay:     input prompt "
Enter delay value in seconds: ":delay 4520     Delay=int(delay*100)/100 4525     If delay<=32000 then goto 4540 else print "

Entered value too large....try again." 4530     Wait 2 4535     Goto setdlay 4540     Delay$=str$(delay) 4545     Return 4550 Keybrd:     path$=" KEYBOARD INPUT" 4555     Key$="F2" 4560     Call path_lab 4565     Rep$(path$,pos(path$,"key",1),14)="" 4570     Err=0 4575     Kset$="" 4580     If pos(iden$,"XX",0) then goto 4605 4585     If pos(iden$,"AA",1) or pos(iden$,"SG",1) then input #log_unit prompt "help?":kset$ 4590     If kset$<>"" then print using "'Keywords are: '//500a/":kset$ 4595     Input #log_unit prompt "SET?" buffer blokbuf$:blokbuf$ 4600     Print using "'Settings are:'//fa/":blokbuf$ 4605     If len(lset$) then print "

ENTERING COMMANDS FROM THE KEYBOARD WILL ALTER THE PREVIOUSLY LEARNED SETUP!" 4610     Print using "FA2/FAS":"
ENTER DEVICE ASCII COMMANDS  (imbedded carriage return is permitted)","press <LINE FEED> to stop entry : " 4615     Input #"COMM0(EOM=<10>):":kset$ 4620     If pos(kset$,"INIT",1) then print using "/fa":"The INIT command will negate any learned settings in this step!" else goto 4640 4625     Print "
Is this what you want?" 4630     Call y_nanswr 4635     If answer$<>"Y" then goto 4610 4640     If len(kset$)+len(lset$)>550 then print using "//FA":"KEYBOARD settings plus LEARNED settings too large!  ALL settings discarded. " else goto 4655 4645     Init var kset$,lset$ 4650     Return 4655     Print #log_unit:lset$&kset$ 4660     Wait 0.5 4665     If status>90 and err and iden$<>"XX" then goto 4570 else return 4670 Lrnit:     if not(iden$="XX") then goto 4690 4675     Print using "/FA/FA/FA":"LEARN SETTINGS applies to TEKTRONIX instruments conforming to the ","Codes and Formats standard.","Do you wish to attempt LEARN SETTINGS with this instrument?" 4680     Call y_nanswr 4685     If answer$="N" then return 4690     Path$=" LEARN SETTINGS" 4695     Key$="F1" 4700     Binprpt$="" 4705     Call path_lab 4710     Rep$(path$,pos(path$,"learn",1),15)="" 4715     Keyflag=0 4720     If len(useron$) then print #log_unit:useron$&" ON" 4725     If iden$<>"24" then goto 4745 4730     Print "
Set up the "&sel_ins$&" front panel and then press function KEY 1                       to store the current settings." 4735     Wait 4740     Goto 4770 4745     If not(iden$="XX" or iden$="FG" or iden$="SG" or iden$="PS") then goto 4815 4750     Print "
Do you wish to learn Low Level Binary settings?" 4755     Call y_nanswr 4760     If answer$="N" then goto 4815 4765     Input prompt "
Set up "&sel_ins$&" front panel and then enter the prompt for binary settings (defaults to LLSET? if no entry) : ":binprpt$ 4770     Select ask$("lu",log_unit) 4775     If len(binprpt$) then print #log_unit:binprpt$ else print #log_unit:"LLSET?" 4780     Wait 1 4785     If seg$(instr$(log_unit),10,2)="32" then wbyte atn(val(seg$(instr$(log_unit),8,2))+64,mla) else wbyte atn(val(seg$(instr$(log_unit),8,2))+64,val(seg$(instr$(log_unit),10,2))+96,mla) 4790     Rbyte blokbuf$ 4795     Wbyte atn(unt,unl) 4800     Lset$=blokbuf$ 4805     Input prompt "

THE SETTINGS HAVE BEEN LEARNED"&chr$(13)&"Press <RETURN> to continue.":ans$ 4810     Goto 4915 4815     Print "
Set up "&sel_ins$&" front panel and then press either the "&sel_ins$&" INST ID button"&chr$(13)&"or function KEY 1 to store the current settings." 4820     Print "
If you press the wrong INST ID button nothing will happen." 4825     Wait 4830     If keyflag=1 then goto 4845 4835     If iden$="CG" and (status=64 or status=80) then goto 4845 4840     If status<>67 and status<>83 then goto 4825 4845     If len(useron$) then print #log_unit:useron$&" OFF" 4850     If iden$="7D" then input prompt "LO OF;SET?;WFMPRE?" #log_unit:lset$ else input prompt "SET?" #log_unit:lset$ 4855     If iden$<>"AA" or not(pos(lset$,"DBR",1)) then goto 4880 4860     Print #"frtp:":"" 4865     Print "

dbRATIO is not a programmable function..." 4870     Wait 2 4875     Rep$(lset$,pos(lset$,"DBR",1),4)="" 4880     Print "

THE FOLLOWING SETTINGS HAVE BEEN LEARNED:" 4885     Print "

"&lset$ 4890     If iden$<>"XX" then goto 4915 4895     Print "
Are these settings correct?" 4900     Call y_nanswr 4905     If answer$="Y" then goto 4915 else lset$="" 4910     Print "
The LEARNED SETTINGS were discarded ! " 4915     If iden$="XX" then keyflag=2 else keyflag=1 4920     If len(lset$)>0 then kset$="" 4925     Return 4930 Toolong:     print using "//fa":"Settings too large.  Settings discarded!" 4935     Init var lset$,kset$ 4940     Branch set_lab 4945 Tak_meas:     path$=" MAKE MEAS" 4950     Path$=" MAKE MEAS" 4955     Key$="F4" 4960     Call path_lab 4965     Rep$(path$,pos(path$,"make",1),10)="" 4970     Jump_out=1 4975     Call query(iden$) 4980     Call sav_data(proc$) 4985     Return 4990 To_edit:     if pos(ask$("path"),"fornxt",1) then print "
The measurement loop sequence must be complete before returning to EDIT MENU!" else goto 5000 4995     Return 5000     Jump_out=1 5005     Call sav_data(proc$) 5010     Return 5015 Deadkey:     keyflag=0 5020     Return 5025 Acq_blk:     if pos(ask$("path"),"fornxt",1) then print "
ACQUIRE BLOCK is not permitted in LOOP steps.
" else goto 5035 5030     Return 5035     Path$=" ACQUIRE BLOCK DATA" 5040     Key$="F5" 5045     Call path_lab 5050     Call aqtimout 5055     Old_lu$=ask$("lu",log_unit) 5060     Old_lu$=seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",tim="&gptmout$&",eom=<0>):" 5065     Rep$(path$,pos(path$,"ACQUIRE",1),18)="" 5070     Print "
Warning: Block Acquire negates use of keys 1, 2, and 4
" 5075     Actcod$="BA" 5080     Call respond 5085     If filen$="" then goto 5100 5090     Input #old_lu$ buffer blokbuf$:acqblok$ 5095     Input prompt "
Acquired block is "&str$(len(acqblok$))&" bytes -  enter file size (should be larger) : ":filsiz 5100     Lset$=filen$&"(ope=new,size="&str$(filsiz)&")" 5105     Kset$="" 5110     L$=iden$&" BLOCK" 5115     Input prompt "

What do you want to call this measurement (15 Character max) : ":lab$ 5120     If lab$="" then label$=l$ else label$=lab$ 5125     Call sav_data(proc$) 5130     Jump_out=1 5135     Return 5140 Acq_wfm:     if pos(ask$("path"),"fornxt",1) then print "
ACQUIRE WAVEFORM is not permitted in LOOP steps." else goto 5150 5145     Return 5150     Path$="ACQUIRE 7D20 WAVEFORM" 5155     Key$="F6" 5160     Call path_lab 5165     Call aqtimout 5170     Actcod$="DW" 5175     Rep$(path$,pos(path$,"ACQUIRE",1),21)="" 5180     Print "
Warning: Waveform acquire negates use of keys 1, 2, and 4
" 5185     Old_lu$=ask$("lu",log_unit) 5190     Open #log_unit:seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",tim="&gptmout$&",eom=<0>,eoa=<0>):" 5195     Input #old_lu$ prompt "di? csw":memnum$ 5200     Memnum=val(memnum$) 5205     Print #old_lu$:"DA ME:"&str$(memnum) 5210     Input #old_lu$ prompt "DA? ENC":mode$ 5215     Mode$=seg$(mode$,pos(mode$,":",1)+1,len(mode$)) 5220     Call getwfm20(log_unit,mode$,wfpre$,wfdata) 5225     Open #log_unit:old_lu$ 5230     If not(grph and plot) then goto 5275 5235     Print "LI100"&page$&cmap$ 5240     GINIT 700,4113,1 5245     Print "
Waveform acquired!" 5250     Call norwfm20(wfdata,wfpre$,normdata) 5255     Call plotwf20(normdata,wfpre$,1,2,3,0,"7D20 WFM "&str$(memnum)&",TEST STEP "&str$(count+1)&",TIME,VOLTS,TEKTRONIX DLTPG S/W,") 5260     Call commrbyt 5265     Print page$ 5270     Call gkeydisp 5275     Print "Specify file for waveform storage at runtime . . ." 5280     Call respond 5285     If filen$="" then goto 5295 5290     Input prompt "
Waveform requires "&str$(len(wfpre$)+val(seg$(ask$("var",wfdata),posn(ask$("var",wfdata),",",1,2),10))*5)&" bytes file size : enter desired file size : ":filsiz 5295     Lset$=filen$&"(OPEN=NEW,SIZE="&str$(filsiz)&")" 5300     Kset$="" 5305     L$="7D20 WFM "&str$(memnum) 5310     Input prompt "

What do you want to call this waveform (15 character max) : ":lab$ 5315     If lab$="" then label$=l$ else label$=lab$ 5320     Call sav_data(proc$) 5325     Workspac=0 5330     Jump_out=1 5335     Return 5340 Tlk_lsn:     path$="  TALK & LISTEN" 5345     Key$="F7" 5350     Call path_lab 5355     Path$="" 5360     Print using "//FA":"ENTER Device command (terminate with <LINE FEED>) : "; 5365     Input #"comm0(eom=<10>):":blokbuf$ 5370     Print #log_unit:blokbuf$ 5375     If not(pos(instr$(log_unit),"TEK",1)) then goto 5385 5380     If pos(blokbuf$,"?",1) then goto 5385 else goto donetalk 5385     Input #log_unit:blokbuf$ 5390     If pos(blokbuf$,chr$(27),0) or pos(blokbuf$,chr$(28),0) or pos(blokbuf$,chr$(29),0) then print using "//fa":"Non-printable response, see strip printout." else goto prntabl 5395     Print #200:blokbuf$ 5400     Goto donetalk 5405 Prntabl:     print using "//'DEVICE RESPONSE : 'fa":blokbuf$ 5410 Donetalk:     return 5415     End 5500 Sub sav_data(var proc$) 5505     Putmem buffer proc$ using "11(' ',fa)":actcod$,iocode$&log_unt$,str$(fn_num),str$(low),str$(up),label$,unit$,delay$,gptmout$,unlok$,lset$&kset$ 5510     Return 5515     End 5600 Sub extract(proc$) local tmp$,low$,up$ 5605     Getmem buffer proc$ dels " :tmp$,actcod$,iocode$,fn_num$,low$,up$,label$,unit$,delay$,gptmout$,unlok$ 5610     Lset$=seg$(proc$,posn(proc$," ",1,11)+1,len(proc$)) 5615     Log_unt$=seg$(iocode$,3,2) 5620     Iocode$=seg$(iocode$,1,2) 5625     Delay=val(delay$) 5630     Low=val(low$) 5635     Up=val(up$) 5640     Kset$="" 5645     Return 5650     End 5700 Function nxtlpnum local lpstep,nxlpstep,lastlp 5705     Integer lpstep,nxlpstep,nxtlpnum 5710     For lpstep=1 to 10 5715       If loop(lpstep,3)=0 then exit to lastlp 5720       Next lpstep 5725 Lastlp:     nxtlpnum=lpstep 5730     Return 5735     End 5800 Sub query(qread$) 5805     Actcod$="MR" 5810     If qread$<>"DC" then goto 5830 5815     Print "
Do you wish to do a peak to peak?" 5820     Call y_nanswr 5825     If answer$="Y" then actcod$="PR" 5830     Call aqtimout 5835     If pos(ask$("path"),"fornxt",1) then goto 5855 5840     Print "
Do you wish to specify measurement limits?" 5845     Call y_nanswr 5850     If pos(answer$,"Y",1) then call limits 5855     Call meas_lab(qread$) 5860     Return 5865     End 5900 Sub aqtimout 5905     Print using "/fa":"Enter Acquisition Timeout in seconds or press <RETURN> for default of           10 seconds : "; 5910     Input gptmout$ 5915     If gptmout$="" then gptmout$="10" 5920     If asc(gptmout$)<48 or asc(gptmout$)>57 then print "
Entry must be a number.....try again" else goto 5935 5925     Wait 1 5930     Goto 5905 5935     If val(gptmout$)<=0 or val(gptmout$)>21474800.0 then print "
Value entered is not legal ( must be > 0 and < 2.14748E+7) Try again" else goto 5950 5940     Wait 1 5945     Goto 5905 5950     Return 5955     End 6000 Sub limits 6005     Actcod$=seg$(actcod$,1,1)&"L" 6010     Input prompt "

Enter lower limit. ":low 6015     Input prompt "
Enter upper limit. ":up 6020     Return 6025     End 6100 Sub output 6105     Print "Select a device for output." 6110     Input prompt "
S=Screen, P=4041 printer, "&seg$(ask$("sysdev"),1,1)&"="&sysdev$&", L=Line printer, or RETURN for none: ":outdata$ 6115     If outdata$="" then return 6120     Outdata$=seg$(outdata$,1,1) 6125     If pos("SsPpLlTtDd",outdata$,1) then return else goto 6110 6130     End 6200 Sub fornxt 6205     Enable abort 6210     Path$=path$&" LOOP: stimulus" 6215     Actcod$="FN" 6220     Flg1=1 6225     Call instru(0,"
Select a stimulus instrument for measurement loop",0) 6230     Err=0 6235     Rep$(path$,pos(path$,"LOOP:",1),14)="" 6240     Print "

Will the loop be incrementing a stimulus parameter?" 6245     Call y_nanswr 6250     If answer$="n" then loop(fn_num,l_par)=1 else goto 6275 6255     Print "

Enter command(s).....e.g. MODE TRIG;MTRIG...or NEXT...DATA H0110...etc.." 6260     Print "or use reference guides.
" 6265     Input kset$ 6270     Goto 6335 6275     Loop(fn_num,l_par)=0 6280     Input prompt "
Will the stimulus increment be :"&chr$(13)&"
 1. Logarithmic"&chr$(13)&" 2. Linear"&chr$(13)&"
Enter choice be number : ":answer$ 6285     If answer$<>"1" and answer$<>"2" then input #700:answer$ else goto 6295 6290     Goto 6285 6295     If answer$="1" then loop(fn_num,llog)=1 else loop(fn_num,llog)=0 6300     Print "


Enter the command(s)... the last command must be the header (NO ARGUMENT)." 6305     Print "  e.g. FUNC SINE;DISP FREQ;FREQ ...or VPOS... etc. " 6310     Input kset$ 6315     If kset$="" then goto 6300 6320     Print "
NOTE:  The suffix entry is for non-Tektronix instrumentation that require a            suffix as part of the instrument command (IE: MZ as in FR100MZ). No             suffix is required for Tektronix devices." 6325     Input prompt "
Enter a suffix to follow the numeric loop value"&chr$(13)&"or press <RETURN> for none :":suffix$ 6330     Unit$=suffix$ 6335     If loop(fn_num,l_par)=1 then input prompt "

Enter number of loop iterations to be made: ":loops else goto 6365 6340     If loops>100 then goto 6335 6345     Start=1 6350     Endval=loops 6355     Stepval=1 6360     Goto 6430 6365     If loop(fn_num,llog)=1 then print "
NOTE:  Logarithmic loop starting and ending values may NOT be :"&chr$(13)&"       ZERO (0) ...or... OPPOSITE polarities (+ & -)." 6370     Input prompt "

Enter starting value: ":start 6375     Input prompt "
Enter ending value: ":endval 6380     If not(loop(fn_num,llog)) then goto 6405 6385     If start=0 or endval=0 then print "Zero (0) values are not allowed" else goto 6395 6390     Goto 6365 6395     If (start*endval)<0 then print "Loop values of opposite polarities are not allowed." else goto 6420 6400     Goto 6365 6405     Print "
The minimum allowable increment value is ";((endval-(start))/(100-1));"." 6410     Input prompt "
Enter loop increment value: ":stepval 6415     If abs(stepval)<(endval-start)/(100-1) then goto 6405 else goto 6430 6420     Input prompt "
Enter number of loop iterations to be made (100 is max). ":stepval 6425     If abs(stepval)>100 then goto 6420 6430     Print #102:"Testing loop limits" 6435     If loop(fn_num,l_par)=1 then print #log_unit:kset$&suffix$ else print #log_unit:kset$;str$(start)&suffix$ 6440     Wait 0.5 6445     If err then goto 6230 6450     If loop(fn_num,l_par)=0 then print #log_unit:kset$;str$(endval)&suffix$ 6455     Wait 0.5 6460     If err then goto 6230 6465     Label$="LOOP STIMULUS  " 6470     Loop(fn_num,lstrt)=start 6475     Loop(fn_num,lstop)=endval 6480     Loop(fn_num,lstpitr)=stepval6485Inpu prom"
        Desired delay (in seconds) between stimulus device settings (if any)            and measurement device settings and/or response.                                Enter delay time ( 0 to 32000 ) or <RETURN> for none  : ":delay$ 6490     If delay$="" then delay=0 else goto 6500 6495     Goto 6540 6500     If asc(delay$)>=48 and asc(delay$)<=57 then goto 6520 6505     Print "

Entry was not a valid number.....try again" 6510     Wait 2 6515     Goto 6485 6520     Delay=int(val(delay$)*100)/100 6525     If delay<=32000 then goto 6540 else print "

Entered value too large.....try again." 6530     Wait 2 6535     Goto 6485 6540     Delay$=str$(delay) 6545     Call sav_data(proc$) 6550     Loop$(fn_num,lstim)=proc$ 6555     Flg1=0 6560     Path$=path$&" LOOP: meas." 6565     Call instru(0,"
Select a measurement instrument for measurement loop",0) 6570     Loop$(fn_num,lacqr)=proc$ 6575     Return 6580     End 6600 Sub text local no_meas,ml,define 6605     Iocode$="TX" 6610     Init var lset$,kset$,label$,unit$ 6615     Delay$="0" 6620     Unlok$="LOCKOUT" 6625     Gptmout$="0" 6630     Print "

Add text: " 6635     Print "
Specify prompting for operator interaction." 6640     Print using "lfa/5tfa/":"  -- Pressing the RETURN key allows multi-line prompting up to","550 characters (SPACE BAR generated spaces included)." 6645     Print "  -- Pressing the <LINE FEED> key terminates the prompting." 6650     Print "

e.g....Connect FG 5010 OUTPUT to DC 5010 CHA INPUT.<RETURN>" 6655     Print "       Turn R_49 clockwise.<LINE FEED>" 6660     Print "

Enter prompting:
" 6665     Input #"comm(EOM=<10>):":kset$ 6670     If kset$="" then goto 6665 6675     Print 6680     Print "
Will the operator be required to enter measurement results?" 6685     Call y_nanswr 6690     If answer$="Y" then actcod$="MR" else goto no_meas 6695     Print "
Is the resulting measurement to be compared to PASS/FAIL limits?" 6700     Call y_nanswr 6705     If answer$="Y" then call limits 6710     Goto ml 6715 No_meas:     print "
Will the operator be required to indicate PASS/FAIL via the keyboard?" 6720     Call y_nanswr 6725     If answer$<>"Y" then actcod$="NR" else actcod$="PF" 6730     If actcod$="NR" then goto define 6735 Ml:     call meas_lab("TX") 6740 Define:     call sav_data(proc$) 6745     Return 6750     End 6800 Sub timerr 6805     Print pagem$ 6810     Print "
Incorrect format!" 6815     Print "
Enter date and time." 6820     Print "Day-Month-Year Hour:Minute:Second e.g.....25-MAY-84 10:45:10" 6825     Input timdate$ 6830     Retry 6835     End 6900 Sub timout 6905     Advance 6910     End 7000 Sub store 7005     Init var str_len 7010     Fn_num=nxtlpnum 7015     For i=1 to 100 7020       Str_len=str_len+len(newprcd$(i))+1 7025       Next i 7030     For i=1 to 10 7035       Str_len=str_len+len(loop$(i,lstim))+1 7040       Str_len=str_len+len(loop$(i,lacqr))+1 7045       Next i 7050     Filesize=3000+43*count9+str_len 7055     Tape$="TAPE(OPEN=NEW,SIZE="&str$(filesize)&",FOR=ITE)" 7060     Print pagem$ 7065     Print "Store procedure on "&sysdev$&"." 7070     Call respond 7075     If filen$<>"" then goto 7085 7080     Return 7085     Ftype$="REPLACE" 7090     Open #80:filen$ 7095     If ftype$="NEW" then goto 7120 7100     Print "
WARNING:  File already exists!"&chr$(13)&"Do you wish to replace old file?" 7105     Call y_nanswr 7110     If answer$="n" then return 7115     Rep$(tape$,11,3)="replace" 7120     Rep$(tape$,1,4)=filen$ 7125     Newf=0 7130     Open #80:tape$ 7140     Print #80 using "I":count9 7145     Print #80 using "I":instr$ 7150     Print #80 using "I":newprcd$ 7155     Print #80 using "I":loop$ 7160     Print #80 using "I":loop 7165     Print #80 using "I":sequence 7170     Print #80 using "I":stp_ptr 7175     Close 80 7180     Print "
Do you wish a list of the instruments required for this test printed to the     thermal printer?" 7185     Call y_nanswr 7190     If answer$="N" then return 7195     Print "

A list of instruments required for this test is being printed." 7200     Print #200 using " 4x9a//'FILE: '12a/":seg$(ask$("time"),1,9),filen$ 7205     Print #200 using "'DEVICE'2X'PORT'2X'ADDR'": 7210     Print #200 using "13x'PRI;SEC'": 7215     For i=1 to count9 7220       If seg$(instr$(i),10,2)="32" then print #200 using "6A3X1A4x2a":seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2) 7225       If seg$(instr$(i),10,2)<>"32" then print #200 using "6A3x1a4x2a';'2a":seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2),seg$(instr$(i),10,2) 7230       Next i 7235     Print #200 using "12L": 7240     Return 7245     End 7300 Sub respond 7305     If newf then print pagem$&"
Selected file ("&filen$&") not found.
" 7310     Print 7315     Dir "(LONG=YES)" 7320     Input prompt "
Enter file name or press <RETURN> for none: ":filen$ 7325     If filen$="" then goto 7335 else call tfilnam 7330     If filen$="" then goto 7315 7335     Fsav$=filen$ 7340     Init var newf 7345     Return 7350     End 7400 Sub taperr1 7405     Print pagem$ 7410     Print "
Warning!" 7415     Input prompt "
Insert "&sysdev$&" into drive and press <RETURN> : ":answer$ 7420     Print pagem$ 7425     Retry 7430     End 7500 Sub file_eof 7505     Eof_err=1 7510     Advance 7515     End 7600 Sub taperr2 7605     Print pagem$ 7610     Print "
Caution!" 7615     Print "
Change write protect tab on tape to RECORD and press <RETURN> ." 7620     Input answer$ 7625     Print pagem$ 7630     Retry 7635     End 7700 Sub taperr3 7705     Newf=1 7710     Ftype$="NEW" 7715     Advance 7720     End 7800 Sub file_is 7805     Oldfil=1 7810     Advance 7815     End 7900 Sub taperr4 7905     Print "
"&sysdev$&" is full!" 7910     Input prompt "Insert another "&sysdev$&" and press <RETURN> ":answer$ 7915     Retry 7920     End 8000 Sub change local deadkey,help_edt,bkmain,list_sk,deletk,alte_rk,insertk,add_k,gen_step,getstnum,chkrg,goodstep,steptyp,loop_s,gen_fn,dupe_s,bad,valid_s,dup_it,singldup,end_dupe,list_lk,lis1,gen_gsub,gsub1,gsub3,gen_rtn,seq_init,g_stptyp,altloop,cklp 8005     If count9=0 then call re_start 8010     Disable abort 8015     On abort then call chgabort 8020     B=count 8025     Ebranch=0 8030     Print pagem$ 8035 Edit_lab:     disable abort 8040     Init var keylab1$,keylab2$,keylab3$,keylab4$ 8045     Cnt$="" 8050     Khead$="EDIT FUNCTIONS" 8055     Data "LIST","DUP  ","REPLA","INSRT","NEW  ","ALTER","HELP","MAIN","LIST","DELET" 8060     Data "STEPS","STEP ","STEP ","STEP","STEP ","STEP ","    ","MENU","HCOPY","STEPS" 8065     Restore 8055 8070     Read keylab3$,keylab1$(1),keylab1$(2),keylab4$,keylab2$(1),keylab2$(2) 8075     Call gkeydisp 8080     Print pagem$ 8085     Print "Press a function key" 8090     Keyflag=0 8095     Wait 8100     If keyflag=0 then goto 8095 8105     Delay$="0" 8110     Gosub keyflag of list_sk,dupe_s,repl_ck,insertk,add_k,alte_rk,help_edt,bkmain,list_lk,deletk,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey 8115     Key$="N/A" 8120     If mbranch then enable abort else goto 8130 8125     Return 8130     If keyflag=0 then goto 8080 8135     Goto edit_lab 8140 Help_edt:     cnt$="" 8145     Path$=" HELP for EDIT MENU" 8150     Key$="F7" 8155     Call path_lab 8160     Helpfil$="HEDIT" 8165     Init var path$ 8170     Call prinhelp 8175     Keyflag=0 8180     Return 8185 Bkmain:     mbranch=1 8190     Return 8195 List_sk:     path$=" LIST Steps" 8200     Key$="F1" 8205     Call path_lab 8210     Strem$="comm0:" 8215     Gosub lis1 8220     Call commrbyt 8225     Return 8230 Deletk:     path$=" EDIT: DELETE Steps" 8235     Key$="F2" 8240     Call path_lab 8245     Print "Enter step(s) to DELETE." 8250     Call num_in 8255     If count1=0 then goto 8275 8260     For count=count1 to count2 8265       If stp_ptr(count)<>0 then call del_ete(count) else print "
No Step ";count;" to DELETE !" 8270       Next count 8275     Keyflag=0 8280     Return 8285 Alte_rk:     path$=" EDIT: ALTER Step" 8290     Key$="F6" 8295     Call path_lab 8300     Print pagem$ 8305     Input prompt "
Enter step # to ALTER (1 to 100) or press <RETURN> for none : ":cnt$ 8310     If cnt$="" then return else call chkrng(1,100,cnt$) 8315     If cnt$="" then goto 8305 else count=val(cnt$) 8320     If stp_ptr(count) then goto alt_gd else print "
Step "&cnt$&" non-existent." 8325     Goto 8305 8330 Alt_gd:     proc$=newprcd$(stp_ptr(count)) 8335     Call extract(proc$) 8340     If not(sequence(stp_ptr(count),ret_rn)) then goto cklp else print using "/fa/":"illegal ALTER of a GOSUB or RETURN step type." 8345     Goto 8385 8350 Cklp:     if actcod$="FN" then goto altloop 8355 Alt1:     print using "/fa6(20tfa/)s":"You may ALTER","1 Step label","2 Unit label","3 Lower limit","4 Upper limit","5 Delay time","6 GPIB time out" 8360     Print using "3(20tfa/)":"7 Lockout/Local","8 Branching","9 RETURN to EDIT menu" 8365     Input prompt "
Enter ALTER # : ":altn 8370     Goto altn of stlab,unlab,lolim,uplim,alt_dly,alt_gp,alt_lok,br_nch 8375     Call sav_data(proc$) 8380     Newprcd$(stp_ptr(count))=proc$ 8385     Return 8390 Stlab:     print "Current Step label is : ";label$ 8395     Input prompt "Enter new label : ":lab$ 8400     Label$=lab$ 8405     Goto cklp 8410 Unlab:     print "Current Unit label is : ";unit$ 8415     Input prompt "Enter new label : ":unit$ 8420     Goto alt1 8425 Lolim:     if not(pos(actcod$,"L",1)) then goto nolim 8430     Print "Current lower limit is : ";low 8435     Input prompt "Enter new lower limit : ":low 8440     Goto alt1 8445 Uplim:     if not(pos(actcod$,"L",1)) then goto nolim 8450     Print "Current upper limit is : ";up 8455     Input prompt "Enter new upper limit : ":up 8460     Goto alt1 8465 Nolim:     print "No limits given." 8470     Goto alt1 8475 Alt_dly:     print "Current delay time is ";delay$ 8480     Input prompt "Enter new delay value ":delay 8485     Delay$=str$(abs(delay)) 8490     Goto alt1 8495 Alt_gp:     print "Current Acquisition timeout value is ";gptmout$ 8500     Input prompt "Enter new value: ":gptmout$ 8505     If gptmout$="" then gptmout$="10" 8510     If asc(gptmout$)<48 or asc(gptmout$)>57 then print "
Entry must be a number.....try again" else goto 8525 8515     Wait 1 8520     Goto 8500 8525     If val(gptmout$)<=0 or val(gptmout$)>2.14748E+7 then print "
Value entered is not legal ( must be > 0 and < 2.14748E+7) Try again" else goto alt1 8530     Wait 1 8535     Goto 8500 8540 Alt_lok:     print "The front panel is in ";unlok$ 8545     Print "Should it be changed?" 8550     Call y_nanswr 8555     If answer$="n" then goto alt1 8560     If unlok$="LOCAL" then unlok$="LOCKOUT" else unlok$="LOCAL" 8565     Goto alt1 8570 Altloop:     print using "/fa6(20tfa/)s":"You may ALTER","1 Step label","2 RETURN to EDIT menu" 8575     Input prompt "
Enter ALTER # : ":altn 8580     Goto altn of stlab 8585     Call sav_data(proc$) 8590     Newprcd$(stp_ptr(count))=proc$ 8595     Return 8600 Br_nch:     call sequencr(count) 8605     Goto alt1 8610 Insertk:     path$=" EDIT: INSERT Step" 8615     Key$="F4" 8620     Call path_lab 8625     Call xpand(cnt$) 8630     If cnt$="" then return 8635     Gosub g_stptyp 8640     Return 8645 Deadkey:     keyflag=0 8650     Return 8655 Add_k:     path$=" EDIT: ADD New Step" 8660     Key$="F5" 8665     Call path_lab 8670     Print pagem$ 8675     Init var fn_num 8680     Gosub getstnum 8685     If cnt$="" or pos(cnt$,"ex",1) then return 8690     Gosub g_stptyp 8695     Return 8700 Gen_step:     stp_ptr(count)=nxseqndx 8705     Proc$=null$ 8710     Call instru(1,"
Press a Function Key",1) 8715     Call sequencr(count) 8720     Newprcd$(stp_ptr(count))=proc$ 8725     Return 8730 Getstnum:     call clr_bufr 8735     Input prompt "
Enter step # to ADD (1 to 100), press <RETURN> for AUTO NUMBER or               Enter <exit> to return to edit menu:  ":cnt$ 8740     If pos(cnt$,"ex",1) then return 8745     If cnt$="" then cnt$=str$(count+1) else goto chkrg 8750     Print "
AUTO STEP ";cnt$ 8755 Chkrg:     call chkrng(1,100,cnt$) 8760     If cnt$<>"" then goto goodstep else print "
STEP # OUT OF RANGE" 8765     Wait 3 8770     Return 8775 Goodstep:     count=val(cnt$) 8780     If stp_ptr(count)=0 then return 8785     Cnt$="" 8790     Print "
STEP ALREADY EXISTS." 8795     Goto getstnum 8800 Steptyp:     print using "/fa4(20tfa/)/fa1xs":"You may produce","S SINGLE Step","L LOOP step","G GOSUB step","R RETURN step","enter S, L, G, or R :" 8805     Input styp$ 8810     If not(pos("SLGR",styp$,1)) or styp$="" then goto steptyp 8815     Return 8820 Loop_s:     fn_num=nxtlpnum 8825     If fn_num>10 then print "
ALL LOOP STEPS USED - use other EDIT keys." else goto gen_fn 8830     Return 8835 Gen_fn:     call fornxt 8840     Actcod$="FN" 8845     Iocode$="FN" 8850     Init var low,up 8855     Unlok$="LOCKOUT" 8860     Call sav_data(proc$) 8865     Stp_ptr(count)=nxseqndx 8870     Newprcd$(stp_ptr(count))=proc$ 8875     Call sequencr(count) 8880     Return 8885 Dupe_s:     path$=" EDIT: DUPLICATE Step" 8890     Key$="F10" 8895     Call path_lab 8900     Input prompt "
Enter step # to DUPLICATE (1 to 100)  or  press <RETURN> for none : ":cnt$ 8905     If cnt$="" then return 8910     Call chkrng(1,100,cnt$) 8915 Bad:     if cnt$="" then print "
INVALID Step #" else goto valid_s 8920     Goto 8900 8925 Valid_s:     o_count=val(cnt$) 8930     If stp_ptr(o_count) then goto dup_it 8935     Print "
STEP ";o_count;"  non-existent." 8940     Goto 8900 8945 Dup_it:     if sequence(stp_ptr(o_count),ret_rn)=0 then goto singldup else print using "/fa/":"Illegal DUPE of a GOSUB or RETURN Step Type." 8950     Goto end_dupe 8955 Singldup:     gosub getstnum 8960     If cnt$="" or pos(cnt$,"ex",1) then return 8965     Stp_ptr(count)=nxseqndx 8970     Newprcd$(stp_ptr(count))=newprcd$(stp_ptr(o_count)) 8975     Call sequencr(count) 8980     Proc$=newprcd$(stp_ptr(o_count)) 8985     Call extract(proc$) 8990     Fn_num=val(fn_num$) 8995     If actcod$<>"FN" then goto end_dupe else proc$=loop$(fn_num,lstim) 9000     Call extract(proc$) 9005     Low=low+1 9010     Call sav_data(proc$) 9015     Loop$(fn_num,lstim)=proc$ 9020 End_dupe:     keyflag=0 9025     Print "Duplication of step ";o_count;" to step ";count;" completed." 9030     Return 9035 List_lk:     path$=" HARDCOPY LIST Steps" 9040     Key$="S1" 9045     Call path_lab 9050     Call x_printr 9055     Strem$=com$ 9060     Gosub lis1 9065     Keyflag=0 9070     Return 9075 Lis1:     print "Enter step(s) to LIST." 9080     Call num_in 9085     If count1<>0 then call list_s(strem$,count1,count2) 9090     Return 9095 Gen_gsub:     stp_ptr(count)=nxseqndx 9100     Gosub seq_init 9105     Print "
Enter step # to GOSUB (1 to 100) : "; 9110     Input cnt$ 9115     Call chkrng(1,100,cnt$) 9120     If cnt$<>"" then goto gsub1 else print "
STEP # OUT OF RANGE" 9125     Goto gen_gsub 9130 Gsub1:     sequence(stp_ptr(count),brchstrt)=val(cnt$) 9135 Gsub3:     input prompt "
Enter step to branch to or press <RETURN> for next step  : ":cnt$ 9140     If cnt$="" then cnt$="0" 9145     Call chkrng(0,100,cnt$) 9150     If cnt$="" then goto gsub3 9155     Sequence(stp_ptr(count),brchnxt)=val(cnt$) 9160     Newprcd$(stp_ptr(count))=null$&"gosub" 9165     Sequence(stp_ptr(count),ret_rn)=1 9170     Return 9175 Gen_rtn:     stp_ptr(count)=nxseqndx 9180     Gosub seq_init 9185     Sequence(stp_ptr(count),ret_rn)=1 9190     Sequence(stp_ptr(count),brchnxt)=0 9195     Newprcd$(stp_ptr(count))=null$&"return" 9200     Return 9205 Seq_init:     sequence(stp_ptr(count),brchnxt)=count+1 9210     Sequence(stp_ptr(count),brchfail)=0 9215     Sequence(stp_ptr(count),iterates)=0 9220     Sequence(stp_ptr(count),brchstrt)=0 9225     Sequence(stp_ptr(count),lg_lin)=0 9230     Sequence(stp_ptr(count),incr)=0 9235     Sequence(stp_ptr(count),ret_rn)=0 9240     Return 9245 Repl_ck:     path$=" EDIT: REPLACE Step" 9250     Key$="F3" 9255     Call path_lab 9260 Repstp:     input prompt "
Enter the step # to REPLACE (1 to 100) or press <RETURN> for none : ":cnt$ 9265     If cnt$="" then return 9270     Call chkrng(1,100,cnt$) 9275     If cnt$="" then goto repstp else count=val(cnt$) 9280     If stp_ptr(count)=0 then print "
No step to replace" else goto replacit 9285     Goto repstp 9290 Replacit:     call del_ete(count) 9295     Gosub g_stptyp 9300     Return 9305 G_stptyp:     enable abort 9310     Gosub steptyp 9315     Gosub pos("SLGR",styp$,1) of gen_step,loop_s,gen_gsub,gen_rtn 9320     Disable abort 9325     Return 9330     End 9400 Sub chgabort 9405     Print using "//fa2X3D" #102:"ABORT STEP",count 9410     Print using "//FA2X3D":"ABORT STEP",count 9415     Call del_ete(count) 9420     Flg1=0 9425     Branch edit_lab 9430     End 9500 Sub stakpush(var ret_step) 9505     Substp=sequence(stp_ptr(ret_step),brchstrt) 9510     If sequence(stp_ptr(ret_step),brchnxt)=0 then ret_step=ret_step+1 else ret_step=sequence(stp_ptr(ret_step),brchnxt) 9515     If stak_pt=20 then return 9520     Stak_pt=stak_pt+1 9525     Ret_stak(stak_pt)=ret_step 9530     Ret_step=substp 9535     Return 9540     End 9600 Sub stakpop(var ret_step) 9605     If stak_pt=0 then ret_step=ret_step+1 else ret_step=ret_stak(stak_pt) 9610     If stak_pt>0 then stak_pt=stak_pt-1 9615     Return 9620     End 9700 Sub num_in local first,second,again,count$ 9705 Again:     input prompt "  Enter one or two numbers (1,3 or 1 3) or press <RETURN> for none ":count$ 9710     If count$<>"" then goto first else count1=0 9715     Count2=0 9720     Return 9725 First:     count1=val(count$) 9730     If ask("chpos")<len(count$) then goto second else cnt1$=str$(count1) 9735     Call chkrng(1,100,cnt1$) 9740     If cnt1$="" then goto again else count2=count1 9745     Return 9750 Second:     count2=valc(count$,ask("chpos")) 9755     Cnt1$=str$(count1) 9760     Cnt2$=str$(count2) 9765     Call chkrng(1,100,cnt1$) 9770     If cnt1$="" then goto again else call chkrng(count1,100,cnt2$) 9775     If cnt2$="" then goto again else return 9780     End 9800 Sub chkrng(bottom,top var num$) local num 9805     Integer num 9810     Num$=numin$(num$) 9815     If num$="" then return 9820     Num=val(num$) 9825     If num<bottom or num>top then num$="" 9830     Return 9835     End 9900 Function numin$(num$) local nogo,num,numerr 9905     Integer num 9910     Numerr=0 9915     On error(101) then gosub nogo 9920     On error(80) then gosub nogo 9925     On error(89) then gosub nogo 9930     Num=val(num$) 9935     If numerr=0 then numin$=str$(num) else numin$="" 9940     Off error(101) 9945     Return 9950 Nogo:     numerr=1 9955     Advance 9960     End10000 Sub cmprss(begstep) local i,ii,renumseq10005     Integer i,ii10010     Xrfrnc=010015     Newrfrnc=010020     Ii=010025     For i=1 to 10010030       Ii=ii+110035       If stp_ptr(i)=0 and i>=begstep then ii=ii+110040       If ii>100 then exit to renumseq10045       Newrfrnc(i)=stp_ptr(ii)10050       Xrfrnc(ii)=i10055       Next i10060 Renumseq:     call seq_ren10065     Stp_ptr=newrfrnc10070     Return10075     End10100 Sub seq_ren local n,i,seq1,seq2,seq3,nexti,noprin10105     Integer n,i,b10110     Print "
Do you wish a record of steps renumbered listed to the thermal printer? "10115     Call y_nanswr10120     If answer$="n" then noprin=1 else noprin=010125     For i=1 to 10010130       N=newrfrnc(i)10135       B=010140       If n=0 then goto seq310145       If sequence(n,brchnxt)<1 then goto seq110150       If sequence(n,brchnxt)=xrfrnc(sequence(n,brchnxt)) then goto seq1 else sequence(n,brchnxt)=xrfrnc(sequence(n,brchnxt))10155       B=110160 Seq1:       if sequence(n,brchfail)<1 then goto seq210165       If sequence(n,brchfail)=xrfrnc(sequence(n,brchfail)) then goto seq2 else sequence(n,brchfail)=xrfrnc(sequence(n,brchfail))10170       B=110175 Seq2:       if sequence(n,brchstrt)<1 then goto seq310180       If sequence(n,brchstrt)=xrfrnc(sequence(n,brchstrt)) then goto seq3 else sequence(n,brchstrt)=xrfrnc(sequence(n,brchstrt))10185       B=110190 Seq3:       if noprin then goto nexti10195       If b then print #"prin:":"REN step ";i;" Branch"10200       If i<xrfrnc(i) then print #"prin:":"REN Branch step ";i;"    to  ";xrfrnc(i)10205 Nexti:       next i10210     Return10215     End10300 Sub del_ete(count) local delproc,dexit10305     If stp_ptr(count)=0 then goto dexit10310     Proctmp$=newprcd$(stp_ptr(count))10315     Call extract(proctmp$)10320     Fn_num=val(fn_num$)10325     If actcod$<>"FN" then goto delproc10330     Proctmp$=loop$(fn_num,lstim)10335     Call extract(proctmp$)10340     If low=0 then goto delloop else low=low-110345     Call sav_data(proctmp$)10350     Loop$(fn_num,lstim)=proctmp$10355     Goto delproc10360 Delloop:     loop$(fn_num,lstim)=null$10365     Loop$(fn_num,lacqr)=null$10370     Loop(fn_num,lstrt)=010375     Loop(fn_num,lstop)=010380     Loop(fn_num,lstpitr)=010385     Loop(fn_num,l_par)=010390     Loop(fn_num,llog)=010395 Delproc:     newprcd$(stp_ptr(count))=null$10400     Sequence(stp_ptr(count),brchnxt)=010405     Sequence(stp_ptr(count),brchfail)=010410     Sequence(stp_ptr(count),iterates)=010415     Sequence(stp_ptr(count),brchstrt)=010420     Sequence(stp_ptr(count),incr)=010425     Sequence(stp_ptr(count),ret_rn)=010430     Sequence(stp_ptr(count),lg_lin)=010435     Stp_ptr(count)=010440 Dexit:     return10445     End10500 Sub xpand(var cnt$) local stpmx,i,skip,renumseq,insrtstp,xpandit,xexit10505     Integer stpmx,skip,i10510     Stpmx=maxstep(1)10515     If stpmx<100 then goto insrtstp else print "
NO ROOM FOR INSERT"10520     Cnt$=""10525     Goto xexit10530 Insrtstp:     input prompt "
Enter step # to INSERT before (1 to 100) : ":cnt$10535     Call chkrng(1,100,cnt$)10540     If cnt$="" then print "
INVALID STEP #"10545     If cnt$="" then goto xexit else count=val(cnt$)10550     If stp_ptr(count)=0 then goto xexit10555     Stpmx=maxstep(count)10560     If stpmx<101-count then goto xpandit else print "
NO INSERT POSSIBLE after step ";cnt$;" , use DELETE key to make space."10565     Cnt$=""10570     Goto xexit10575 Xpandit:     xrfrnc=010580     Newrfrnc=010585     Skip=010590     For i=1 to 10010595       If i=count then skip=110600       If skip+i>100 then exit to renumseq10605       Newrfrnc(i+skip)=stp_ptr(i)10610       Xrfrnc(i)=i+skip10615       If stp_ptr(i)=0 and skip=1 then skip=0 else goto 1062510620       Xrfrnc(i)=i10625       Next i10630 Renumseq:     call seq_ren10635     Stp_ptr=newrfrnc10640 Xexit:     enable abort10645     Return10650     End10700 Function nxseqndx local nxndx,ndx10705     Integer ndx,nxseqndx10710     For ndx=1 to 10010715       If newprcd$(ndx)=null$ then exit to nxndx10720       Next ndx10725 Nxndx:     nxseqndx=ndx10730     Return10735     End10800 Function fitstep(start) local i10805     Integer i,maxstep,fitstep10810     For i=start to 10010815       If stp_ptr(i) then maxstep=maxstep+110820       Next i10825     If maxstep<101-start then fitstep=1 else fitstep=010830     Return10835     End10900 Sub sequencr(countr) local iter,loopstrt,brchout,looper,brancher,failbrch10905     Sequence(stp_ptr(countr),brchnxt)=010910     Sequence(stp_ptr(countr),brchfail)=010915     Sequence(stp_ptr(countr),iterates)=010920     Sequence(stp_ptr(countr),brchstrt)=010925     Print using "fa=72a":pagem$,"Branching menu"10930     Print using "/fa2(20tfa/)s":"You may CREATE","1 Multi-step loop ( repeat step(s) 'n' times )","2 Unconditional branch ( branch out of sequence )"10935     If pos(actcod$,"L",1) or actcod$="PF" then print using "20tfa":"3 Conditional branch ( branch on failed measurement )"10940     Input prompt "
Enter a number or press <RETURN> to continue :":answer$10945     If answer$="" then return10950     If asc(answer$)<49 or asc(answer$)>51 then goto 1094010955     Gosub val(answer$) of looper,brchout,failbrch10960     Goto 1092510965 Looper:     input prompt "
How many iterations to complete this loop? (1 to 32000) ":bstep$10970     Call chkrng(1,32000,bstep$)10975     If bstep$="" then goto looper else sequence(stp_ptr(countr),iterates)=val(bstep$)10980 Loopstrt:     input prompt "
What is the beginning step # of this multi-step loop? (1 to 100) ":bstep$10985     Call chkrng(1,100,bstep$)10990     If bstep$="" then goto loopstrt10995     If val(bstep$)>countr then goto loopstrt else sequence(stp_ptr(countr),brchstrt)=val(bstep$)11000     Return11005 Brchout:     input prompt "
Enter step number (1 to 100) to branch to after this step or press <RETURN> for next step. ":bstep$11010     If bstep$="" then bstep$="0"11015     Call chkrng(0,100,bstep$)11020     If bstep$="" and countr+1>100 then print "
Procedure terminates with this step."11025     If bstep$="" and countr+1<=100 then goto brchout else sequence(stp_ptr(countr),brchnxt)=val(bstep$)11030     Return11035 Failbrch:     if pos(actcod$,"L",1)>0 or actcod$="PF" then input prompt "
What step # should be branched to if this measurement fails limits?  Enter step number or press <RETURN> for next step : ":bstep$ else return11040     If bstep$="" then bstep$="0"11045     Call chkrng(0,100,bstep$)11050     If bstep$="" then goto failbrch else sequence(stp_ptr(countr),brchfail)=val(bstep$)11055     Return11060     End11100 Sub list_s(iostrem$,begstep,endstp) local nxi,list_stp,list_fn,list_typ,whos_it,list_act,loop_par,list_seq,loopseq,out_frmt,nxoutchr,go_ret11105     Integer j,i11110     Init var j,i11115     Open #500:iostrem$11120     Print pagem$11125     For i=begstep to endstp11130       If stp_ptr(i)=0 then goto nxi11135       J=stp_ptr(i)11140       Proctmp$=newprcd$(j)11145       Call extract(proctmp$)11150       Lab$=label$11155       Print #500 using "'# '3DS":i11160       If iocode$="FN" then gosub list_fn else gosub list_stp11165       Print #500 using "37('. ')/":11170 Nxi:       next i11175     If j then goto 1118511180     If begstep=endstp then print "No STEP ";begstep;" to list" else print "No STEPS to list in the range of ";begstep;" to ";endstp11185     If pos(iostrem$,"comm1",1) then print #500:chr$(12)11190     Return11195 List_stp:     gosub list_typ11200     Gosub list_act11205     If iocode$="TX" then print #500:lset$ else gosub out_frmt11210     Gosub list_seq11215     Return11220 List_fn:     fn_num=val(fn_num$)11225     Proc$=loop$(fn_num,lstim)11230     Call extract(proc$)11235     Gosub list_typ11240     Gosub list_act11245     Gosub loop_par11250     Print #500 using "/=80A/":"-   -   -   LOOP ACQUISITION   -   -   -"11255     Proc$=loop$(fn_num,lacqr)11260     Call extract(proc$)11265     Label$=lab$11270     Gosub list_typ11275     Gosub list_act11280     Gosub out_frmt11285     Gosub list_seq11290     Return11295 List_typ:     ty$=iocode$11300     If ty$="" then return11305     Print #500 using "10t15A5x/":label$11310     If ty$="PS" then print #500:"POWER SUPPLY -- ";11315     If ty$="DM" then print #500:"MULTI-METER -- ";11320     If ty$="DC" then print #500:"COUNTER -- ";11325     If ty$="MI" then print #500:"MULTI INTERFACE -- ";11330     If ty$="SI" then print #500:"SIGNAL SCANNER -- ";11335     If ty$="FG" then print #500:"FUNCTION GENERATOR -- ";11340     If ty$="CG" then print #500:"SCOPE CAL GENERATOR -- ";11345     If ty$="7D" then print #500:"DIGITIZER -- ";11350     If ty$="AA" then print #500:"DISTORTION ANALYZER -- ";11355     If ty$="SG" then print #500:"SIGNAL GENERATOR -- ";11360     If ty$="24" then print #500:"PORTABLE OSCILLOSCOPE -- ";11365     If ty$="XX" then print #500:"GPIB DEVICE --";11370     If ty$="TX" then print #500:"OPERATOR PROMPT -- "; else goto whos_it11375     Return11380 Whos_it:     v=val(log_unt$)11385     If seg$(instr$(v),10,2)<>"32" then print #500 using "'ID '6a'  PORT '1a'  ADDRESS '2a'  SECONDARY '2a/":seg$(instr$(v),1,6),seg$(instr$(v),7,1),seg$(instr$(v),8,2),seg$(instr$(v),10,2) else goto 1139511390     Return11395     Print #500 using "'ID '6a'  PORT '1a'  ADDRESS '2a/":seg$(instr$(v),1,6),seg$(instr$(v),7,1),seg$(instr$(v),8,2)11400     Return11405 List_act:     if actcod$="" then return11410     If actcod$="DW" then print #500:"ACQUIRE WAVEFORM ON FILE"11415     If actcod$="BA" then print #500:"ACQUIRE DATA BLOCK ON FILE"11420     If actcod$="PR" then print #500:"P-P VOLTS MEASUREMENT"11425     If actcod$="MR" and ty$<>"TX" then print #500:"MEASUREMENT"11430     If actcod$="NR" then print #500:"DEVICE SETUP - NO MEASUREMENT"11435     If actcod$="PL" then print #500 using "fa/fak5XfakS":"P-P VOLTS with LIMITS:","LOW = ",low,"HIGH = ",up11440     If actcod$="ML" and ty$<>"TX" then print #500 using "fa2xfak5xfaks":"MEASUREMENT LIMITS:","LOW = ",low,"HIGH = ",up11445     If actcod$="ML" and ty$="TX" then print #500 using "fa/fak5xfak":"OPERATOR ENTERS DATA with LIMITS:","LOW = ",low,"HIGH = ",up11450     If actcod$="MR" and ty$="TX" then print #500:"OPERATOR ENTERS DATA"11455     If actcod$="PF" then print #500:"OPERATOR ENTERS  PASS/FAIL"11460     If not(pos("NR PF",actcod$,1)) and ty$<>"TX" then print #500 using "/'ACQUISITION TIMEOUT: '2X10A":gptmout$11465     If not(actcod$="NR" or ty$="TX") then print #500 using "/'MEASUREMENT UNITS: '20t5as":unit$11470     Print #500 using "30t'TIME DELAY: '42t10a60t'PANEL MODE: '7a/":delay$,unlok$11475     Return11480 Loop_par:     print #500 using "/'PARAMETER: ""'FA'""'5X'UNITS: ""'FA'""'/":lset$,unit$11485     Print #500:"INCREMENT : ";11490     If loop(fn_num,l_par)=0 and loop(fn_num,llog)=0 then print #500:loop(fn_num,lstrt);" to ";loop(fn_num,lstop);" in increments of ";loop(fn_num,lstpitr)11495     If loop(fn_num,llog)=1 then print #500:loop(fn_num,lstrt);" to ";loop(fn_num,lstop);" for ";loop(fn_num,lstpitr);" iterations."11500     If loop(fn_num,l_par)=1 then print #500:int(loop(fn_num,lstop));" iterations."11505     Return11510 List_seq:     print #500 using "/":"
BRANCH Sequences"11515     If sequence(j,ret_rn) then goto go_ret11520     If sequence(j,iterates) then goto loopseq11525 Shgl:     print #500:"Branch to : ";11530     If sequence(j,brchnxt)=0 then print #500:"Next Step" else print #500:sequence(j,brchnxt)11535     If not(pos(actcod$,"L",1)>0 or actcod$="PF") then return11540     Print #500:"FAIL Branch to : ";11545     If sequence(j,brchfail)=0 then print #500:"Next Step" else print #500:sequence(j,brchfail)11550     Return11555 Loopseq:     print #500:"Loop to : ";sequence(j,brchstrt);11560     Print #500:"   for ";sequence(j,iterates);" iterations"11565     Gosub shgl11570     Return11575 Go_ret:     if sequence(j,brchstrt) then print #500:"GOSUB to : ";sequence(j,brchstrt) else print #500:"RETURN"11580     If sequence(j,brchstrt) then gosub shgl11585     Return11590 Out_frmt:     if actcod$="" or len(lset$)=0 then return11595     If actcod$<>"DW" and actcod$<>"BA" then print #500:"INSTRUMENT SETTINGS:" else print #500:"ACQUISITION FILE PARAMETERS:"11600     If pos(lset$,"%",1)=0 and pos(lset$,"@",1)=0 and pos(iostrem$,"COMM0",1) then print #500:lset$ else goto 1161011605     Return11610     Line$=""11615     Linelen=011620     For outchr=1 to len(lset$)11625       C$=seg$(lset$,outchr,1)11630       If asc(c$)<32 or asc(c$)>126 then c$="_"11635       Linelen=linelen+111640       Line$=line$&c$11645       If linelen>78 or outchr=len(lset$) then print #500:line$ else goto nxoutchr11650       Linelen=011655       Line$=""11660 Nxoutchr:       next outchr11665     Print #500:11670     Return11675     End11700 Function maxstep(count) local stp11705     Maxstep=011710     For stp=count to 10011715       If stp_ptr(stp)<>0 then maxstep=maxstep+111720       Next stp11725     Return11730     End11800 Sub infile local respd,verr,brnchout,ins_list,inptdata,missing,wrngdata,linkfile,endlink,tek$,lu$11805     Init var mis_ins,mis,newf,gport0,gport1,inslab1$,inslab2$,inslab3$,inslab4$11810     I$=",EOU=<0>,EOA=<0>,EOH=<0>,EOM=<10>"11820     Dim lu$ to 2,tek$ to 311825     On error(812) then gosub missing11830     On error(101) then gosub verr11835     On error(1000) then gosub brnchout11840     Print #102:"check configuration"11845 Respd:     if filelnk$=chr$(13) then call respond else gosub linkfile11850     Newf=011855     If filen$="" then return11860     Open #80:filen$&"(FOR=ITE)"11865     If newf=1 then goto respd11870     If type(80)=5 then input #80 using "I":count9 else goto wrngdata11875     For i=1 to count911880       If type(80)=4 then input #80 using "I":lab$ else goto wrngdata11885       Instr$(val(seg$(lab$,12,2)))=lab$11890       If len(lab$)=13 then call ckid11895       Next i11900     For i=count9+1 to 2811905       If type(80)=4 then input #80 using "I":instr$(i) else goto wrngdata11910       Next i11915     If filelnk$<>chr$(13) then goto 1196511920 Ins_list:     print pagem$11925     Init var mis,mis_ins11930     Print "

The following instruments must be at the listed port and address!"11935     Print using "2l20T'DEVICE'5X'PORT'5X'ADDRESS'5x'SECONDARY'//":11940     For i=1 to count911945       Getmem buffer instr$(i) using "6a1a2a2a":dev$,prt$,pri$,sec$11950       If sec$<>"32" then print using "20T6A6X1A10X2A8x2a":dev$,prt$,pri$,sec$ else print using "20t6a6x1a10x2a":dev$,prt$,pri$11955       Next i11960     Call commrbyt11965     For i=1 to count911970       Getmem buffer instr$(i) using "6a1a2a2a2a3a":dev$,prt$,pri$,sec$,lu$,tek$11975       Gpib$="GPIB"&prt$&"(PRI="&pri$&",SEC="&sec$&",TIM=10"11980       If not(pos(tek$,"TEK",1)) then open #i:gpib$&i$&"):" else open #i:gpib$&",EOM=<0>):"11985       If prt$="0" then gport0=1 else gport1=111990       If pos(tek$,"TEK",1) then input #i prompt "ID?":id$ else print #i:11995       Wait 0.512000       If pos(id$,"CG551AP",1) then id$="CG5001"12005       Wait 0.0112010       If not((pos(dev$,"XX",1)=0 and pos(id$,trim$(dev$),1)=0)) and not(mis_ins) then goto 1202512015       If sec$="32" then print "
          The "&dev$&" at address "&pri$&" on PORT "&prt$&" is missing" else print "
          The "&dev$&" at address "&pri$&","&sec$&" on PORT "&prt$&" is missing"12020       Mis=mis+112025       Mis_ins=012030       Next i12035     If mis then input prompt "
Add the missing instruments and enter ""CONT"" or press <RETURN> to abort the test: ":ret$ else print "
     All instruments present and accounted for . . . "12040     If mis and ret$="CONT" then goto ins_list12045     If mis=0 then goto inptdata12050     Init var count9,inslab1$,inslab2$,inslab3$,inslab4$12055     Return12060 Inptdata:     print using "2L=40A2X=12A ":"LOADING PROCEDURE FROM "&sysdev$&" FILE ",fsav$12065     If type(80)=4 then input #80 using "I":newprcd$ else goto wrngdata12070     If type(80)=4 then input #80 using "I":loop$ else goto wrngdata12075     If type(80)=6 then input #80 using "I":loop else goto wrngdata12080     If type(80)=5 then input #80 using "I":sequence else goto wrngdata12085     If type(80)=5 then input #80 using "I":stp_ptr else goto wrngdata12090     If type(80)<>1 then goto wrngdata12095     Close 8012100     Call setins12105     Print pagem$12110     Return12115 Missing:     mis_ins=112120     Advance12125 Wrngdata:     print using "lfa/fa//":"Warning!","Selected data file was not generated with this software!"12130     Trap12135 Brnchout:     print #"frtp:":"WARNING:"12140     Wait 312145     If pos(ask$("path"),"r_main",1) then branch run_lab else branch main_lab12150 Linkfile:     cr0=pos(filelnk$,chr$(13),cr1)12155     Cr1=pos(filelnk$,chr$(13),cr0+1)12160     If cr1=0 then goto endlink12165     Filen$=seg$(filelnk$,cr0+1,cr1-cr0-1)12170     Fsav$=filen$12175     Return12180 Verr:     print using "lfa/fa//":"Warning!","Selected data file was not generated with this software!"12185     Goto brnchout12190 Endlink:     filen$=""12195     Return12200     End12300 Sub err_88812305     Print #102:bell$;"INVALID BAUD VALUE"12310     Wait 212315     Print "%!1[2A%!0"12320     Branch set_baud12325     End12400 Sub abormenu12405     Set console "FRTP:"12410     Print #102:bell$;"HANDLING AN ABORT"12415     Branch clr_mem12420     End12500 Sub gkeydisp local ll1$12505     If termid=4105 then ll1$="LLA4" else ll1$="LLA5"12510     If verflag then compress12515     Print "%!0";12520     Print bmap$;12525     Print bell$&ll1$&"LBC1RW `` @8so?_RV `` @7o"&chr$(127)&"?_";12530     If pos(ask$("path"),"pfkey",1) then goto 1254012535     Print page$12540     Print "MC0MT5KA0"&pagew$&"     
"&khead$12545     Image 7X4(7A)7X4(7A)12550     Image 7X4(7A)7X2(7A)52T12A12A12555     Print "LF6n @"12560     Print using 12545:keylab1$12565     Print using 12545:keylab2$12570     Print "LF3v @MT3ML1LT:"12575     Print using "8X'F1'5X'F2'5X'F3'5X'F4'12X'F5'5X'F6'5X'F7'5X'F8'":12585     Print "LF3l""ULG4l""ULG4l$[LG3l$[LG3l""U"12590     Print "LF3l%TLG4l%TLG4l'ULG3l'ULG3l%T"12595     Print "LF3l(NLG4l(NLG4l*OLG3l*OLG3l(N"12600     Print "LF3l+HLG4l+HLG4l-NLG3l-NLG3l+H"12605     Print "LF3l0RLG4l0RLG4l2XLG3l2XLG3l0R"12610     Print "LF3l3QLG4l3QLG4l5RLG3l5RLG3l3Q"12615     Print "LF3l6KLG4l6KLG4l8QLG3l8QLG3l6K"12620     Print "LF3l9JLG4l9JLG4l;KLG3l;KLG3l9J"12625     Print "MT5LF3f @"12630     Image 6x7a1x3(7a)7x4(7a)12635     If pos(ask$("path"),"instru",1) then print using 12630:keylab3$ else goto 1265012640     If pos(ask$("path"),"instru",1) then print using 12630:keylab4$ else goto 1265012645     Goto 1266012650     If keylab3$(7)="MT3PASS " then print using 12550:keylab3$ else print using 12545:keylab3$12655     If keylab3$(7)="MT3PASS " then print using 12550:keylab4$ else print using 12545:keylab4$12660     Print "MPH8LP/j @1LG0| @LG0|?_LG/j?_LEKA1"12665     Return12670     End12700 Sub map_key12705     Print "KDH82@6C9KDH92@6C0KDH:2@4C1KDH;2@4C2KDH<2@4C3KDH=2@4C4KDH>2@4C5KDH?2@4C6";12710     Print "KDH02@6C1KDH12@6C2KDH22@6C3KDH32@6C4KDH42@6C5KDH52@6C6KDH62@6C7KDH72@6C8";12715     Print "KDG-24C0";12720     Return12725     End12800 Sub tm_conf local sel_port,next_pri,all_done,check_id,devlist0,tek_inst,new_id,tm_inst,err_811,err_812,err_818,getout,sec,second12805     Image <6a1a>2a>2a>2a>3a12810     Print using "2L=72A/":"Make sure all GPIB connections have been made"12815     Print using "=72A/":"and that the power has been turned on."12820     Input prompt "                      Press <RETURN> when ready ":ret$12825     Print "
Do you wish to check secondary addresses during the GPIB configuration"&chr$(13)&"process?"12830     Call y_nanswr12835     If answer$="y" then nosec=0 else nosec=112840     Print pagem$12845     Print "KA1LV1"&ll$12850     Ret2prt$=ask$("select")12855     Integer stb,pri,prim,sec,bus,try,err818,port,count9,err812,cntr12860     Init var try,stb,pri,instr$,port,id$,bus,count9,gport0,gport1,inslab1$,inslab2$,inslab3$,inslab4$12865     On error(811) then gosub err_81112870     On error(812) then gosub err_81212875     On error(818) then gosub err_81812880 Sel_port:     gpib$="GPIB"&str$(port)12885     Select gpib$&"(SPE=.1,TIME=.2):"12890     Set driver gpib$&"(ma=30):"12895     Init var bus,try12900     Poll stb,pri,sec;012905     Print bell$12910     Print #102:"POLLING "&gpib$12915     Bus=112920     Print using "L=75A ":"* * * POLLING PORT "&gpib$&" * * *"12925     Print using "5t65('-')/ 25t'DEVICE'22x'ADDRESS'":12930     Print using "26t'""ID""'18x'PRIMARY'3x'SECONDARY'/5t65('-')/":12935   Rem LOOK FOR VALID PRIMARY ADDRESSES12940     For prim=0 to 2912945       Sec=3212950 Seek:       err812=012955       Wbyte atn(mta,32+prim,96+sec),chr$(10),eoi,atn(unt,unl)12960       If not(err812) and sec<32 then cntr=cntr+1 else goto 1297012965       Goto 1297512970       If not(err812) and sec=32 then cntr=cntr+1 else goto second12975       If cntr>14 then goto getout else gosub check_id12980       If sec=32 then goto next_pri12985 Second:       if nosec then goto next_pri12990       Sec=sec*(sec<32)+1*(sec<>32)12995       If sec<32 then goto seek13000 Next_pri:       next prim13005 All_done:     port=port+113010     Cntr=013015     If pos(ask$("driver"),"GPIB1",1) and port=1 then goto sel_port13020     If not(pos(ask$("driver"),"GPIB1",1)) and term then print using "L2(=75A/)/=75A":"GPIB1 NOT AVAILABLE","ON THIS 4041  ","* * * * *"13025     Select ret2prt$13030     Print #102:"POLLING IS COMPLETE"13035     Print using "/=75a//=75a":"AUTO-CONFIGURE IS COMPLETE","Press <RETURN> to continue"13040     Input ret$13045     Call setins13050     Return13055 Getout:     print "

WARNING :   The number of instruments on GPIB port : ",port,"  exceeds the EZ-TEST recommended maximum of 14."13060     Print "
Reconfigure the port and try again"13065     Input prompt "

Press <RETURN> to exit to MAIN MENU":ret$13070     Return13075 Check_id:     count9=count9+113080     Wbyte sdc(prim,sec+96),atn(unt,unl)13085     If pos(gpib$,"GPIB0",1) then gport0=113090     If pos(gpib$,"GPIB1",1) then gport1=113095     Open #count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOM=<10>,tim=10):"13100     Id$=""13105     Input #count9 prompt "ID?":id$13110     Wbyte sdc(prim,sec+96),atn(unt,unl)13115     If pos(id$,"TEK/",1) then goto tek_inst13120     Input prompt "
PORT "&str$(port)&",ADDRESS "&str$(prim)&";"&str$(sec)&" - Enter Instrument Name (4 characters) : ":id$13125     If len(id$)<4 then id$=id$&"    "13130     Goto new_id13135 Devlist0:     if id$="" then instr$(count9)="  N/A " else putmem buffer instr$(count9) using 12805:seg$(id$,pos(id$,"/",1)+1,pos(id$,",",1)-pos(id$,"/",1)-1),str$(port),str$(pri),str$(sec),str$(count9),"   "13140 Tek_inst:     id$=seg$(id$,pos(id$,"/",1)+1,pos(id$,",",1)-pos(id$,"/",1)-1)13145     If id$="CG551AP" then id$="CG5001"13150     If id$="2465" or id$="2445" then id$=id$&"  "13155     If len(id$)>5 then goto 1316513160     Putmem buffer id$ using "fa6t":id$13165     If pos("DM5010DC5009DC5010AA5001MI5010SI5010FG5010SG5010PS5010CG5001PS50042465  2445  7D20  ",id$,1) then goto tm_inst13175     Id$="XX"&seg$(id$,1,4)13180     Open #count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOH=<0>,EOA=<0>,EOU=<0>,EOM=<0>,TIM=10):"13185     Putmem buffer instr$(count9) using 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"TEK"13190     Goto 1321013195 New_id:     id$="XX"&seg$(id$,1,4)13200 Tm_inst:     if not(pos(seg$(id$,1,2),"XX",1)) then putmem buffer instr$(count9) using 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"TEK" else putmem buffer instr$(count9) using 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"   "13205     If pos(id$,"XX",1) then open #count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOH=<0>,EOA=<0>,EOU=<0>,EOM=<10>,TIM=10):" else open #count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOM=<0>,TIM=10):"13210     If sec<>32 then print using "25T<20A5X2D9x2d":id$,prim,sec else print using "25t<20a5x2d":id$,prim13215     Return13220 Err_811:     print13225     Advance13230 Err_812:     err812=113235     If bus=0 then goto 1324513240     Advance13245     If try and not(bus) then branch all_done13250     Print bell$13255     If term then print using "2L=75A//=75A":"THERE ARE NO ACTIVE DEVICES AT "&gpib$13260     Try=113265     Retry13270 Err_818:     err818=113275     Advance13280     End13300 Sub r_main local deadkey,nu_test,run_test,step_tst,run_link,go2main,runhelp,plotwfrm,get_data,plotfn,run_seg,rseg1,logdat,wrngdata13305     On abort then call abort2ex13310     On error(703 to 752) then gosub wrngdata13315     On error(858) then gosub wrngdata13320     Log_all=113325     Init var tnam$,opname$,t_dev$13330     Outdata$="S"13335     Print pagem$13340 Run_lab:     khead$="TEST EXECUTION MENU"13345     Data "LOG","RUN","","","RETRV","","",""13350     Data "FAIL","SEG","","","DATA","","","HELP"13355     Data "SETUP","RUN  ","STEP ","RUN  ","STORE","PULSE","PLOT ","MAIN"13360     Data "TEST ","TEST ","TEST ","LINK ","DATA ","PARAM","LOOPS","MENU"13365     Init var keylab1$,keylab2$,keylab3$,keylab4$,s_tep13370     Restore 1334513375     Read keylab1$,keylab2$,keylab3$,keylab4$13380     If log_all=0 then keylab2$(1)="ALL"13385     Call gkeydisp13390     Enable keys13395     Print pagem$13400     Print "Press a function key"13405     Keyflag=013410     Wait13415     Gosub keyflag of nu_test,run_test,step_tst,run_link,stor_dat,plotwfrm,plotfn,go2main,logdat,run_seg,deadkey,deadkey,get_data,deadkey,deadkey,runhelp13420     Map$=bmap$13425     If mbranch then return13430     If keyflag=0 then goto 1339013435     Goto run_lab13440 Nu_test:     init var filelnk$,cr0,cr113445     Data_lu=10013450     Outdata$="S"13455     Filelnk$=chr$(13)13460     Print pagem$13465     Print using "=75A":"TEST SET-UP"13470     Print "
Do you want to get a test from "&sysdev$&"?"13475     Call y_nanswr13480     If answer$="N" then goto 13575 else print "
Do you want to link multiple files?"13485     Call y_nanswr13490     If answer$="Y" then goto 1351513495     Call infile13500     Filex$=filen$13505     Fsav$=filen$13510     Goto 1357513515     Dir "(lon=yes)"13520     Newf=013525     Cr0=013530     Input prompt "Enter filename or press <RETURN> to end the sequence : ":filen$13535     If len(filen$) then open #80:filen$&"(for=ite)" else goto 1357513540     If newf=1 then print "
File ";filen$;" not found on "&sysdev$&" . . ." else goto 1355013545     Goto 1352013550     Input #80 using "I":count9,instr$,newprcd$13555     If newf then goto 1352013560     Filelnk$=filelnk$&filen$&chr$(13)13565     Cr0=cr0+113570     If cr0<10 then goto 1353013575     Call output13580     If outdata$<>"" then call storset13585     Outset$=outdata$13590     Datlutmp=data_lu13595     Input prompt pagem$&"

Enter Test Name: ":tnam$13600     Input prompt "

Enter operator name: ":opname$13605     Input prompt "

Enter the test device ID name or number: ":t_dev$13610     Print "
Will test be run with operator interaction (IE: Failure menu displayed if step  fails limits during execution)?"13615     Call y_nanswr13620     If answer$="y" then f_flag$="YES" else f_flag$="NO"13625     Keyflag=113630     Return13635 Wrngdata:     print using "lfa/fa//":"Warning!","Selected data file was not generated with this software!"13640     Newf=113645     Advance13650 Run_test:     print pagem$13655     Call sdc_all13660     Begstp=113665     Init var me_data$,mecount,start,start$,finish,finish$,date$13670     Endstp=10013675     If mis=0 then call begin else print #"prin(ind=0):":"TEST ";filen$;" ABORTED","MISSING INSTRUMENTS"13680     Data_lu=70013685     Outdata$=""13690     Keyflag=213695     Call sdc_all13700     Return13705 Step_tst:     s_tep=113710     Call sdc_all13715     Init var me_data$,mecount13720     Gosub run_seg13725     Keyflag=313730     Call sdc_all13735     Return13740 Run_link:     if filelnk$=chr$(13) then return13745     Call sdc_all13750     Begstp=113755     Endstp=10013760     Init var me_data$,mecount,start,start$,finish,finish$,date$13765     If cr1=0 then goto 1378513770     If verflag then compress13775     Print pagem$13780     If mis=0 then call begin else print #"prin(ind=0):":"TEST ";filen$;" ABORTED ","MISSING INSTRUMENTS"13785     If cr1<len(filelnk$) then call infile else goto 1379513790     Goto 1376513795     Init var cr0,cr113800     Close data_lu13805     Data_lu=70013810     Keyflag=413815     Call sdc_all13820     Return13825 Go2main:     wipe=113830     Mbranch=113835     Return13840 Deadkey:     keyflag=013845     Return13850 Runhelp:     path$=" HELP for TEST EXECUTION MENU"13855     Key$="F7"13860     Call path_lab13865     Helpfil$="HEXECU"13870     Init var path$13875     Call prinhelp13880     Keyflag=013885     Return13890 Plotwfrm:     newf=013895     Map$=cmap$13900     Print "Specify file name for waveform retrieval . . ."13905     Call respond13910     If filen$="" then return13915     Open #80:filen$&"(EOU=<13>)"13920     If newf=1 then print "
File not found !" else goto 1393013925     Goto plotwfrm13930     Input #80:id$13935     If pos(id$,"7D20",1)=0 then print "
FILE DOES NOT CONTAIN 7D20 WAVEFORM ! " else goto 1394513940     Goto 1390013945     Input #80:label$,wfpre$13950     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))13955     Integer wfdata(wfpts)13960     Input #80:wfdata13965     If grph and plot then goto 13980 else print "
Graphics Rompacks Not Installed !"13970     Dsp_flg=013975     Goto 1401013980     Dsp_flg=113985     GINIT 700,4113,113990     Print "LI100"&page$&cmap$13995     Print "
Waveform retrieved !"14000     Call norwfm20(wfdata,wfpre$,normdata)14005     Call plotwf20(normdata,wfpre$,1,2,3,0,"7D20 WFM "&" File : "&filen$&"   "&label$&",TEKTRONIX  EZ-TEST   S/W,TIME,VOLTS,,")14010     If sgpr then goto 14025 else print "
PULSE PARAMETERS Not Available - Signal Processing Rompack Not Installed !"14015     Call commrbyt14020     Goto 1416514025     Print "
Enter Pulse analysis parameter requirements . . ."14030     Print "
Beginning point on waveform (0 to "&str$(wfpts)&") : ";14035     Input bgn14040     Print "
Ending point on waveform (0 to "&str$(wfpts)&") : ";14045     Input e_nd14050     Print "
Base level % (0 to 100) : ";14055     Input base14060     Print "
Top level % (0 to 100) : ";14065     Input top14070     Print "
% Level for period (0 to 100) : ";14075     Input perlvl14080     Print pagem$14085     Call pulse(wfdata,wfpre$,bgn,e_nd,base,top,perlvl,dsp_flg,ans)14090     Data "WAVEFORM  MAX  ","WAVEFORM  MIN  ","WAVEFORM  MID  ","WAVEFORM  P-P  ","WAVEFORM  TOP  ","WAVEFORM  90% ","WAVEFORM  50% ","WAVEFORM  10% ","WAVEFORM  BASE ","OVERSHOOT  (%) ","UNDERSHOOT (%) ","RISETIME ","FALLTIME ","WIDTH ","PERIOD "14095     Restore 1409014100     Print "Want a strip printout?"14105     Call y_nanswr14110     If answer$="N" then goto 1414514115     Print #"PRIN:" using "//3(=20A/)":id$,label$,"PULSE PARAMETERS"14120     For i=1 to 1514125       Read lab$14130       Print #"PRIN:" using "FA/N/":lab$,ans(i)14135       Next i14140     Print #"PRIN:" using "10L":14145     Print "Want further analysis?"14150     Call y_nanswr14155     If answer$="Y" and dsp_flg then goto 1400514160     If answer$="Y" and dsp_flg=0 then goto 1402514165     Print page$&"LLA>"14170     Workspac=014175     Return14180 Get_data:     newf=014185     Path$=" Retrieve Test Data File"14190     Key$="F5"14195     Call path_lab14200     Print "Specify file name for test data retrieval . . ."14205     Call respond14210     If filen$="" then print pagem$ else goto 1422014215     Goto 1431014220     Open #81:filen$14225     If newf then print "
File not found! " else goto 1424014230     Close 8114235     Goto get_data14240     Input prompt "
Output device? (S=Screen, L=Line printer or M=Memory) :":outdev$14245     If outdev$<>"L" then goto 1426514250     Call x_printr14255     Copy filen$ to ask$("lu",800)14260     Goto 1431014265     If outdev$<>"S" then goto 1428514270     Print pagem$14275     Copy filen$ to ask$("console")14280     Goto 1431014285     If outdev$<>"M" then goto 1430014290     Call fillmed14295     Goto 1431014300     Print "
WHAT !"14305     Goto 1424014310     Close 8114315     Init var path$14320     If filen$<>"" then call commrbyt14325     Return14330 Plotfn:     if grph and plot then goto 14345 else print "
NO LOOP DATA AVAILABLE  or  GRAPHICS ROMS NOT INSTALLED"14335     Keyflag=014340     Return14345     Path$="  Plot LOOP Test Data"14350     Key$="S8"14355     Call path_lab14360     Call graphfn14365     Print pagem$14370     Init var path$14375     Return14380 Run_seg:     print pagem$14385     If mis=0 then goto rseg1 else print #"prin:":"Test ";filen$;" ABORTED","Missing Instruments"14390     Return14395 Rseg1:     print "Enter step(s) to RUN."14400     Call num_in14405     If count1=0 then goto 1443514410     Call sdc_all14415     Init var me_data$,mecount14420     Begstp=count114425     Endstp=count214430     Call begin14435     Data_lu=70014440     Outdata$=""14445     Keyflag=1014450     Call sdc_all14455     Return14460 Stor_dat:     call output14465     Call storset14470     Call stordata14475     Return14480 Logdat:     if log_all=0 then log_all=1 else log_all=014485     If log_all then print "
All measurement data will be saved." else print "
Only failure data will be saved."14490     Wait 214495     Return14500     End14600 Sub begin local outdev14605     Init var stp,logd,fntest,out$,count,repeat,stimset$,stak_pt14610     If cr1=0 then init var me_data$,mecount else mecount=mecount+114615     If cr1=0 then goto 14620 else putmem buffer me_data$(mecount) using "'Proc '12a58t":filen$14620     Avg=114625     Me_max=val(seg$(ask$("var",me_data$),4,6))14630     For kk=1 to 10014635       Seqr(kk)=sequence(kk,iterates)14640       Next kk14645     If start$<>"" then goto 1466014650     Start=ask("time")14655     Start$=seg$(ask$("time"),11,8)14660     If gport0 then select "GPIB0:" else goto 1467014665     Wbyte llo14670     If gport1 then select "GPIB1:" else goto 1468014675     Wbyte llo14680     Call r_runit14685     Finish=ask("time")14690     Date$=ask$("time")14695     Finish$=seg$(date$,11,8)14700     If cr1>1 and cr1<len(filelnk$) then return14705     Data_lu=70014710 Outdev:     outdata$=outset$14715     Call stordata14720     Return14725     End14800 Sub r_runit local r_run0,r_run1,r_run2,r_run3,r_run4,run_nofn,lp_step,next_lp,seq_bad,ret_sub,singl,st_sngl14805     Print #"FRTP(rate=.05,vie=.05):":"TEST FILE ";fsav$14810     Stp=begstp14815     Nxstp=begstp14820 R_run0:     if stp=0 or stp>100 or nxstp>100 or nxstp>endstp then return14825     If mecount<me_max then goto r_run114830     Print "KA0LF7f-N                                     LFf-NProcedure Terminated after "&str$(me_max)&" AcquisitionsKA1"14835     Return14840 R_run1:     if nxstp>=begstp then stp=nxstp14845     If stp_ptr(stp)=0 then stp=stp+1 else goto r_run214850     Nxstp=stp14855     Goto r_run014860 R_run2:     if sequence(stp_ptr(stp),ret_rn)=1 then goto ret_sub14865     Proc$=newprcd$(stp_ptr(stp))14870     If proc$=null$ then goto r_run314875     Call extract(proc$)14880     Call run_step14885     If actcod$="FN" then call fornext else gosub run_nofn14890 R_run3:     if p_f$="FAIL" then goto seq_bad14895     If sequence(stp_ptr(stp),brchstrt) then goto lp_step14905     If sequence(stp_ptr(stp),brchnxt) then nxstp=sequence(stp_ptr(stp),brchnxt) else nxstp=stp+114910     Goto r_run414915 Lp_step:     if seqr(stp_ptr(stp))>1 then goto next_lp14925     Seqr(stp_ptr(stp))=sequence(stp_ptr(stp),iterates)14930     If sequence(stp_ptr(stp),brchnxt) then nxstp=sequence(stp_ptr(stp),brchnxt) else nxstp=stp+114935     Goto r_run414940 Next_lp:     seqr(stp_ptr(stp))=seqr(stp_ptr(stp))-114945     Nxstp=sequence(stp_ptr(stp),brchstrt)14950     Goto r_run414955 Seq_bad:     if sequence(stp_ptr(stp),brchfail) then nxstp=sequence(stp_ptr(stp),brchfail) else nxstp=stp+114960 R_run4:     gosub singl14965     Goto r_run014970 Run_nofn:     if iocode$="TX" then call r_text else call setit14975     Return14980 Ret_sub:     if sequence(stp_ptr(stp),brchstrt) then call stakpush(nxstp) else call stakpop(nxstp)14985     Gosub singl14990     Goto r_run014995 Singl:     if s_tep then print "
" else goto st_sngl15000     Print "Press ""STEP TEST"" key (3) for next test step ";((nxstp max begstp) max stp+1)15005     Keyflag=015010     If keyflag<>3 then goto 1501015015     Print pagem$15020 St_sngl:     keyflag=015025     P_f$="PASS"15030     Return15035     End15100 Sub blok_get local eompos,commapos15105     Init var blokbuf$,acqblok$15110     Blocklu$=ask$("lu",outadd)15115     Eompos=pos(blocklu$,"EOM",1)15120     Commapos=pos(blocklu$,",",eompos)15125     Rep$(blocklu$,eompos,commapos-eompos)="EOM=<0>"15130     Init var oldfil,eof_err15135     Print "
Acquiring data block . . . "15140     Input #blocklu$ buffer blokbuf$:acqblok$15145     Call storem15150     Return15155     End15200 Sub setit local nopause15205     If actcod$="FN" then goto nopause15210     Outadd=val(log_unt$)15215     Outadd$=ask$("lu",outadd)15220     Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15225     Open #outadd:outadd$15230     If actcod$="NR" then print #outadd:lset$ else goto nopause15235     Call progwat15240     Return15245 Nopause:     init var rdata,rdata$15250     If actcod$="DW" then call fn7dwv(outadd) else goto 1526015255     Return15260     If actcod$="BA" then call blok_get else goto 1527015265     Return15270     If pos("SG SI FG PS 7D MI 24 XX",iocode$,1) then call fnmi(outadd)15275     If iocode$="DC" then call fndc(outadd)15280     If iocode$="CG" then call fncg(outadd)15285     If pos("DM AA",iocode$,1) then call fndm(outadd)15290     Return15295     End15400 Sub fornext local stepsize,n_steps,n,frn0,sign,temp$,dely15410     Logd=015415     Fn_num=val(fn_num$)15420     Temp$=label$15425     Proctmp$=loop$(fn_num,lstim)15430     Call extract(proctmp$)15435     Dely1=delay15440     Ins1=val(log_unt$)15445     Outadd$=ask$("lu",ins1)15450     Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15455     Open #ins1:outadd$15460     Suffix$=unit$15465     Set1$=lset$15470     If loop(fn_num,l_par) then goto acqrdev15475 Frn0:     getmem buffer lset$ dels ";":stimset$15480     Lset$=seg$(lset$,ask("buffer")+1,len(lset$))15485     If lset$="" then goto acqrdev else goto frn015490 Acqrdev:     proctmp$=loop$(fn_num,lacqr)15495     Call extract(proctmp$)15500     Label$=temp$15505     Ins2=val(log_unt$)15510     Outadd$=ask$("lu",ins2)15515     Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15520     Call storem15525     Open #ins2:outadd$15530     Stepsize=loop(fn_num,lstpitr)15535     N_steps=loop(fn_num,lstpitr)-115540     If loop(fn_num,llog) then sign=sgn(loop(fn_num,lstrt))15545     If loop(fn_num,llog) then stepsize=(lgt(sign*loop(fn_num,lstop))-lgt(sign*loop(fn_num,lstrt)))/n_steps else n_steps=(loop(fn_num,lstop)-loop(fn_num,lstrt))/stepsize15550     If n_steps<>int(n_steps) then n_steps=int(n_steps)+115555     For n=0 to n_steps15560       If loop(fn_num,llog) then fntest=sign*10^(lgt(sign*loop(fn_num,lstrt))+n*stepsize) else fntest=loop(fn_num,lstrt)+n*stepsize15565       If n=n_steps then fntest=loop(fn_num,lstop)15570       If loop(fn_num,l_par) then print #ins1:set1$ else print #ins1:set1$;str$(fntest)&suffix$15575       Logd=logd+115580       Gosub dely15585       Call setit15590       Next n15595     Return15600 Dely:     if dely1=0 then return else strt=ask("time")15605     If ask("time")-strt>=dely1 then return else goto 1560515610     Return15615     End15700 Sub fndc(outadd) local timeout15705     Init var repeat,rdtemp15710     For m=1 to avg15715       If len(lset$) then print #outadd:lset$15720       Call progwat15725       If seg$(actcod$,1,1)="P" then goto 1574015730       If pos(lset$,"?",1) then input #outadd:rdata else input #outadd prompt "SEND":rdata15735       Goto 1574515740       Call dcp_pk(outadd,rdata)15745       Rdtemp=rdtemp+rdata15750       Next m15755     Rdata=rdtemp/avg15760     Call storem15765     If repeat then goto 1570515770     Avg=115775     Return15780     End15800 Sub fndm(outadd)15805     Init var repeat,rdtemp15810     For m=1 to avg15815       If len(lset$) then print #outadd:lset$15820       Call progwat15825       If pos(lset$,"?",1) then input #outadd:rdata else input #outadd prompt "SEND":rdata15830       Rdtemp=rdtemp+rdata15835       Next m15840     Rdata=rdtemp/avg15845     Call storem15850     If repeat then goto 1580515855     Avg=115860     Return15865     End15900 Sub fn7dwv(outadd)15905     Old_lu$=ask$("lu",outadd)15910     Open #outadd:seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",eom=<0>,eoa=<0>):"15915     Init var oldfil,eof_err,memnum$,mode$15920     Input #old_lu$ prompt "di? csw":memnum$15925     Memnum=val(memnum$)15930     Print "
Acquiring waveform . . . "15935     Print #old_lu$:"DA ME:"&str$(memnum)15940     Input #old_lu$ prompt "WFM? ENC":mode$15945     Mode$=seg$(mode$,pos(mode$,":",1)+1,len(mode$))15950     Call getwfm20(outadd,mode$,wfpre$,wfdata)15955     Call storem15960     Return15965     End16000 Sub fncg(outadd) local ctr,ret,temp$16005     On error(811) then gosub err81116010     Select ask$("lu",outadd)16015     Init var rdtemp,repeat,cgdata$,status,address,dev,ctr,temp$16020     Wait 116025     Gptmout=valc(ask$("lu",outadd),pos(ask$("lu",outadd),"TIM=",1))16030     For m=1 to avg16035       If len(lset$) then print #outadd:lset$16040       Print "
Press CG 5001 CONTINUE button to take the measurement."16045       Call progwat16050       Input #outadd prompt "read?":cgdata$16055       Rdata=val(cgdata$)16060       Print "
Measurement acquired !"16065       If pos(ask$("path"),"fornext",1) then goto 1609016070       U_d=valc(cgdata$,pos(cgdata$,"D",1))16075       Putmem buffer u_d$ using "5J":u_d16080       Unitspc$=u_d$16085       Unit$=trim$(unitspc$)16090       Rdtemp=rdtemp+rdata16095       Next m16100     Rdata=rdtemp/avg16105     Rdata=round(rdata*1.0E+10)/1.0E+1016110 Ret:     call storem16115     If repeat then goto 1601516120     Avg=116125     Return16130 Err811:     ctr=ctr+116135     Ctrend=60/gptmout16140     If ctr>=ctrend then input prompt "

It has now been one(1) minute since the prompt.  Do you wish to continue or abort the measurement <c> or <a>: ":temp$ else retry16145     If temp$<>"c" and temp$<>"a" then goto 1614016150     If temp$="a" then goto 16160 else ctr=016155     Retry16160     Rdata=016165     Branch ret16170     End16200 Sub dcp_pk(digcntr var p_pampl) local att1_tes,pk_pk16205     Init var n_pk,p_pk16210     If seg$(instr$(digcntr),1,6)="DC5010" then range=2 else range=316215     Print #digcntr:"CHA A;ATT 5;COU DC;"16220     Print #digcntr:"AUTO;"16225     Input #digcntr prompt "CHA A;MIN?;MAX?;":n_pk,p_pk16230     If n_pk>-5*range and p_pk<5*range then goto att1_tes16235     Print #digcntr:"COU AC;"16240     Wait 0.516245     Print #digcntr:"AUTO;"16250     Input #digcntr prompt "CHA A;MIN?;MAX?;":n_pk,p_pk16255 Att1_tes:     if not(n_pk>-range and p_pk<range) then goto pk_pk16260     Input #digcntr prompt "ATT 1;AUTO;CHA A;MIN?;MAX?;":n_pk,p_pk16265 Pk_pk:     p_pampl=p_pk-n_pk16270     Return16275     End16300 Sub fnmi(outadd) local space1,binget,hexget,decget,arg_end,fnmi_out,valerr16305     Init var rdtemp,repeat16310     For m=1 to avg16315       On error(101) then gosub valerr16320       If len(lset$) then print #outadd:lset$16325       Call progwat16330       Input #outadd:rdata$16335       If iocode$="MI" then goto 1635016340       Rdata=val(rdata$)16345       Goto arg_end16350       Space1=pos(rdata$," ",1)16355       Semicol=pos(rdata$,";",space1)16360       If pos(rdata$," ",space1+1) then space1=space1+1 else goto 1637516365       Goto 1636016370       Space1=space1+116375 Binget:       if pos(rdata$,"B",space1) then rdata$=seg$(rdata$,space1+2,semicol-space1-2) else goto hexget16380       Getmem buffer rdata$ using "20B":rdata16385       Goto arg_end16390 Hexget:       if pos(rdata$,"H",space1) then rdata$=seg$(rdata$,space1+2,semicol-space1-2) else goto decget16395       Getmem buffer rdata$ using "5H":rdata16400       Goto 1642016405 Decget:       rdata$=seg$(rdata$,space1+1,semicol-space1+1)16410       If asc(seg$(rdata$,1,1))>=48 and asc(seg$(rdata$,1,1))<=57 or asc(seg$(rdata$,1,1))=45 then rdata=val(rdata$) else rdata=016415 Arg_end:       rdtemp=rdtemp+rdata16420       Next m16425     Rdata=rdtemp/avg16430     Call storem16435     If repeat then goto 1630516440     Avg=116445 Fnmi_out:     off error(101)16450     Return16455 Valerr:     rdata=016460     Advance16465     End16500 Sub r_text local txagain16505     Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))16510     If ty<>0 then call clr_bufr16515     Init var lab$,repeat16520     If pos(ask$("path"),"FAILURE",1) then goto txagain16525     Call run_step16530 Txagain:     print pagem$16535     Print using "30A//  FA//":"OPERATOR INSTRUCTIONS: ",lset$16540     If actcod$="NR" then call commrbyt else goto 1655516545     Print pagem$16550     Return16555     If actcod$="PF" then call pfkey else goto 1657016560     Print pagem$16565     Return16570     Input prompt "
Enter measurement result from keyboard (must be a number). ":rdata16575     Call storem16580     If repeat then goto 1651516585     Print pagem$16590     Return16595     End16700 Sub storem local limit1,bloc_dat,stuffit,fndat16705     Hilmt$="---   "16710     Lolmt$="---   "16715     Rdata$="   ---"16720     Putmem buffer step$ using "1an4t15a":"#",stp,label$16725     If actcod$="DW" or actcod$="BA" then goto bloc_dat16730     If actcod$="PF" then goto stuffit16735     Putmem buffer rdata$ using "I9t5a":rdata,unit$16740     If pos(ask$("path"),"fornext",1) then gosub fndat16745     If pos(actcod$,"L",1) then goto limit1 else p_f$="---"16750     Goto stuffit16755 Limit1:     putmem buffer hilmt$ using "I":up16760     Putmem buffer lolmt$ using "I":low16765     If low>up then goto revlmt16770     If rdata>=low and rdata<=up then p_f$="PASS" else p_f$="FAIL"16775     Goto 1678516780 Revlmt:     if rdata<=low and rdata>=up then p_f$="PASS" else p_f$="FAIL"16785     If p_f$="FAIL" then call failure16790     If repeat then return16795     Goto stuffit16800 Bloc_dat:     if pos(lset$,"(",1)<>1 then goto 1681516805     Lset$="Acquire ONLY"16810     Goto 1686016815     Print "Checking data file . . ."16820     Rep$(lset$,len(lset$),0)=",EOU=<13>"16825     Open #80:lset$16830     If oldfil then rep$(lset$,pos(lset$,"=",1)+1,3)="REP" else goto 1684016835     Open #80:lset$16840     Print "Storing data . . ."16845     Print #80:instr$(outadd),label$16850     If actcod$="DW" then print #80:wfpre$,wfdata else print #80:acqblok$16855     Close 8016860     If eof_err then p_f$="FAIL" else p_f$="PASS"16865     If pos(lset$,"(",1) then rdata$="File"&seg$(lset$,1,pos(lset$,"(",1)-1) else rdata$="File"&lset$16870     Image 20a20t16a36t<9a45t<9a54t4a16875 Stuffit:     if log_all or p_f$="FAIL" then mecount=mecount+1 else return16880     Putmem buffer me_data$(mecount) using 16870:step$,rdata$,lolmt$,hilmt$,p_f$16885     Return16890 Fndat:     if logd=0 then putmem buffer rdata$ using "4a4t<10a":"Loop",stimset$ else putmem buffer step$ using "i9t4a":fntest,"ITEM"16895     Return16900     End17000 Sub record local loopmea,fld1$,fld2$,fld3$,fld4$,fld5$,metemp$17005     If mecount=0 then return17010     If pos(ask$("lu",data_lu),"COMM0",1) then print pagem$17015     Image 25TFA25A17020     Print #data_lu using 17015:"TEST NAME: ",tnam$17025     Print #data_lu using 17015:"OPERATOR: ",opname$17030     Print #data_lu using 17015:"ID: ",t_dev$17035     Print #data_lu using 17015:"DATE: ",seg$(date$,1,9)17040     Print #data_lu using "2L78('-')":17045     If verflag then compress17050     For i=1 to mecount17055       Metemp$=me_data$(i)17060       Call parse(metemp$,fld1$,fld2$,fld3$,fld4$,fld5$)17065       Print #data_lu using "<22a30t'|'32t26a":fld1$,fld2$17070       If pos(fld5$,"PAS",1) or pos(fld5$,"FAI",1) then print #data_lu using "4t'Low '<22a30t'| Hi '<22a56t'|'s":fld3$,fld4$ else goto 1708017075       If pos(fld5$,"FAIL",1) and data_lu=700 then print #data_lu:"LI262    "&fld5$&"    LI122" else print #data_lu:"    "&fld5$17080       Next i17085     Print #data_lu using "78('-')2/":17090     Print #data_lu using "T'START TIME: '8A4X'COMPLETION TIME: '8A4X'TOTAL TIME: '7.2G2L":start$,finish$,finish-start17095     Return17100     End17200 Sub parse(temp$ var fld1$,fld2$,fld3$,fld4$,fld5$)17205     Image 20a16a9a9a4a17210     Getmem buffer temp$ using 17205:fld1$,fld2$,fld3$,fld4$,fld5$17215     If seg$(fld1$,1,4)="Proc" then return17220     If seg$(temp$,10,4)="ITEM" then getmem buffer fld1$ using "I":fntest else goto 1723017225     Putmem buffer fld1$ using "4tk":fntest17230     If pos(fld2$,"---",1) or pos(fld2$,"File",1) then goto 1725517235     If pos(fld2$,"Loop",1) then goto 17250 else getmem buffer fld2$ using "I5a":rdata,unit$17240     Putmem buffer fld2$ using "kx5a":rdata,unit$17245     Goto 1726017250     Rep$(fld2$,5,0)="on: "17255     Rep$(fld2$,5,0)=" "17260     If pos(fld3$,"---",1) then goto 17270 else getmem buffer fld3$ using "I":low17265     Putmem buffer fld3$ using "k":low17270     If pos(fld4$,"---",1) then goto 17280 else getmem buffer fld4$ using "I":up17275     Putmem buffer fld4$ using "k":up17280     Return17285     End17300 Sub precord local ploopmea17305     If mecount=0 then return17310     Image /'STIMULUS'/=20A17315     Image 'LO LIMIT:'/=20A/'HI LIMIT:'/=20A/'PASS/FAIL: '>8A17320     Print #100 using "'TEST NAME:'FA2/'OPERATOR:'FA2/'ID:'FA2/'DATE:'FA/20('-')/20('-')":tnam$,opname$,t_dev$,seg$(ask$("time"),1,9)17325     If verflag then compress17330     For i=1 to mecount17335       Metemp$=me_data$(i)17340       Call parse(metemp$,plab$,rdata$,lolmt$,hilmt$,p_f$)17345       If pos("P#",seg$(plab$,1,1),1) then print #100 using "/<20A":plab$ else print #100 using 17310:trim$(plab$)17350       If pos(rdata$,"Loop",1) or pos(rdata$,"File",1) then goto 1736517355       If pos(rdata$,"       ",1) then goto 17375 else getmem buffer rdata$ dels " ":rdata$,unit$17360       Print #100:"READING in: ";unit$17365       Print #100 using "=20A":rdata$17370       If pos(p_f$,"PAS",1) or pos(p_f$,"FAI",1) then print #100 using 17315:lolmt$,hilmt$,p_f$17375       Next i17380     Print #100 using "/20('-')/20('-')/2l/'START TIME: '>fa/'STOP TIME:  '>fa/'TOTAL TIME:  '7.2g":start$,finish$,finish-start17385     Print #100 using "12L":17390     Return17395     End17500 Sub save_it local redif,nofi17505     Newf=017510     Filesize=80*(mecount+14)17515     Tape$="(OPEN=NEW,SIZE="&str$(filesize)&")"17520     Call respond17525     If filen$="" then goto nofi17530     Ftype$="REPLACE"17535     Open #100:filen$17540     If ftype$="NEW" then goto redif17545     Print "
Warning file already exist!"17550     Print "
Do you wish to replace old file?"17555     Call y_nanswr17560     If answer$="N" then return17565 Redif:     rep$(tape$,7,3)="REPLACE"17570     Filed$=filen$&tape$17575     Newf=017580     Return17585 Nofi:     outdata$=""17590     Newf=017595     Return17600     End17700 Sub failure local deadkey,rev_lmts,fail_lab,redo,onward,go_on,average,abrt_tes17705     Q=117710     Avg=117715     Repeat=017720     If f_flag$<>"YES" then return17725     Print pagem$17730     Print using "faj2/'  Lo Limit: 'e3x'Hi Limit: 'e":"Failed measurement is : ",rdata,low,up17735 Fail_lab:     khead$="FAILURE PROMPTING"17740     Data "","","","","CON-","RPEAT","AVG","ABORT"17745     Data "","","","","TINUE","MEAS","MEAS","TEST"17750     Init var keylab1$,keylab2$,keylab3$,keylab4$17755     Restore 1774017760     Read keylab3$,keylab4$17765     Call gkeydisp17770     Call run_step17775     Print "Press a function key"17780     Keyflag=017785     Wait17790     Gosub keyflag of deadkey,deadkey,deadkey,deadkey,onward,redo,average,abrt_tes,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey17795     If keyflag=0 then goto 1778517800     If repeat or avg>1 or q=0 then return17805     Goto fail_lab17810 Redo:   rem MAKE MEASUREMENT AGAIN17815     Repeat=117820     Return17825 Onward:     q=017830     Return17835 Average:     repeat=117840     If iocode$="TX" then print "

** Averaging not permitted with keyboard input. **" else goto 1785517845     Q=117850     Return17855     Input prompt "
Enter number of measurements to be averaged for this test: ":avg17860     Return17865 Deadkey:     keyflag=017870     Return17875 Abrt_tes:     print #102:"TEST ABORTED"17880     Mbranch=117885     Trap17890     End17900 Sub abort2mn17905     Print #102:bell$&"Handling an abort"17910     Print pagem$17915     Cnt$=str$(count)17920     Branch main_lab17925     End18000 Sub meas_lab(qread$) local lab$18005     Dim lab$ to 1518010     L$=qread$&" meas"18015     Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))18020     If ty<>0 then call clr_bufr18025     Print "%!1"18030     Input prompt "


What do you want to call this step (15 character max)? ":lab$18035     If lab$="" then label$=l$ else label$=lab$18040     If not(qread$="CG" and pos(ask$("path"),"fornxt",1)) then goto 18050 else unit$="% err"18045     Goto 1806018050     If qread$="CG" or qread$="GL" then unit$="     " else goto 1806518055     Print "%!0"18060     Return18065     Input prompt "

Enter units of measurement (5 character max) : ":unit$18070     Print "%!0"18075     Return18080     End18100 Sub x_printr18105     If not(pos(ask$("driver"),"COMM1",1)) then print "

Optional comm driver (COMM1) not present in this system!" else goto 1812518110     Com$="COMM0:"18115     Call commrbyt18120     Return18125     Phypar$=seg$(ask$("lu",800),pos(ask$("lu",800),"(",1)+1,pos(ask$("lu",800),"ech",1)-8)18130     Logpar$=seg$(ask$("lu",800),pos(ask$("lu",800),"ech",1),pos(ask$("lu",800),"):",1)-len(phypar$)-8)18135     Print using "2Lfa//fa":"COMM1 PHYSICAL PARAMETERS ARE:",phypar$18140     Print "
Enter physical parameters for COMM1 or <RETURN> for no change: "18145     Input prompt "
  e.g. baud=1200,fla=bid,typ=2000 (see 4041 Ref. Guide)        %!1[2A%!0":phy$18150     If phy$="" then phy$=phypar$18155     Set driver "comm1:"18160     Set driver "COMM1("&phy$&"):"18165     Print using "4Lfa//fa ":"COMM1 LOGICAL PARAMETERS ARE:",logpar$18170     Print "

Enter logical parameters for COMM1 or <RETURN> for no change:"18175     Input prompt "
  e.g. cr=cr,con=yes  (see 4041 Ref. Guide)                   %!1[2A%!0":com$18180     If com$="" then com$=logpar$18185     Com$="COMM1"&"("&com$&"):"18190     Open #800:com$18195     If keyflag<>7 then print pagem$18200     Return18205     End18300 Sub pfkey18305     Khead$="PASS/FAIL KEYS"18310     Init var keylab1$,keylab2$,keylab3$,keylab4$18315     Data "MT3PASS ","MT3KEY  ","MT2FAIL ","MT2KEY  "18320     Restore 1831518325     Read keylab3$(7),keylab4$(7),keylab3$(8),keylab4$(8)18330     Call gkeydisp18335     Call run_step18340     Print "Press PASS or FAIL key"18345     Keyflag=018350     Wait18355     If keyflag=7 then p_f$="PASS"18360     If keyflag=8 then p_f$="FAIL"18365     If keyflag<>7 and keyflag<>8 then goto 1834518370     Call storem18375     Return18380     End18400 Sub path_lab18405     Print "MG0";18410     If cnt$="" then stplab$="" else stplab$="STEP: "&cnt$18415     If key$="" then keyl$="" else keyl$=" KEY: "&key$18420     Print "KA0LF7f-N                                           LFf-N"&stplab$&keyl$&path$&"KA1";18425     Return18430     End18500 Sub all_errs18505     Print "The system reported: ";ask$("error")18510     Advance18515     End18600 Sub pollerrs18605     Print "SERIAL POLL ERROR REPORTED: "&ask$("error")18610     Print #200 using "FA/FA//":"SERIAL POLL ERROR:",ask$("error")18615     Advance18620     End18700 Sub y_nanswr18705     Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))18710     If ty<>0 then call clr_bufr18715     Answer$="z"18720     Input #700 prompt "     Enter <y> for 'yes'  or  <RETURN> for 'no' : ":answer$18725     If answer$="" then answer$="n"18730     If answer$<>"Y" and answer$<>"N" then goto 1870518735     Return18740     End18800 Sub prinhelp local again,linec,line$,a$18805     Integer linec18810     Dim line$ to 8018815     Newf=018820     Linec=018825     Open #405:helpfil$18830     If newf then print "Help file not available" else goto again18835     Wait 218840     Goto 1891518845 Again:     if eof(405) then goto 1888518850     Linec=linec+118855     Input #405:line$18860     Print line$18865     If linec=18 then input prompt "
     Press <RETURN> for more or enter <q> to stop ":a$ else goto again18870     If a$="q" then goto 18885 else linec=018880     Goto again18885     Close 40518890     Print "
Do you want to print the HELP information to an external printer?"18895     Call y_nanswr18900     If answer$<>"Y" then goto 1891518905     Call x_printr18910     Copy helpfil$ to com$18915     Print pagem$18920     Return18925     End19000 Sub run_step19005     If label$="" and out$<>"TX" and out$<>"FN" and actcod$="NR" then label$="INSTR. SET-UP"19010     If label$="" and out$="TX" then label$="OPERATOR PROMPT"19015     Print "KA0LF7f-N                                     LFf-NMT7STEP: "&str$(stp)&" "&label$&"KA1"19020     Print #"frtp(rate=.05,view=.05):":stp;"  ";label$19025     Return19030     End19100 Sub exitest19105     Branch run_lab19110     End19200 Sub abort2ex19205     If gport0 then select "gpib0:" else goto 1921519210     Wbyte atn(unt,unl),ren(0),ren(1)19215     If gport1 then select "gpib1:" else goto 1922519220     Wbyte atn(unt,unl),ren(0),ren(1)19225     Print #102 using "/fa":"ABORT"19230     Print page$19235     Finish=ask("time")19240     Date$=ask$("time")19245     Finish$=seg$(date$,11,8)19250     Cr1=019255     Branch run_lab19260     End19300 Sub progwat local strt19305     If unlok$="LOCAL" then select ask$("lu",outadd) else goto 1931519310     If seg$(instr$(outadd),10,2)="32" then wbyte gtl(val(seg$(instr$(outadd),8,2))) else wbyte gtl(val(seg$(instr$(outadd),8,2)),val(seg$(instr$(outadd),10,2)))19315     If delay=0 then return else strt=ask("time")19320     If ask("time")-strt>=delay then return else goto 1932019325     End19400 Sub clr_bufr19405     Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))19410     If ty=0 then return19415     Select "COMM0:"19420     For xx=1 to ty19425       Rbyte answer$19430       Next xx19435     Return19440     End19500 Sub getwfm20(log_unit,mode$ var wfpre$,wfdata) local temp$,wfpts,get_asc,get_rtn19560     Delete var wfdata19565     Init var blokbuf$,wfpre$,wfdata,wfpts19570     Print #log_unit:"lo off;da encdg:"&mode$19575     Input #log_unit prompt "wfmpre?":wfpre$19580     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))19585     Print #log_unit:"curve?"19590     If mode$="asc" then goto get_asc19595     Integer wfdata(wfpts)19600     Input #log_unit buffer blokbuf$:bufr$19605     Getmem buffer blokbuf$ using "5A,+8%":temp$,wfdata19610     Goto get_rtn19615 Get_asc:     dim wfdata(wfpts)19620     Input #log_unit buffer blokbuf$:wfdata19625 Get_rtn:     delete var temp$,wfpts19630     Return19635     End19700 Sub norwfm20(wfdata,wfpre$ var normdata) local mode$,norm_asc19740     Print "Normalizing waveform.....wait"19745     Delete var normdata19750     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))19755     Yzero=valc(wfpre$,pos(wfpre$,"yz",1))19760     Mode$=seg$(wfpre$,pos(wfpre$,":",pos(wfpre$,"enc",1))+1,3)19765     Ymult=valc(wfpre$,pos(wfpre$,"ym",1))19770     Dim normdata(wfpts)19775     If mode$="asc" then goto norm_asc19780     Normdata=(((wfdata-128)/25)*ymult)+yzero19785     Return19790 Norm_asc:     normdata=(wfdata*ymult)+yzero19795     Return19800     End19900 Sub graphfn local x1,x2,size,dec,inc,count,ylo,yhi,xtype,ele1,xx1,xx2,y1,y2,yy1,yy2,autoflag,lxw,hxw,lyw,hyw,lxv,hxv,lyv,hyv,a,b19905     On error(80) then gosub err8019910     Integer x1,x2,size19915     Print pagew$19920     GINIT 700,4113,119925     Call fnmenu(x1,x2)19930     If x2=0 then goto 2014519935     If x2=1 then size=1 else size=x2-x119940     Long xplt(size),yplt(size)19945     Dim a(size),b(size)19950     For point=1 to size19955       Metemp$=me_data$(x1+point)19960       Getmem buffer metemp$ using "I11aI":xplt(point),fld1$,yplt(point)19965       A(point)=xplt(point)19970       B(point)=yplt(point)19975       Next point19980     Print "LI700"19985     Print pagem$19990     Print using "2L=75A":"PLOTTING "&grlab$19995     Rcall "xlog",020000     If size<3 then goto 2003020005     If (xplt(1)-xplt(2))<>(xplt(2)-xplt(3)) and (xplt(1) min xplt(size))>0 then rcall "xlog",120010     Rcall "ask xlog",xtype20015     Ele1=xplt(1)20020     If xtype then rcall "XRANGE",10^int(lgt(ele1)),xplt(size) else XRANGE20025     If xtype then rcall "xtic",int(lgt(xplt(1))),1 else XTIC20030     LINESTYL 020035     SYMBOL 2,120040     XGRID 120045     YGRID 120050     Print pagew$20055     COLOR 120060     XYPLOT xplt,yplt20065     COLOR 320070     SYMBOL 0,120075     LINESTYL 120080     XYADD xplt,yplt20085     COLOR 520090     Rcall "ask viewport",xx1,xx2,yy1,yy220095     Rcall "ask window",x1,x2,y1,y220100     If xtype then gosub ticmark20105     VIEWPORT xx1,xx2,yy1,yy220110     WINDOW x1,x2,y1,y220115     TITLE grlab$20120     SUBTITLE date$20125     MOVE 65,1520130     GTEXT "STIMULUS: "&stimset$20135     YTITLE "MEASUREMENT : "&grunit$20140     Goto 1992520145     COLOR 120150     Print "LI122"20155     Delete var xplt,yplt20160     Pkhead$=""20165     Return20170 Ticmark:     rcall "ask yrange",ylo,yhi,autoflag20175     Rcall "ask plot",lxw,hxw,lyw,hyw,lxv,hxv,lyv,hyv20180     WINDOW lxw,hxw,lyw,hyw20185     VIEWPORT lxv,hxv,lyv,hyv20190     LINESTYL 220195     For dec=int(lgt(xplt(1))) to int(lgt(xplt(size)))+120200       Inc=10^int(dec)20205       For count=10^dec+inc to 10^(dec+1)-inc step inc20210         MOVE lgt(count),ylo20215         DRAW lgt(count),yhi20220         Next count20225       Next dec20230     LINESTYL 120235     Return20240 Err80:     input prompt "Unable to plot loop"&chr$(13)&"Selected loop has a value that is outside the range of the graph routine."&chr$(13)&"Press <RETURN> to continue.":ans$20245     Branch 1991520250     End20300 Sub plotwf20(ydata,wfpre$,axis_col,wfm_col,labl_col,ty_pe,label$) local start,sto_p,titl$,i,seg_labl,seg_done,plot_et,plot_at,plot_pt,plot_gr20380     Dim titl$(5)20385     For i=0 to 420390       If i=0 then start=1 else start=posn(label$,",",1,i)+120395       Sto_p=posn(label$,",",1,i+1)20400       If sto_p<>-1 then goto seg_labl20405       Sto_p=len(label$)+120410       Exit to segdone20415 Seg_labl:       titl$(i+1)=seg$(label$,start,(sto_p-start))20420       Next i20425 Segdone:     VIEWPORT20430     OFFSET20435     Xincr=valc(wfpre$,pos(wfpre$,"xi",1))20440     Ymult=valc(wfpre$,pos(wfpre$,"ym",1))20445     Yzero=valc(wfpre$,pos(wfpre$,"yz",1))20450     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))20455     YRANGE -((10*ymult)/2)+yzero,((10*ymult)/2)+yzero20460     Gosub ty_pe+1 of plot_et,plot_at,plot_pt20465     Goto plot_gr20470 Plot_et:     tpos=valc(wfpre$,pos(wfpre$,"pt.o",1))*xincr20475     XRANGE -(tpos),(xincr*(wfpts-1))-tpos20480     OFFSET -tpos,xincr20485     Return20490 Plot_at:     XRANGE 0,(wfpts-1)*xincr20495     OFFSET 0,xincr20500     Return20505 Plot_pt:     XRANGE 0,(wfpts-1)20510     Return20515 Plot_gr:     XGRID 120520     YGRID 120525     PAGE20530     COLOR axis_col20535     YPLOT20540     COLOR wfm_col20545     YADD ydata20550     COLOR labl_col20555     TITLE titl$(1)20560     SUBTITLE titl$(2)20565     XTITLE titl$(3)20570     YTITLE titl$(4)20575     Return20580     End20600 Sub pulse(wfm,pre$,bgn,e_nd,base,top,perlvl,dsp_flg var ans) local proc1,proc3,proc4,proc5,proc6,proc7,ck_rgt,not_frst,cross_ck,inc_i_cr,cross1,ck_slope,cr_done,ck_done,nxt_edge,inc_i_1,inc_i_2,slp_done,init_i_1,inc_i_3,ck_1,period2,wfpts,label$20645     If dsp_flg=0 then goto proc120670     VIEWPORT20675     Rcall "ask viewport",vx1,vx2,vy1,vy220720     Char_h=vy2/3020725     Char_w=vx2/8020730     PAGE20735     MOVE 10*char_w,25*char_h20740     COLOR 720745     Print "MC1F41"20750     GTEXT "Computing Pulse Parameters "20755     MOVE 20*char_w,20*char_h20760     GTEXT "BUSY"20765     Print "MC111"20790 Proc1:     dim ans(16),label$(7),fifloc(1)20795     Integer wmin,wmax,maxloc,minloc20800     Init var rise,fall,wfm_per,wfm_wid,ans,fifloc,strtpt,r10,r90,f10,f90,edge20805     Init var rgt,lft,test,edge20810     Wfpts=valc(pre$,pos(pre$,"nr",1))20815     Ymult=valc(pre$,pos(pre$,"ym",1))20820     Xinc=valc(pre$,pos(pre$,"xi",1))20825     Yzero=valc(pre$,pos(pre$,"yz",1))20830     Tpos=valc(pre$,pos(pre$,"pt.o",1))*xinc20835     Encdg$=seg$(pre$,pos(pre$,":",pos(pre$,"enc",1))+1,3)20840     Yunit$=seg$(pre$,pos(pre$,":",pos(pre$,"yu",1))+1,1)20845     Xunit$=seg$(pre$,pos(pre$,":",pos(pre$,"xu",1))+1,1)20850     If bgn<1 or bgn>wfpts or bgn>=e_nd then bgn=120855     If e_nd>wfpts or e_nd<1 or e_nd<=bgn then e_nd=wfpts20860     If base<0 or base>100 then base=020865     If top<0 or top>100 then top=10020870     If perlvl<=0 or perlvl>=100 then perlvl=5020905     Vres=25620910     Vrtscale=ymult/2520930     If encdg$="asc" then wfm=(wfm+5.12)*2520960     If not((e_nd-bgn-1)<>wfpts and dsp_flg=2) then goto proc320965     Integer tmpwfm(wfpts)20970     Tmpwfm=wfm20995 Proc3:     if (e_nd-bgn)=wfpts then goto proc521000 Proc4:     for i=bgn to e_nd21005       Wfm(i-bgn+1)=wfm(i)21010       Next i21015     Integer wfm(e_nd-bgn)21020 Proc5:     AMAX wfm,wmax,maxloc21025     Ans(1)=(wmax-vres/2)*vrtscale+yzero21030     AMIN wfm,wmin,minloc21035     Ans(2)=(wmin-vres/2)*vrtscale+yzero21040     Range=wmax-wmin21045     If range<25 then goto proc821050     If (base=0 and top=0) then goto histo21055     Top=top/100*range+wmin21060     Base=base/100*range+wmin21065     Goto proc621105 Histo:     dim hstwfm(vres),temp(vres)21110     Init var hstwfm,temp,wmin_flg21115     AMIN wfm,wmin,minloc21120     If wmin>=1 then goto histo121145     Wmin_flg=121150     Wfm=wfm+121155 Histo1:     for i=1 to e_nd-bgn21160       Hstwfm(wfm(i))=hstwfm(wfm(i))+121165       Next i21170     AMAX wfm,wmax,maxloc21175     AMIN wfm,wmin,minloc21210     Temp(2)=-121215     Temp(((wmax-wmin)/2)+wmin)=221220     INTEGRAT temp,temp21225     Temp(1)=-121230     Hstwfm=hstwfm*temp21235     AMAX hstwfm,hmax,maxloc21260     If wmin_flg=1 then top=maxloc-1 else top=maxloc21265     AMIN hstwfm,hmax,minloc21270     If wmin_flg=1 then base=minloc-1 else base=minloc21275     If wmin_flg=1 then wfm=wfm-121310 Proc6:     ans(5)=(top-vres/2)*vrtscale+yzero21315     Ans(9)=(base-vres/2)*vrtscale+yzero21320     Center=(top-base)/2+base21325     Ans(7)=(center-vres/2)*vrtscale+yzero21330     L10=(top-base)*0.1+base21335     Ans(8)=(l10-vres/2)*vrtscale+yzero21340     L90=(top-base)*0.9+base21345     Ans(6)=(l90-vres/2)*vrtscale+yzero21365     Slope=121370     CROSS wfm,center,l,121375     Fifloc(1)=l21380     If l<1 then goto slp_done21385     Edge=121420 Ck_rgt:     if rgt+int(fifloc(1))<(e_nd-bgn+1) then rgt=rgt+121425     If int(fifloc(1))-lft>1 then lft=lft+121430     Test=wfm(int(fifloc(1))+rgt)-wfm(int(fifloc(1))-lft)21435     If abs(test)<5 then goto ck_rgt21440     Slope=sgn(test)21445 Not_frst:     if ((slope=1 and rise>=1) or (slope=-1 and fall>=1)) then goto nxt_edge21465     Lev=l1021470     Gosub cross_ck21475     If slope=1 then r10=loc else f10=loc21495     Lev=l9021500     Gosub cross_ck21505     If slope=1 then r90=loc else f90=loc21525     Goto ck_done21560 Cross_ck:     init var old_loc,loc,i21565 Inc_i_cr:     i=i+121570     CROSS wfm,lev,loc,i21575 Cross1:     if loc=-1 and old_loc=0 then goto cr_done21580     If loc>fifloc(edge) or loc=-1 then goto ck_slope21585     Old_loc=loc21590     Goto inc_i_cr21595 Ck_slope:     if ((lev=l10 and slope=-1) or (lev=l90 and slope=1)) then goto cr_done21600     Loc=old_loc21605 Cr_done:     return21625 Ck_done:     if r10>=1 and r90>=1 then rise=edge21630     If f10>=1 and f90>=1 then fall=edge21635     If rise and fall then goto slp_done21660 Nxt_edge:     i=021665 Inc_i_1:     i=i+121670     CROSS wfm,(top-1)*(slope=1)+(base+1)*(slope=-1),l,i21675     If l<1 then goto slp_done21680     Temploc=l21685     If l<=fifloc(edge) then goto inc_i_121690     I=021695 Inc_i_2:     i=i+121700     CROSS wfm,center,l,i21705     If l<1 then goto slp_done21710     If l<=temploc then goto inc_i_221730     Dim fifloc(edge+1)21735     Fifloc(edge+1)=l21740     Edge=edge+121745     Slope=-slope21750     Goto not_frst21755 Slp_done:     if rise then ans(12)=(r90-r10)*xinc21760     If fall then ans(13)=(f10-f90)*xinc21765     If edge<2 then goto proc721770     Wfm_wid=fifloc(2)-fifloc(1)21775     Ans(14)=wfm_wid*xinc21780   Rem find the period if available21785 Proc7:     dim perloc(3)21790     Perlvl=perlvl/100*range+wmin21795     Level=perlvl21800     J=121805 Init_i_1:     i=021810 Inc_i_3:     i=i+121815     CROSS wfm,level,l,i21820     Perloc(j)=l21825     If perloc(j)<1 then goto proc821830     If j>1 then goto period221835     J=221840     Init var rgt,lft,test21845 Ck_1:     if rgt+int(perloc(1))<(e_nd-bgn+1) then rgt=rgt+121850     If int(perloc(1))-lft>1 then lft=lft+121855     Test=wfm(int(perloc(1))+rgt)-wfm(int(perloc(1))-lft)21860     If abs(test)<5 then goto ck_121865     Slope=sgn(test)21900     I1=i21905     Discrim=521910     Level=perlvl-slope*discrim21915     If level>wmax then level=wmax21920     If level<wmin then level=wmin21925     Goto init_i_121930 Period2:     if perloc(j)<=perloc(j-1) then goto inc_i_321935     If j=3 then goto per_done21940     J=321945     I=i121970     Level=perlvl21975     Goto inc_i_321980 Per_done:     wfm_per=perloc(3)-perloc(1)21985     Ans(15)=wfm_per*xinc22005     Wsum=022010     For i=perloc(1) to perloc(3)22015       Prod=(wfm(i)-vres/2)*vrtscale+yzero22020       Wsum=prod*prod+wsum22025       Next i22030     Ans(16)=sqr(wsum/wfm_per)22040 Proc8:     ans(3)=(ans(1)-ans(2))/2+ans(2)22045     Ans(4)=abs(ans(1)-ans(2))22050     If rise>=1 then ans(10)=abs((wmax-top)*100/(top-base))22055     If fall>=1 then ans(11)=abs((wmin-base)*100/(top-base))22060     If dsp_flg=0 then goto re_turn22065     Dim results$ to 20022070     Results$=";MAX:   ,"&yunit$&";MIN:   ,"&yunit$&";MID:   ,"&yunit$&";P-P:   ,"&yunit$&";100 %: ,"&yunit$22075     Results$=results$&";90 %:  ,"&yunit$&";50 %:  ,"&yunit$&";10 %:  ,"&yunit$&";0 %:   ,"&yunit$&";+O.S.: ,%"22080     Results$=results$&";-O.S.: ,%;RISE:  ,"&xunit$&";FALL:  ,"&xunit$&";WIDTH: ,"&xunit$&";PERIOD:,"&xunit$22085     Results$=results$&";RMS:   ,"&yunit$22090 Dsp_wfm:     if dsp_flg=1 then wfpts=e_nd-bgn22095     If dsp_flg=1 then strtpt=bgn22100     XRANGE -tpos+(strtpt*xinc),xinc*(wfpts-1)-tpos+(strtpt*xinc)22105     OFFSET -tpos+(strtpt*xinc),xinc22110     YRANGE -(5.12*ymult)+yzero,5.08*ymult+yzero22115     PAGE22120     VIEWPORT22125     WINDOW22130     MOVE 17*char_w,28*char_h22135     VIEWPORT 40,140,1,9522140     COLOR 122145     Rcall "linestyle",122150     YGRID 022155     XGRID 022160     YPLOT22165     YTITLE "AMPLITUDE volts"22170     XTITLE "Time Relative To Trigger"22175     Rcall "ask plot",pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy222180     Dim ploc(11)22185     Ploc(1)=wmax22190     Ploc(2)=top22195     Ploc(3)=l9022200     Ploc(4)=center22205     Ploc(5)=l1022210     Ploc(6)=base22215     Ploc(7)=wmin22220     Label$(1)=" Max"22225     Label$(2)="100%"22230     Label$(3)=" 90%"22235     Label$(4)=" 50%"22240     Label$(5)="10%"22245     Label$(6)="0%"22250     Label$(7)="Min "22255     COLOR 322275     Rcall "linestyle",222280     Delete var temp22285     VIEWPORT pvx1,pvx2,pvy1,pvy222290     WINDOW pwx1,pwx2,pwy1,pwy222295     For i=1 to 722300       If ploc(i)<1 then goto 2241022305       Temp=vrtscale*(ploc(i)-vres/2)+yzero22310       MOVE pwx1,temp22315       DRAW pwx2,temp22320       VIEWPORT vx1,vx2,pvy1,pvy222325       WINDOW22330       Rcall "linestyle",122335       RMOVE char_w,022340       If i<5 then RDRAW int((((i+2)*char_w)+pvx2)/char_w)*char_w-pvx2,022345       If i>4 then RDRAW int((((9-(i-2))*char_w)+pvx2)/char_w)*char_w-pvx2,022350       WINDOW pwx1,pwx2,pwy1,pwy222355       If i<5 then RDRAW 0,pwy2-((ploc(i)-vres/2)*vrtscale+yzero)22360       If i>4 then RDRAW 0,pwy1-((ploc(i)-vres/2)*vrtscale+yzero)22365       VIEWPORT22370       WINDOW22375       If i<5 then RDRAW 0,int((((5-i)*char_h)+pwy2)/char_h)*char_h-pwy2+(char_h/2) else RDRAW 0,-(int((pwy1-((3-i)*char_h))/char_h)*char_h-pwy1)+(char_h/2)22380       RDRAW char_w,022385       RMOVE 0,-(char_h/2)22390       GTEXT label$(i)22395       VIEWPORT pvx1,pvx2,pvy1,pvy222400       WINDOW pwx1,pwx2,pwy1,pwy222405       Rcall "linestyle",222410       Next i22435     COLOR 422440     Rcall "linestyle",122445     Integer wpt_pt,loc(2)22450     Init var wpt_pt,loc,done22455     Wpt_pt=wfpts/(pvx2-pvx1)22480     If rise<1 then goto dr_fall22485     If dsp_flg=1 then loc(1)=int(r10) else loc(1)=int(r10)+bgn22490     If dsp_flg=1 then loc(2)=int(r90) else loc(2)=int(r90)+bgn22495     Loc$="RISE"22500     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5)22540     If max_char>len(loc$) then pass=0 else pass=122545     If (loc(1)>f90+strtpt and fall>=1 and loc(2)<wfpts-100) then pass=222550     For i=1 to 222555       VIEWPORT pvx1,pvx2,pvy1,pvy222560       WINDOW 1,wfpts,0,vres22565       If (i=2 and loc(2)-loc(1)<wpt_pt) then goto 2268022570       If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i))+1 else MOVE loc(i),wfm(loc(i)+1)22575       DRAW loc(i),vres22580       VIEWPORT22585       WINDOW22605       RMOVE 0,char_h/222610       RDRAW 0,char_h22615       If (pass=2 or i=2) then goto 2268022620       If pass=1 then RMOVE -char_w*(len(loc$)+1),0 else RMOVE char_w,022625       If pass>0 then goto 2267022630       If (max_char-len(loc$))/2<1 then goto 2267022655       For i1=1 to int((max_char-len(loc$))/2-0.5)22660         Rep$(loc$,0,0)=chr$(32)22665         Next i122670       GTEXT loc$22675       Goto 2270522680       If (i=1 or pass<2) then goto 2270522685       VIEWPORT22690       WINDOW22695       RMOVE char_w,022700       GTEXT loc$22705       Next i22710 Dr_fall:     if (done=1 or fall=0) then goto dr_time22715     Done=122720     If dsp_flg=1 then loc(1)=int(f90) else loc(1)=int(f90)+strtpt22725     If dsp_flg=1 then loc(2)=int(f10) else loc(2)=int(f10)+strtpt22730     Loc$="FALL"22735     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5)22740     If max_char>len(loc$) then pass=0 else pass=122745     If (loc(1)>r90+strtpt and rise>=1 and loc(2)<wfpts-100 and pass=1) then pass=222750     Goto 2255022770 Dr_time:     if edge<2 then goto lst_parm22775     If dsp_flg=1 then loc(1)=int(fifloc(1)) else loc(1)=int(fifloc(1))+bgn22780     If dsp_flg=1 then loc(2)=int(fifloc(2)) else loc(2)=int(fifloc(2))+bgn22785     Loc$="WIDTH"22790     Done=022795     N=122800     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5)22805     If max_char+1>len(loc$) then pass=0 else pass=122810     If (pass=1 and ((loc(1)<wfpts/2 and loc(2)<wfpts-100 and int((perloc(3)+strtpt-loc(2))/wpt_pt/char_w)>len(loc$)) or (loc(1)>perloc(1)+strtpt and perloc(1)+strtpt<>0))) then pass=222815     For i=1 to 222820       VIEWPORT pvx1,pvx2,pvy1,pvy222825       WINDOW 1,wfpts,0,vres22830       If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i)-1 max 1) else MOVE loc(i),wfm(loc(i)-1 max 1)22835       DRAW loc(i),022840       VIEWPORT22845       WINDOW22850       RMOVE 0,-3*char_h22855       RDRAW 0,-1.5*char_h*n22860       If (pass=2 or i=2) then goto 2290522865       If pass=1 then RMOVE -char_w*(len(loc$)+1),0 else RMOVE char_w,022870       If pass>=1 then goto 2289522875       If (max_char-len(loc$))/2<1 then goto 2289522880       For i1=1 to int((max_char-len(loc$))/2-0.5)22885         Rep$(loc$,0,0)=chr$(32)22890         Next i122895       GTEXT loc$22900       Goto 2292022905       If (i=1 or pass<2) then goto 2292022910       RMOVE char_w,022915       GTEXT loc$22920       Next i22925     If (done=1 or wfm_per=0) then goto lst_parm22930     N=222935     Done=122940     If dsp_flg=1 then loc(1)=int(perloc(1)) else loc(1)=int(perloc(1))+strtpt22945     If dsp_flg=1 then loc(2)=int(perloc(3)) else loc(2)=int(perloc(3))+strtpt22950     Loc$="PERIOD"22955     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5)22960     If max_char+1>len(loc$) then pass=0 else pass=122965     If (pass=1 and loc(1)<wfpts/2 and loc(2)<(wfpts-100)) then pass=222970     Goto 2281522975 Lst_parm:     COLOR 222980     If dsp_flg=2 then YADD vrtscale*(tmpwfm-vres/2)+yzero else YADD vrtscale*(wfm-vres/2)+yzero22985     VIEWPORT22990     WINDOW22995     COLOR 323000     MOVE 2*char_w,26*char_h23005     GTEXT "Pulse Parameters:"23010     MOVE 2*char_w,24*char_h23015     Sp=023020     For i=1 to 1623025       If ans(i)=0 then goto dsp_pro223030       Sp=sp+123035       If i>=12 then COLOR 423040       If i>=12 then MOVE 2*char_w,(24*char_h)-(char_h*sp) else MOVE 2*char_w,(25*char_h)-(char_h*sp)23045       Putmem buffer msg$ using "fa,x,4j,fa":seg$(results$,posn(results$,";",1,i)+1,7),ans(i),seg$(results$,posn(results$,",",1,i)+1,1)23050       GTEXT msg$23055 Dsp_pro2:       next i23060 Re_turn:     delete var loc,ploc,wfm,tmpwfm,rise,vx1,vx2,vy1,vy2,pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy2,char_w,char_h,wmax,wmin,maxloc,minloc,wfpts,ymult,xinc,yzero,tpos,encdg$,xunit$,yunit$,vres,vrtscale,range,hstwfm,temp,wmin_flg,center,l1023065     Delete var l90,r10,r90,f10,f90,edge,slope,i,rgt,lft,l,old_loc,loc,temploc,wfm_wid,level,i1,discrim,perloc,wfm_per,wsum,prod,results$,loc$,strtpt,ploc,wpt_pt,done,max_char,pass,sp,wfm23070     Return23075     End23100 Sub stordata local n_dev,t_ck,l_ck,p_ck,s_ck23105     If mecount=0 then print "
NO DATA ! " else goto n_dev23110     Return23115 N_dev:     if outdata$="" then print "

Test data acquired. Use ""STORE DATA"" to view." else goto t_ck23120     Return23125 T_ck:     data_lu=datlutmp23130     If outdata$="T" or outdata$="D" then open #100:filed$ else goto p_ck23135     Call record23140     Close 10023145     Newf=023150     Return23155 P_ck:     if outdata$="P" then open #100:"PRIN(IND=0):" else goto l_ck23160     Call precord23165     Close 10023170     Return23175 L_ck:     if outdata$="L" then open #100:com$ else goto s_ck23180     Call record23185     If val(com$) then print #com$:chr$(12)23190     Close 10023195     Return23200 S_ck:     if outdata$="S" then data_lu=70023205     Call record23210     Call commrbyt23215     Return23220     End23300 Sub storset local t_ck,l_ck23305     If pos("TtDd",outdata$,1) then goto t_ck23310     If outdata$="L" then goto l_ck23315     Return23320 T_ck:     call save_it23325     Return23330 L_ck:     call x_printr23335     Return23340     End23400 Sub fnmenu(var x1,x2) local fllab$,flpnt,i,j,j1,levnam$,found,getchce,none23405     Integer f,i,j,j1,x1,x223410     X1=123415     X2=mecount23420     J=023425     For i=1 to mecount23430       If seg$(me_data$(i),1,4)="Proc" then j=j+123435       Next i23440     If j=0 then goto 2353523445     Dim fllab$(j) to 1523450     Integer flpnt(j+1)23455     J=123460     Flpnt(1)=123465     For i=1 to mecount23470       If seg$(me_data$(i),1,4)<>"Proc" then goto 2349023475       Fllab$(j)=seg$(me_data$(i),6,10)23480       Flpnt(j)=i23485       J=j+123490       Next i23495     If j=1 then flpnt(j+1)=mecount else flpnt(j)=mecount23500     F=123505     If j=1 then goto 2352523510     Levnam$="File Name"23515     Gosub getchce23520     If f<=0 then goto nodo23525     X1=flpnt(f)23530     X2=flpnt(f+1)23535     J=023540     For i=x1 to x223545       If pos(me_data$(i),"Loop",20) then j=j+123550       Next i23555     If j=0 then goto none23560     Dim fllab$(j) to 1523565     Fllab$=""23570     Integer flpnt(j+1)23575     Flpnt=023580     J=123585     For i=x1 to x223590       If not(pos(me_data$(i),"Loop",20)) then goto 2363023595       For j1=1 to j23600         If fllab$(j1)=seg$(me_data$(i),5,15) then exit to found23605         Next j123610       If j1>j then fllab$(j)=seg$(me_data$(i),5,15)23615       J1=j23620       J=j+123625 Found:       flpnt(j1)=flpnt(j1)+123630       Next i23635     Levnam$="Loop Step"23640     Gosub getchce23645     If f<=0 then goto nodo23650     I=flpnt(f)23655     If i=1 then goto 2368523660     Print "There are ";i;" occurrences of Loop ";fllab$(f)23665     Input prompt "Which Loop do you want ":i23670     If i<=0 then goto nodo23675     If i>flpnt(f) then print "Invalid Selection" else goto 2368523680     Goto 2365023685     J1=i23690     For j=x1 to x223695       If seg$(me_data$(j),5,15)=fllab$(f) and pos(me_data$(j),"Loop",20) then j1=j1-1 else goto 2370523700       If j1=0 then exit to jstart23705       Next j23710 Jstart:     x1=j+123715     For j=x1 to x223720       If pos("P#",seg$(me_data$(j),1,1),1) then exit to jfinish23725       Next j23730 Jfinish:     x2=j-123735     If flpnt(f)=1 then grlab$=fllab$(f) else grlab$=trim$(fllab$(f))&" #"&str$(i)23740     Stimset$=trim$(seg$(me_data$(x1-1),25,10))23745     Grunit$=seg$(me_data$(x1),30,5)23750     X1=x1-123755     Return23760 Getchce:     j=j-123765     For i=1 to j23770       Print using "2d2x<16as":i,fllab$(i)23775       Next i23780     Print23785     F=9923790     Input prompt "            Select "&levnam$&" by Number or 0 for none :":f23795     If f>j then print "Invalid Selection" else goto 2381023800     Wait 123805     Goto 2376523810     Return23815 Nodo:     x1=023820     X2=023825     Return23830 None:     print "No loop data to plot
"23835     Call commrbyt23840     X1=023845     X2=023850     Return23855     End23900 Function linein$ local line$23905     Dim line$ to 8023910     Input #81:line$23915     Linein$=trim$(seg$(line$,pos(line$,":",1)+2,len(line$)-pos(line$,":",1)+2))23920     Return23925     End24000 Sub fillmed local line$,lpmeas,dproc,dloop,dfile,dmeas,dout,dtime,dlim,again,done,stimset$24005     Dim line$ to 80,stimset$ to 1224010     Image   20A20t4A24t<12A36T>9A45T>9A54T4A24015     Image   I9T4A20TI29T<5A36T>9A45T>9A54T4A24020     Image   20A20tI29t<5A36T>9A45T>9A54T4A24025     Image   36a<9A45T<9A54T4A24030     Init var me_data$,mecount24035     Open #81:filen$24040     Tnam$=linein$24045     Opname$=linein$24050     T_dev$=linein$24055     Date$=linein$24060     Start=024065 Again:     if eof(81) then goto done24070     Input #81:line$24075     If seg$(line$,1,4)="Proc" then goto dproc24080     If pos(line$,"Loop",20) then goto dloop24085     If pos(line$,"File",20) then goto dfile24090     If seg$(line$,1,1)="#" then goto dmeas24095     If seg$(line$,1,2)="  " then goto lpmeas24100     If pos(line$,"START TIME:",1) then goto dtime24105     Goto again24110 Lpmeas:     if seg$(line$,5,3)="Low" and seg$(line$,33,2)="Hi" then goto dlim24115     Fntest=val(line$)24120     Rdata=valc(line$,pos(line$,"|",1)+1)24125     Unit$=seg$(line$,ask("chpos")+1,5)24130     Putmem buffer line$ using 24015:fntest,"ITEM",rdata,unit$,"---   ","---   ","---"24135     Goto dout24140 Dlim:     if pos(line$,"---",1) then goto 24165 else low=valc(line$,pos(line$,"Low",1))24145     Putmem buffer low$ using "I":low24150     Up=valc(line$,pos(line$,"Hi",1))24155     Putmem buffer up$ using "I":up24160     Goto 2417524165     Low$="---   "24170     Up$="---   "24175     P_f$=seg$(line$,posn(line$,"|",1,2)+5,4)24180     Line$=seg$(me_data$(mecount),1,36)24185     Putmem buffer line$ using 24025:line$,low$,up$,p_f$24190     Me_data$(mecount)=line$24195     Goto again24200 Dproc:     putmem buffer line$ using "17a56t":seg$(line$,1,17)24205     Goto dout24210 Dloop:     getmem buffer line$ using "20a21x10a":label$,stimset$24215     Putmem buffer line$ using 24010:label$,"Loop",stimset$,"---   ","---   ","---"24220     Goto dout24225 Dfile:     getmem buffer line$ using "20a17x14a":label$,stimset$24230     Putmem buffer line$ using 24010:label$,"File",stimset$,"---   ","---   ","---"24235     Goto dout24240 Dmeas:     getmem buffer line$ using "20a":label$24245     Rdata=valc(line$,pos(line$,"|",1))24250     Unit$=seg$(line$,ask("chpos")+1,5)24255     Putmem buffer line$ using 24020:label$,rdata,unit$,"---   ","---   ","---"24260 Dout:     mecount=mecount+124265     Me_data$(mecount)=line$24270     Goto again24275 Dtime:     line$=seg$(line$,pos(line$,"START",1),80)24280     Getmem buffer line$ using "12x8a21x8a15x9a":start$,finish$,fin$24285     Finish=val(fin$)24290     Goto again24295 Done:     close 8124300     Return24305     End24400 Sub disk_err local err$,err,temp$,e1201,e1203,e1208,e1209,e1210,e1211,e1212,e1213,e1214,e1216,e121724405     Err$=ask$("error")24410     Print "ERROR : "&err$&" has occured.
"24415     Err=val(err$)-120024420     Goto err of e1201,na,e1203,na,na,na,na,e1208,e1209,e1210,e1211,e1212,e1213,e1214,na,e1216,e1217,no,no,no,conte,conte,conte,conte,conte,conte,conte,conte,conte24425     Goto hdwarerr24430 E1201:     input prompt "
The file name you specified contained illegal character(s).  Press <RETURN>     to continue.":temp$24435     Advance24440 E1203:     input prompt "
The number of files in the directory exceeds the maximum allowed.  Press        <RETURN> to continue.":temp$24445     Advance24450 E1208:     input prompt "
Input data type did not match with input.  Press <RETURN> to continue.":temp$24455     Advance24460 E1209:     input prompt "
Rbyte or Wbyte number out of range.  Press <RETURN> to continue.":temp$24465     Advance24470 E1210:     input prompt "
Rbyte or Wbyte while disk in logical mode.  Press <RETURN> to continue.":temp$24475 Na:     print "Disk error : "&err$&"...This error should have been handled elsewhere."24480     Advance24485 E1211:     input prompt "
An attempt was made to format a disk specifying more directory entries than can be placed on 1/16th of the disk.  Press <RETURN> to continue. ":temp$24490     Advance24495 E1212:     input prompt "
Illegal physical mode operation.  Press <RETURN> to continue. ":temp$24500     Advance24505 E1213:     input prompt "
An attempt was made to write to a file on a disk that has a write protect tab   inplace.  Remove write protect tab or insert another disk and press <RETURN>    to try again. ":temp$24510     Retry24515 E1214:     input prompt "
The data read back, from a sector just written, was incorrect.  Press <RETURN>  to try again or <CTRL C> to abort. ":temp$24520     Retry24525 E1216:     input prompt "
The data transferred to/from the disk caused a parity error.  Press <RETURN> to try again or <CTRL C> to abort. ":temp$24530     Retry24535 E1217:     input prompt "
An attempt was made to rename a file to an existing file name on the same disk. Press <RETURN> to try again. ":temp$24540     Renamerr=124545     Advance24550 Conte:     input prompt "A disk error has occured and was caused by the SCSI hardware contained on the   option 3 board.  This may indicate a hardware problem.  Press <RETURN> to       continue. ":temp$24555     Advance24560 Hdwarerr:     input prompt "This error is sent from the disk controller card.  This may indicate a problem  with the disk drive.  Press <RETURN> to continue. ":temp$24565     Advance24570 No:     input prompt "An error has occured that did not exist at the time of this software.  Press    <RETURN> to continue. ":temp$24575     Advance24580     End24600 Sub sys_dev local temp$,sysd,dev$,lu$,dev,lu,device$24605     Device$=ask$("sysdev")24610     On error(1200 to 1400) then gosub err122224615     Dim dev$ to 1,lu$ to 124620     Print "WARNING:  The system device you select must be connected and fully operational  or an error will be generated."24625     Print "
Present system device is,   "&device$&chr$(13)&" 
Do you wish to change it?"24630     Call y_nanswr24635     If answer$<>"y" then return24640     Input prompt "

Enter system device, tape or disk. <t> or <d> ":temp$24645     If temp$<>"t" and temp$<>"d" then goto 2464024650     If temp$="d" then goto dev24655     Device$="tape:"24660     Goto ret24665 Dev:     input prompt "

Enter the disk device # : ":dev$24670     If asc(dev$)<48 or asc(dev$)>54 then print "
Invalid device number...try again" else goto lu24675     Goto dev24680 Lu:     input prompt "

Enter the disk logical unit # : ":lu$24685     If asc(lu$)<48 or asc(lu$)>50 then print "
Invalid logical unit number...try again." else goto setdev24690     Goto lu24695 Setdev:     device$="Disk(dev="&dev$&",uni="&lu$&"):"24700 Ret:     set sysdev device$24705     Wait 0.524710     If pos(ask$("sysdev"),"TAPE",1) then dim filen$ to 6 else dim filen$ to 1224715     Sysdev$=seg$(device$,1,4)24720     Return24725 Err1222:     print "
Invalid disk selection...try again."24730     Branch dev24735     End24800 Sub compr24805     Print chr$(13)&"
Memory compress in progress.......wait"&chr$(13)24810     Compress all24815     Retry24820     End24900 Sub autobaud(var baud,termid) local term_id$,baud$,i,e885,nexti,found,clse24905     Fail=024910     Termid=024915     Baud=024920     Dim baud$ to 4,term_id$ to 524925     Init var baud$,term_id$,fail,termid,baud24930     On error(885) then gosub e88524935     For i=1 to 1224940       Data "9600","4800","2400","300","600","1200","1800","2000","150","134","110","75"24945       Read baud$24950       Set driver "comm0(iba="&baud$&"):"24955       Open #2:"comm0(tim=2):"24960       Input #2 prompt chr$(27)&"%!0"&chr$(27)&"NU "&chr$(27)&"IQ?T":term_id$24965       If len(term_id$)<>5 then goto nexti24970       If pos("$ 9$ :$ ;$ =",seg$(term_id$,3,3),1)<>0 then exit to found24975 Nexti:       next i24980     Fail=124985     Goto clse24990 E885:     advance24995     Return25000 Found:     termid=asc(seg$(term_id$,5,1))+404825005     Baud=val(baud$)25010 Clse:     close 225015     Return25020     End25100 Sub initerm(baud,termid) local iw$,rv$,a$,b$,i,dalin,dta25105     Print #"frtp:":"Initializing ";termid25110     Dim a$ to 300,b$ to 30025115     S$="comm0(bau="&str$(baud)&",edi=ras):"25120     Set driver s$25125     Set console s$25130     Open #1:"comm0:"25135     Print #1:"NRIX0IX0"25140     Set driver "comm0(bau=9600,edi=ras):"25145     Set console "comm0:"25150     Print #1:"LZ"&chr$(12);25155     Print #1:"%!1[?7h"25160     Print #1:"%!0";25165     Print #1:"KC";25170     Wait 0.525175     Print #1:"KL1"25180     Iw$="IW `` @?o"&chr$(127)&"?_"25185     Rv$="RV `` @7o"&chr$(127)&"?_"25190     If termid=4105 then ll$="LLA>" else ll$="LLB0"25195 Dta:     data "IH0","IM1","IA8","IJ84","IL0"25200     Data "KE0","KL0","KW1","KYA0","KA1","KG1","KI0","KF0","KR0"25205     Data "KS0","KT2","LBC1","LI100","LM0","LV1","MA00"25210     Data "MB!!","MCB7C;<","MF0","MG1","ML1","MM0","MN0"25215     Data "MP!","MQ2","MR00","MT1","MV0","NLIX0","NB1"25220     Data "NDF4","NP0","NM0","NQR<","NF0","NC=:"25225     Data "NT1=","NE0","NKL8","NU:","QA0","QD2","QL100","RA101"25230     Data "RC1","RD14","RE0","RF6","RH#|w @","RI211","RJ0","RN211"25235     Data "RQ0","RS `` @#ow$_","RU1;6","RW `` @8kn?_"25240     Data "TC0F40","TB000","TD10","TF40000","TF410F40","TF42G8C2F4"25245     Data "TF43O0C2F4","TF440C2F4","TF45R<C2F4","TF46C<C2F4","TF47K4C2F4"25250     Data "TG140000","TG1410F40","TG142G8C2F4"25255     Data "TG143O0C2F4","TG1440C2F4","TG145R<C2F4","TG146C<C2F4","TG147K4C2F4"25260     Restore dta25265     For i=1 to 8025270       Read a$25275       Print #1:a$;25280       Next i25285     If termid=4105 then goto dalin25290     Print #1:"TG148I6C2F4TG149M2C2F4TG14:P>C2F4";25295     Print #1:"TG14;T:C2F4TG14<A>C2F4TG14=E:C2F4";25300     Print #1:"TG14>0B10TG14?0D20";25305     Print rv$&"TM311"&iw$25310 Dalin:     print ll$25315     Print #1:"LZ"&chr$(12)&"KL0"25320     Print #1:"KDG#4A0A;D<E:";25325     Close 125330     Return25335     End25400 Sub tfilnam local bad,ans$,nexti,i,hh25405     For i=1 to len(filen$)25410       Hh=asc(seg$(filen$,i,1))25415       If i=1 then goto 2543525420       If i=len(filen$) then goto 2543025425       If hh=95 then goto nexti25430       If hh>=48 and hh<=57 then goto nexti25435       If hh>=65 and hh<=90 then goto nexti25440       If hh>=97 and hh<=122 then goto nexti25445       Exit to bad25450 Nexti:       next i25455     Return25460 Bad:     print "
The file name you entered contains illegal character(s) OR                      character(s) in disallowed position(s)."25465     Call commrbyt25470     Filen$=""25475     Return25480     End25500 Sub ckid local pri$,sec$,prt$,nam$,lun$,tekid$,num25505     Integer num25510     Num=val(seg$(lab$,12,2))25515     Getmem buffer instr$(num) using "6a1a2a2a2a":nam$,prt$,pri$,sec$,lun$25520     Select "gpib"&prt$&":"25525     Prim=val(pri$)25530     Sec=val(sec$)25535     Wbyte sdc(prim,sec),atn(unt,unl)25540     Open #num:"gpib"&prt$&"(pri="&pri$&",sec="&sec$&",eom=<10>,tim=10):"25545     Id$=""25550     Input #num prompt "id?":id$25555     Wbyte sdc(prim,sec+96),atn(unt,unl)25560     If pos(id$,"TEK/",1) then instr$(num)=instr$(num)&"TEK" else instr$(num)=instr$(num)&"   "25565     Return25570     End25600 Sub sdc_all local err8,ret,err81225605     On error(812) then gosub err81225610     If count9=0 then goto 2563525615     For i=1 to count925620       Select "gpib"&seg$(instr$(i),7,1)&":"25625       If seg$(instr$(i),10,2)="32" then wbyte gtl(val(seg$(instr$(i),8,2))),atn(unl) else wbyte gtl(val(seg$(instr$(i),8,2)),val(seg$(instr$(i),10,2))+96),atn(unl)25630       Next i25635     Select "gpib0:"25640     Wbyte ren(0),ren(1),atn(unt,unl)25645     If pos(ask$("driver"),"GPIB1",1) then select "gpib1:" else goto ret25650     Wbyte ren(0),ren(1),atn(unt,unl)25655 Ret:     return25660 Err812:     advance25665     End25700 Sub commrbyt local ans$25705     Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))25710     If ty<>0 then call clr_bufr25715     Print "Press any key to continue";25720     Rbyte #700:ans$25725     Print25730     Return25735     End25800 Sub setins local i,ii25805     Data "AA","SG","CG","PS","","XX","OPER",""25810     Data "5001","5010","5001","5004","7D20","INSTR","PRMPT","HELP"25815     Data "DC5010","2465","DM","FG","PS","MI","SI",""25820     Data "DC5009","2445","5010","5010","5010","5010","5010",""25825     Data 1,2,3,4,5,6,7,0,9,10,11,12,13,14,15,1625830     Restore 2580525835     Read keylab1$,keylab2$,keylab3$,keylab4$,validkey25840     Xx=025845     For i=1 to 525850       Sel_cnt=025855       For ii=1 to count925860         If pos(instr$(ii),keylab1$(i)&keylab2$(i),1) then sel_cnt=125865         If pos(instr$(ii),"XX",1) then xx=125870         Next ii25875       If sel_cnt then goto 25890 else keylab1$(i)=""25880       Keylab2$(i)=""25885       Validkey(i+8)=025890       Next i25895     If xx=1 then goto 25910 else validkey(14)=025900     Keylab1$(6)=""25905     Keylab2$(6)=""25910     For i=1 to 725915       Sel_cnt=025920       For ii=1 to count925925         If i<>1 then goto 2593525930         If pos(instr$(ii),"DC50",1) then sel_cnt=125935         If i<>2 then goto 2594525940         If pos(seg$(instr$(ii),1,2),"24",1) then sel_cnt=125945         If pos(instr$(ii),keylab3$(i)&keylab4$(i),1) then sel_cnt=125950         Next ii25955       If sel_cnt then goto 25970 else keylab3$(i)=""25960       Keylab4$(i)=""25965       Validkey(i)=025970       Next i25975     Inslab1$=keylab1$25980     Inslab2$=keylab2$25985     Inslab3$=keylab3$25990     Inslab4$=keylab4$25995     Inskey=validkey26000     Return26005     End