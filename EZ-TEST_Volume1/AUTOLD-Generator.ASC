4!  *************************************************************8!  **                                                         **12!  **                  TEK EZ-TEST VOLUME I                   **16!  **                 TEST PROGRAM GENERATOR                  **20!  **            4100 SERIES COLOR GRAPHIC TERMINAL           **24!  **                      Version 5.0                        **28!  **                                                         **32!  **                       * * * * *                         **36!  **                                                         **40!  **          COPYRIGHT (c) 1984 by TEKTRONIX, INC.          **44!  **                   ALL RIGHTS RESERVED                   **48!  **                                                         **52!  **                       * * * * *                         **56!  **                                                         **60!  **   This  software may not be  copied, in  whole or in    **64!  **   part, without written permission of Tektronix, Inc.,  **68!  **   except for back-up and  archive  purposes.  Removal   **72!  **   of this Copyright and Disclaimer  statement will be   **76!  **   violation of the Copyright.                           **80!  **                                                         **84!  *************************************************************100Clr_mem:dele var all105Init all110Inte grph,plot,sgpr,utl1,term,baud,wipe,termid,verflag115Dim page$ to 16,pagem$ to 16,pagew$ to 16,bell$ to 1120Sele"gpib0:"125Open#102:"FRTP:"130Open#200:"PRIN:"135Open#300:"gpib0:"140Open#700:"COMM:"145If pos(ask$("driver"),"COMM1",1)then set driv"COMM1(bau=9600):"150If pos(ask$("driver"),"COMM1",1)then open#800:"COMM1(tim=2,tms=5):"155If pos(ask$("driver"),"GPIB1",1)then open#400:"gpib1:"else open#400:"gpib0:"160On abor then call abormenu165On erro(1 to 999)then call all_errs170On erro(1200 to 1495)then call disk_err175On erro(114)then call compr180On erro(815 to 818)then call pollerrs185On erro(554)then call timerr190On erro(811)then call timout195On erro(842)then call taperr1200On erro(1207)then call taperr1205On erro(843)then call taperr2210On erro(850)then call file_is215On erro(1204)then call file_is220On erro(851)then call taperr4225On erro(1202)then call taperr4230On erro(853)then call taperr3235On erro(1205)then call taperr3240On erro(855)then call file_eof245On erro(1206)then call file_eof250On erro(888)then call err_888255On erro(1000)then call exitest260Bell$=chr$(7)265Prin#102:"TEK EZ-TEST"270If pos(ask$("rompack"),"GRPH",1)then grph=1 else grph=0275If pos(ask$("rompack"),"PLOT",1)then plot=1 else plot=0280If pos(ask$("rompack"),"SGPR",1)then sgpr=1 else sgpr=0285If pos(ask$("rompack"),"UTL1",1)then utl1=1 else utl1=0290If pos(ask$("id"),"2.0",1)then verflag=1 else verflag=0295Term=1300Call autobaud(baud,termid)305If fail=0 then goto init4100310Set_baud:inpu#102 prom"TERMINAL BAUD ":baud315Set_driv:set driv"COMM0(BAU="&str$(baud)&",EDIT=RAS,fla=bid,stop=1):"320Init4100:call initerm(baud,termid)325Pagew$=""&chr$(12)330Pagem$="LZ"335Page$=pagew$&pagem$340Call map_key345Wipe=1350Termrdy:prin#102:"TERMINAL IS READY"355Prin"TG1400C2F4";360Prin"TF410F40TF42I6A>F4LI122";365Prin"KA0LV0MT5"&page$;370Wait .5375Prin usin"//=73A/":"MCD9H2B=LTA;TEK  EZ-TEST  "&str$(termid)380Prin usin"=80A":"MCD9F4B=LT<Version 5.0"385Prin usin"///2(=80a)":"TEKTRONIX TEST and MEASUREMENT Software","4100 SERIES TERMINAL"390Prin usin"/=80a/=80a3/":"Copyright (c) 1984,  TEKTRONIX Inc.","ALL RIGHTS RESERVED"395Prin usin"=79a//////////":"*     *     *"400Call commrbyt405Prin pagew$410Dim lolmt$ to 20,hilmt$ to 20,out$ to 2,unitspc$ to 20,cgdata$ to 20,i$ to 40,delay$ to 10,log_unt$ to 10,old_lu$ to 200,wfpre$ to 200,count$ to 3,cmap$ to 150,revcmap$ to 150,bmap$ to 150,map$ to 150415Dim acqblok$ to 10000,blokbuf$ to 10000,tape$ to 100,timdate$ to 18,t_dev$ to 25,khead$ to 30,answer$ to 2,error$ to 30,ty$ to 2,blocklu$ to 300,outdev$ to 1,gptmout$ to 10,outadd$ to 200420Long loop(10,5),rdata,low,up,fntest,rdtemp,xplt,yplt425Dim c$ to 2,ret2prt$ to 200,gpib$ to 30,id$ to 25,key$ to 3,fsav$ to 15,finish$ to 20,start$ to 20,ret$ to 4,step$ to 20,typ$ to 12,l$ to 10,rdata$ to 30,u_d$ to 10,set1$ to 550,styp$ to 1430Dim answer$ to 1,plab$ to 20,lab$ to 16,label$ to 27,unit$ to 5,id$ to 30,path$ to 50,phypar$ to 140,logpar$ to 120,com$ to 120,phy$ to 160,line$ to 82,mode$ to 20,memnum$ to 15,date$ to 18435Dim outdata$ to 8,outset$ to 1,keylab1$(8)to 9,keylab2$(8)to 9,keylab3$(8)to 9,keylab4$(8)to 9,p_f$ to 6,cnt$ to 20,suffix$ to 5,delay$ to 8,stimset$ to 10,metemp$ to 80,tnam$ to 25440Dim inslab1$(8)to 9,inslab2$(8)to 9,inslab3$(8)to 9,inslab4$(8)to 9445Inte inskey(16)450Dim newprcd$(100)to 600,loop$(10,2)to 600,instr$(28)to 16,actcod$ to 6,iocode$ to 4,proc$ to 600,lset$ to 550,kset$ to 550,binprpt$ to 100,bstep$ to 16,proctmp$ to 600,strem$ to 300,filelnk$ to 200,unlok$ to 8,null$ to 20,n$ to 1455Inte fn_num,brchnxt,brchfail,iterates,brchstrt,ret_rn,lg_lin,incr,lstrt,lstop,lstpitr,l_par,llog,lacqr460Data 1,2,3,4,5,6,7,1,2,3,4,5,1,2465Rest 470Read brchnxt,brchfail,iterates,brchstrt,ret_rn,lg_lin,incr,lstrt,lstop,lstpitr,l_par,llog,lstim,lacqr475Inte ins1,ins2,i,logd,err,typos,data_lu,datlutmp,cr1,cr0,oldfil,eof_err,eompos,commapos,memnum,filsiz,ebranch,nxstp,begstp,endstp,keyfl,nxstp,o_count,count1,count2,kk,ret_stak(20),stak_pt,substp,count9480Inte i,log_unit,outadd,prt,address,status,count,ins_cnt,mecount,me_max,f,keyflag,workspac,test,validkey(16),gport0,gport1,xrfrnc(100),newrfrnc(100),sequence(100,7),stp_ptr(100),log_all,stp,cntr,seqr(100)495Dim filed$ to 50,filex$ to 50,me_data$(3000)to 58,ftype$ to 8,helpfil$ to 6,opname$ to 25,f_flag$ to 3,sgn$ to 1,low$ to 20,up$ to 20500Inte try,stb,pri,port,bus,prim,err818,sec,err812,dsp_flg,wfpts,sel_cnt,secondry505Init var count,err,workspac,out$,count9,mbranch,delay,low,up,loops,start,endval,stepval,str_len,filesize,b,j,fn,v,linelen,outchr,sequence510N$=chr$(0)515Null$=n$&n$&n$&"0"&n$&"0"&n$&"0"&n$&n$&n$&"0"&n$&"10"&n$&n$520Newprcd$=null$525Loop$=null$530Init var log_unit,jump_out,flg1,newf,out$,lab$,n,m,q,mis_ins,mis,s_tep,stp,fntest,repeat,mecount,rdtemp,avg,done,bgn,e_nd,base,top,perlvl535Init var offset,u_d,range,n_pk,p_pk,space1,semicol,ty,typos,typdel,strt,xx,delay540Cmap$="TG140R<B80TG141J:C2F4TG142M2C2D;TG143R<C<C2TG144E:C2D;TG145J:B8F4TG146L8C2D;TG147E:E:F4"545Revcmap$="TG140R<00TG141G8C2F4TG142P4A>F4TG1430C2F4TG144G8C2F4TG145I6C<F4TG146P4C2F4TG147E:E:F4TF42000TF47O0C2F4"550Bmap$="TF410E:F4TF40G8C2F4TF42J:A>F4TF46G8E0F4LI122TG140R<A>F4TG1410A4F4TG142G8E0F4TG143O0C2C4TG1440C2C4TG145R<C2C4TG146C<C2C4TG147K4C2C4"555Map$=bmap$560Key$="N/A"565Data_lu=100570Datlutmp=100575Prin"KA1LV1"580Sysdev$=seg$(ask$("sysdev"),1,4)585If sysdev$="TAPE"then dim filen$ to 6 else dim filen$ to 12590If pos(ask$("time"),"01-JAN-81",1)then prin page$ else goto 615595Prin"
Enter date and time."600Prin"
Day-Month-Year Hour:Minute:Second  e.g...25-MAY-84 10:45:10"605Inpu timdate$610Set time timdate$615If not(pos(ask$("driver"),"GPIB1",1))then goto 630620On srq(400)then call prt1625Enab srq(400)630On srq(300)then call prt0635Enab srq(300)640Main_lab:prin pagem$645Call sdc_all650Init var path$655Prin#102:"SELECT MENU KEY"660On key(1)then call keyfla1665On key(2)then call keyfla2670On key(3)then call keyfla3675On key(4)then call keyfla4680On key(5)then call keyfla5685On key(6)then call keyfla6690On key(7)then call keyfla7695On key(8)then call keyfla8700On key(9)then call keyfla9705On key(10)then call keyfla10710On key(11)then call keyfla11715On key(12)then call keyfla12720On key(13)then call keyfla13725On key(14)then call keyfla14730On key(15)then call keyfla15735On key(16)then call keyfla16740On key(20)then call copyscrn745Khead$="MAIN MENU KEYS"750Data"","",""," SYS","","","",""755Data"","",""," DEV","","","",""760Data"","","","","","","",""765Data"","","","","","","",""770Data"EDIT ","GET","SAVE","FILE ","NEW","TERMN","HELP ","EXEC "775Data"PROCD","PROCD","PROCD","UTIL ","PROCD","PROGM","","PROCD"780Init var keylab3$,keylab4$,keylab1$,keylab2$,mbranch785If pos(ask$("driver"),"DISK",1)then rest 750 else rest 760790Read keylab1$,keylab2$795Restr:rest 770800Read keylab3$,keylab4$805Call gkeydisp810Workspac=1815Enab keys820Prin pagem$825Prin"Press a function key"830On abor then call abort2mn835Enab abor840Keyflag=0845Wait 850Gosu keyflag of changek,infilek,storek,filutil,restart,endit,helpmain,runit,deadkey,deadkey,deadkey,sysdev,deadkey,deadkey,deadkey,deadkey855If keyflag=0 then goto 820860Goto 745865Changek:call change870Retu875Infilek:cnt$=""880Path$=" GET PROCEDURE FROM "&sysdev$885Key$="F2"890Filelnk$=chr$(13)895Call path_lab900Prin"
WARNING:  Any procedure that is in memory will be destroyed."905Prin"          Are you sure this is what you want to do?
"910Call y_nanswr915If answer$="n"then retu920Call infile925Retu930Storek:cnt$=""935Path$=" STORE PROCEDURE ON "&sysdev$940Key$="F3"945Call path_lab950Call store955Retu960Restart:prin pagem$965Cnt$=""970Path$=" CLEAR FOR NEW PROCEDURE"975Key$="F5"980Call path_lab985Prin usin"3l=72a":"This function clears all previous procedure generation."990Inpu prom"    
Enter ""OK"" to proceed or press <RETURN> to go back to MAIN MENU : ":ret$995If ret$<>"OK"and ret$<>""then goto 9601000If ret$="OK"then call re_start else retu1005Call change1010Retu1015Helpmain:path$=" DISPLAY HELP INFORMATION"1020Key$="F7"1025Cnt$=""1030Call path_lab1035Helpfil$="HMAIN"1040Call prinhelp1045Keyflag=01050Path$=""1055Retu1060Runit:cnt$=""1065Path$=" TEST EXECUTION"1070Key$="F8"1075Call path_lab1080Filelnk$=""1085Call r_main1090Retu1095Sysdev:if not(pos(ask$("driver"),"DISK",1))then retu1100Cnt$=""1105Path$=" SET SYSTEM DEVICE"1110Key$="S4"1115Call path_lab1120Call sys_dev1125Retu1130Endit:prin page$&ll$1135Prin usin"2l=79a":"Are you sure you are ready to leave the program?"1140Prin usin"2l=79a":"You get one more chance !!!!!!"1145Prin usin"2l=79a":"Press <RETURN> to continue or ""EXIT"" to terminate the program."1150Inpu prom"


                       I'm waiting for your response: ":ret$1155If ret$="EXIT"then goto 1405 else wipe=11160Mbranch=11165Retu1170Deadkey:keyflag=01175Retu1180Filutil:path$=" FILE UTILITIES"1185Cnt$=""1190Key$="F4"1195Call path_lab1200Prin path$1205Choice:prin usin"/4(20t40a//)":"""X"" = DELETE a file","""R"" = RENAME a file","""F"" = FORMAT a "&sysdev$&" (or re-format)","""D"" = DIRECTORY of "&sysdev$1210Inpu prom"Enter choice of  X, R, F, D or press <RETURN> for none : ":ret$1215Prin usin"//":1220If ret$=""then goto no_choic1225If ret$="X"then gosu del_fil1230If ret$="R"then gosu rena_fil1235If ret$="F"then gosu form_tap1240If ret$<>"D"then goto choice1245Prin"
NOTE:  See MANUAL for a description of wild card search character entry.
"1250If pos(ask$("sysdev"),"DISK",1)then inpu prom"
Enter wild card search characters (e.g.; test.*, master.*)                      or Press <RETURN> for entire directory.  : ":ans$ else ans$=""1255If ans$=""then dir  else dir ans$1260Prin"
DIRECTORY to 4041 printer?"1265Call y_nanswr1270If answer$="Y"then dir  to"PRIN:"1275Goto choice1280No_choic:retu1285Del_fil:inpu prom"Enter filename to delete :":filen$1290If not(len(filen$))then retu1295Prin"Delete file :"&filen$&" ?"1300Call y_nanswr1305If answer$="Y"then dele file filen$1310Prin pagem$1315Retu1320Rena_fil:dir"(lon=yes)"1325Inpu prom"
RENAME a file - enter OLD file name : ":filen$1330Renamerr=01335If not(len(filen$))then retu1340Inpu prom"
Enter NEW file name : ":fsav$1345Rena filen$ to fsav$1350If renamerr then goto rena_fil1355Prin pagem$1360Retu1365Form_tap:prin"
WARNING :  FORMAT will destroy ALL files on the "&sysdev$&" !!!!!"1370Prin"
Are you sure this is what you want to do?"1375Call y_nanswr1380If answer$<>"y"then retu1385Inpu prom"FORMAT the  "&sysdev$&" - enter the Volume label : ":filen$1390Form filen$1395Prin pagem$1400Retu1405Call sdc_all1410Call initerm(baud,termid)1415Prin"KDG#0"1420Prin usin"=72a":"Memory Clean-up In Progress"1425Dele var all1430Comp all1435Prin usin"=72a":"Tek EZ-TEST Program Terminated"1440Prin#"frtp:":"Program Terminated"1445End1500Sub keyfla11505Keyflag=11510Resu1515End1600Sub keyfla21605Keyflag=21610Resu1615End1700Sub keyfla31705Keyflag=31710Resu1715End1800Sub keyfla41805Keyflag=41810Resu1815End1900Sub keyfla51905Keyflag=51910Resu1915End2000Sub keyfla62005Keyflag=62010Resu2015End2100Sub keyfla72105Keyflag=72110Resu2115End2200Sub keyfla82205Keyflag=82210Resu2215End2300Sub keyfla92305Keyflag=92310Resu2315End2400Sub keyfla102405Keyflag=102410Resu2415End2500Sub keyfla112505Keyflag=112510Resu2515End2600Sub keyfla122605Keyflag=122610Resu2615End2700Sub keyfla132705Keyflag=132710Resu2715End2800Sub keyfla142805Keyflag=142810Resu2815End2900Sub prt02905Disa srq(400)2910Prt=02915Sele"gpib0(spe=.1,tim=.2):"2920If not(pos(ask$("lu",400),"ENA=0",1))then goto 29052925Call getstaby2930Enab srq(400)2935Resu2940End3000Sub keyfla153005Keyflag=153010Resu3015End3100Sub keyfla163105Keyflag=163110Resu3115End3200Sub copyscrn3205Prin revcmap$3210Prin"KH1"3215Wait 13220Prin map$3225Answer$="z"3230Resu3235End3300Sub prt13305Disa srq(300)3310Prt=13315Sele"gpib1(spe=.1,tim=.2):"3320If not(pos(ask$("lu",300),"ENA=0",1))then goto 33053325Call getstaby3330Enab srq(300)3335Resu3340End3400Sub re_start loca begin3405Begin:init var loop,stp_ptr,count,mis,cntr3410Newprcd$=null$3415Loop$=null$3420Key$=""3425Sequence=03430Prin usin"2l=72a":"**** Start new setup procedure ****."3435Cnt$=""3440Path$=" RE-CONFIGURE GPIB"3445Call path_lab3450Call tm_conf3455If cntr>14 then goto begin else retu3460End3500Sub getstaby loca err_8153505On erro(815)then gosu err_8153510Init var error$,err,status,address,secondry3515Poll status,address,secondry3520If pos(ask$("path"),"TM_CONF",1)then retu3525If pos(ask$("path"),"change",1)and(status=67 or status=83)or(status=65 or status=81)or(status=64 or status=80)or status=0 then goto 3590 else goto 35303530If(status=67 or status=83)or(status=65 or status=81)or(status=64 or status=80)or(status=66 or status=82)or status=0 then goto 35903535If status=65 or status=81 then error$="POWER ON INTERRUPT"3540If status=66 or status=82 then error$="OPC INTERRUPT"3545If status=67 or status=83 then error$="USER INTERRUPT"3550If status=97 or status=113 then error$="COMMAND ERROR"3555If status=98 or status=114 then error$="EXECUTION ERROR"3560If status=99 or status=115 then error$="INTERNAL ERROR"3565If status=102 or status=118 then error$="INTERNAL WARNING"3570If status>=120 or status>=120+16 then error$="DEVICE DEP INTERRUPT"3575Err=13580Prin chr$(13)&"
-- INSTRUMENT at address ";address;";";secondry;" on port ";prt;" reported "&error$&" status ";status;" -- "3585Prin#200 usin"/<8A2D1a2d1X5A1D/<20A<18A/8A3D/12A3D":"Address: ",address,";",secondry,"Port: ",prt,"reported: ",error$,"Status: ",status,"Step # ",stp3590Retu3595Err_815:adva3600End3700Sub instru(wipe,key_mes$,lp_again)loca unused,i,ii,inst_lab,sel_dc9,sel_dc10,sel_dm,sel_fg,sel_ps04,sel_ps,sel_si,sel_mi,sel_cg,sel_aa,sel_sg,sel_7d20,help_ins,textkk,sel_xx3705Enab abor3710Inst_lab:khead$="INSTRUMENT SELECTION MENU"3715Init var ebranch3720Validkey=inskey3725Keylab1$=inslab1$3730Keylab2$=inslab2$3735Keylab3$=inslab3$3740Keylab4$=inslab4$3745If pos(ask$("path"),"fornxt",1)then validkey(15)=0 else goto 37603750Keylab1$(7)=""3755Keylab2$(7)=""3760Call gkeydisp3765Key$=""3770Call path_lab3775Prin pagem$3780Prin key_mes$&" or"&chr$(13)&"<Crtl C> to abort step and RETURN to EDIT menu."3785Init var keyflag3790If count<=100 then goto 3810 else prin"
The maximum of 100 steps has been generated."3795Wait 63800Keyflag=83805Retu3810Wait 3815If keyflag=0 then goto 38103820Prin pagem$3825Keyfl=keyflag3830Gosu validkey(keyflag)of sel_dc10,sel_2465,sel_dm,sel_fg,sel_ps,sel_mi,sel_si,unused,sel_aa,sel_sg,sel_cg,sel_ps04,sel_7d20,sel_xx,textkk,help_ins3835If ebranch then retu3840If validkey(keyfl)=0 then goto 37803845If pos(ask$("path"),"fornxt",1)then retu3850If lp_again then goto inst_lab else retu3855Sel_dc10:dc_cnt$=""3860For i=1 to count93865If pos("DC5009 DC5010",seg$(instr$(i),1,6),1)then dc_cnt$=dc_cnt$&seg$(instr$(i),1,6)3870Next i3875If len(dc_cnt$)=6 then call set_up(dc_cnt$,"USER")else goto 38853880Retu3885Prin"
     Select COUNTER type:

"3890Prin"              1. DC5010"3895Prin"              2. DC5009"3900Inpu prom"
     Enter choice : ":ans$3905If ans$<>"1"and ans$<>"2"then goto 39003910If ans$="1"then dc_cnt$="DC5010"else dc_cnt$="DC5009"3915Call set_up(dc_cnt$,"USER")3920Retu3925Sel_2465:dc_cnt$=""3930Init var t1,t23935For i=1 to count93940If pos(instr$(i),"2445  ",1)then t2=13945If pos(instr$(i),"2465  ",1)then t1=13950Next i3955If t1 and t2 then goto 39703960If t1 then call set_up("2465  ","")else call set_up("2445  ","")3965Retu3970Prin"
     Select SCOPE type:

"3975Prin"              1. 2465"3980Prin"              2. 2445"3985Inpu prom"
     Enter choice : ":ans$3990If ans$<>"1"and ans$<>"2"then goto 39853995If ans$="1"then dc_cnt$="2465"else dc_cnt$="2445"4000Call set_up(dc_cnt$,"")4005Retu4010Sel_dm:call set_up("DM5010","USER")4015Retu4020Sel_fg:call set_up("FG5010","USER")4025Retu4030Sel_ps04:call set_up("PS5004","USER")4035Retu4040Sel_ps:call set_up("PS5010","USER")4045Retu4050Sel_si:call set_up("SI5010","USER")4055Retu4060Sel_mi:call set_up("MI5010","USER")4065Retu4070Sel_cg:call set_up("CG5001","REM")4075Retu4080Sel_aa:call set_up("AA5001","")4085Retu4090Sel_sg:call set_up("SG5010","USER")4095Retu4100Sel_7d20:call set_up("7D20  ","USER")4105Retu4110Help_ins:path$=" HELP for SELECTION MENU"4115Key$="S8"4120Call path_lab4125Helpfil$="HSELIN"4130Path$=""4135Call prinhelp4140Keyflag=04145Retu4150Unused:retu4155Textkk:key$="S7"4160Call path_lab4165Call text4170Ebranch=14175Retu4180Sel_xx:call set_up("XX","")4185Retu4190End4200Sub set_up(sel_ins$,useron$)loca iden$,to_main,deadkey,nxt_i,set_lab,tsignal,unlok,setdlay,keybrd,lrnit,tak_meas,to_edit,acq_blk,acq_wfm,toolong,tlk_lsn4205On erro(64)then gosu toolong4210Iden$=seg$(sel_ins$,1,2)4215Ins_cnt=count94220Sel_cnt=04225For i=1 to count94230If pos(instr$(i),sel_ins$,1)then sel_cnt=sel_cnt+1 else goto 42404235Log_unit=i4240Next i4245If sel_cnt=1 then goto 43254250Prin pagem$4255Prin usin"27TFA/":"Active "&sel_ins$&"(s):"4260Prin usin"10T8A6X12A6X4A6X7A/10T'--------'6X'------------'6X'----'6X'-------'":"DEVICE #","DEVICE NAME","PORT","ADDRESS"4265For i=1 to count94270If pos(instr$(i),sel_ins$,1)then goto 4280 else ins_cnt=ins_cnt-14275Goto nxt_i4280If seg$(instr$(i),10,2)="32"then prin usin"13T2D12XFA11XFA10XFA":i,seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2)4285If seg$(instr$(i),10,2)<>"32"then prin usin"13T2D12XFA11XFA8XFA":i,seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2)&";"&seg$(instr$(i),10,2)4290Nxt_i:next i4295Prin"
                     Select one (DEVICE #): ";4300Inpu log_unit4305If(log_unit>count9 or log_unit<=0)then prin usin"/22TFA":"Invalid number for the "&sel_ins$ else goto 43154310Goto 42954315If not(pos(instr$(log_unit),sel_ins$,1))then prin usin"/22tfa":"Invalid number for the "&sel_ins$ else goto 43254320Goto 42954325If log_unit<=9 then log_unt$="0"&str$(log_unit)else log_unt$=str$(log_unit)4330Iocode$=iden$4335Actcod$="NR"4340Init var lset$,kset$,label$,unit$,delay,low,up4345Delay$="0"4350Gptmout$="10"4355Unlok$="LOCKOUT"4360Proc$=null$4365If flg1 then retu4370Wipe=14375Set_lab:init var keylab1$,keylab2$,keylab3$,keylab4$4380Key$=""4385Khead$=seg$(instr$(log_unit),1,6)&" OPERATING MODES"4390Data"LEARN","KEYBD","SET","MAKE ","ACQR","UNLOK","TALK/","EDIT "4395Data"SETNG","INPUT","DELAY","MEAS ","BLOCK","PANEL","LISTEN","MENU "4400Rest 43904405Read keylab3$,keylab4$4410If unlok$="LOCKOUT"then keylab3$(6)="UNLOK"else keylab3$(6)="LOCK"4415If pos(iden$,"7D",1)then keylab4$(5)="WVFRM"4420Call gkeydisp4425Prin pagem$4430Call path_lab4435Prin"
Press a function key"4440Keyflag=04445Wait 4450If keyflag=0 then goto 44454455If iden$="7D"then gosu keyflag of lrnit,keybrd,setdlay,tak_meas,acq_wfm,unlok,tlk_lsn,to_edit,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey else goto 44654460Goto 44704465Gosu keyflag of lrnit,keybrd,setdlay,tak_meas,acq_blk,unlok,tlk_lsn,to_edit,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey4470If keyflag=0 then goto 44454475If keyflag=7 then goto 44304480If keyflag=1 then goto 44304485If jump_out then jump_out=0 else goto set_lab4490Ebranch=14495Retu4500Unlok:if unlok$="LOCAL"then unlok$="LOCKOUT"else unlok$="LOCAL"4505Prin"
The ";sel_ins$;" will be in ";unlok$4510Retu4515Setdlay:inpu prom"
Enter delay value in seconds: ":delay4520Delay=int(delay*100)/1004525If delay<=32000 then goto 4540 else prin"

Entered value too large....try again."4530Wait 24535Goto setdlay4540Delay$=str$(delay)4545Retu4550Keybrd:path$=" KEYBOARD INPUT"4555Key$="F2"4560Call path_lab4565Rep$(path$,pos(path$,"key",1),14)=""4570Err=04575Kset$=""4580If pos(iden$,"XX",0)then goto 46054585If pos(iden$,"AA",1)or pos(iden$,"SG",1)then inpu#log_unit prom"help?":kset$4590If kset$<>""then prin usin"'Keywords are: '//500a/":kset$4595Inpu#log_unit prom"SET?"buff blokbuf$:blokbuf$4600Prin usin"'Settings are:'//fa/":blokbuf$4605If len(lset$)then prin"

ENTERING COMMANDS FROM THE KEYBOARD WILL ALTER THE PREVIOUSLY LEARNED SETUP!"4610Prin usin"FA2/FAS":"
ENTER DEVICE ASCII COMMANDS  (imbedded carriage return is permitted)","press <LINE FEED> to stop entry : "4615Inpu#"COMM0(EOM=<10>):":kset$4620If pos(kset$,"INIT",1)then prin usin"/fa":"The INIT command will negate any learned settings in this step!"else goto 46404625Prin"
Is this what you want?"4630Call y_nanswr4635If answer$<>"Y"then goto 46104640If len(kset$)+len(lset$)>550 then prin usin"//FA":"KEYBOARD settings plus LEARNED settings too large!  ALL settings discarded. "else goto 46554645Init var kset$,lset$4650Retu4655Prin#log_unit:lset$&kset$4660Wait .54665If status>90 and err and iden$<>"XX"then goto 4570 else retu4670Lrnit:if not(iden$="XX")then goto 46904675Prin usin"/FA/FA/FA":"LEARN SETTINGS applies to TEKTRONIX instruments conforming to the ","Codes and Formats standard.","Do you wish to attempt LEARN SETTINGS with this instrument?"4680Call y_nanswr4685If answer$="N"then retu4690Path$=" LEARN SETTINGS"4695Key$="F1"4700Binprpt$=""4705Call path_lab4710Rep$(path$,pos(path$,"learn",1),15)=""4715Keyflag=04720If len(useron$)then prin#log_unit:useron$&" ON"4725If iden$<>"24"then goto 47454730Prin"
Set up the "&sel_ins$&" front panel and then press function KEY 1                       to store the current settings."4735Wait 4740Goto 47704745If not(iden$="XX"or iden$="FG"or iden$="SG"or iden$="PS")then goto 48154750Prin"
Do you wish to learn Low Level Binary settings?"4755Call y_nanswr4760If answer$="N"then goto 48154765Inpu prom"
Set up "&sel_ins$&" front panel and then enter the prompt for binary settings (defaults to LLSET? if no entry) : ":binprpt$4770Sele ask$("lu",log_unit)4775If len(binprpt$)then prin#log_unit:binprpt$ else prin#log_unit:"LLSET?"4780Wait 1 4785     If seg$(instr$(log_unit),10,2)="32" then wbyte atn(val(seg$(instr$(log_unit),8,2))+64,mla) else wbyte atn(val(seg$(instr$(log_unit),8,2))+64,val(seg$(instr$(log_unit),10,2))+96,mla)4790Rbyt blokbuf$4795Wbyt atn(unt,unl)4800Lset$=blokbuf$4805Inpu prom"

THE SETTINGS HAVE BEEN LEARNED"&chr$(13)&"Press <RETURN> to continue.":ans$4810Goto 49154815Prin"
Set up "&sel_ins$&" front panel and then press either the "&sel_ins$&" INST ID button"&chr$(13)&"or function KEY 1 to store the current settings."4820Prin"
If you press the wrong INST ID button nothing will happen."4825Wait 4830If keyflag=1 then goto 48454835If iden$="CG"and(status=64 or status=80)then goto 48454840If status<>67 and status<>83 then goto 48254845If len(useron$)then prin#log_unit:useron$&" OFF"4850If iden$="7D"then inpu prom"LO OF;SET?;WFMPRE?"#log_unit:lset$ else inpu prom"SET?"#log_unit:lset$4855If iden$<>"AA"or not(pos(lset$,"DBR",1))then goto 48804860Prin#"frtp:":""4865Prin"

dbRATIO is not a programmable function..."4870Wait 24875Rep$(lset$,pos(lset$,"DBR",1),4)=""4880Prin"

THE FOLLOWING SETTINGS HAVE BEEN LEARNED:"4885Prin"

"&lset$4890If iden$<>"XX"then goto 49154895Prin"
Are these settings correct?"4900Call y_nanswr4905If answer$="Y"then goto 4915 else lset$=""4910Prin"
The LEARNED SETTINGS were discarded ! "4915If iden$="XX"then keyflag=2 else keyflag=14920If len(lset$)>0 then kset$=""4925Retu4930Toolong:prin usin"//fa":"Settings too large.  Settings discarded!"4935Init var lset$,kset$4940Bran set_lab4945Tak_meas:path$=" MAKE MEAS"4950Path$=" MAKE MEAS"4955Key$="F4"4960Call path_lab4965Rep$(path$,pos(path$,"make",1),10)=""4970Jump_out=14975Call query(iden$)4980Call sav_data(proc$)4985Retu4990To_edit:if pos(ask$("path"),"fornxt",1)then prin"
The measurement loop sequence must be complete before returning to EDIT MENU!"else goto 50004995Retu5000Jump_out=15005Call sav_data(proc$)5010Retu5015Deadkey:keyflag=05020Retu5025Acq_blk:if pos(ask$("path"),"fornxt",1)then prin"
ACQUIRE BLOCK is not permitted in LOOP steps.
"else goto 50355030Retu5035Path$=" ACQUIRE BLOCK DATA"5040Key$="F5"5045Call path_lab5050Call aqtimout5055Old_lu$=ask$("lu",log_unit)5060Old_lu$=seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",tim="&gptmout$&",eom=<0>):"5065Rep$(path$,pos(path$,"ACQUIRE",1),18)=""5070Prin"
Warning: Block Acquire negates use of keys 1, 2, and 4
"5075Actcod$="BA"5080Call respond5085If filen$=""then goto 51005090Inpu#old_lu$ buff blokbuf$:acqblok$5095Inpu prom"
Acquired block is "&str$(len(acqblok$))&" bytes -  enter file size (should be larger) : ":filsiz5100Lset$=filen$&"(ope=new,size="&str$(filsiz)&")"5105Kset$=""5110L$=iden$&" BLOCK"5115Inpu prom"

What do you want to call this measurement (15 Character max) : ":lab$5120If lab$=""then label$=l$ else label$=lab$5125Call sav_data(proc$)5130Jump_out=15135Retu5140Acq_wfm:if pos(ask$("path"),"fornxt",1)then prin"
ACQUIRE WAVEFORM is not permitted in LOOP steps."else goto 51505145Retu5150Path$="ACQUIRE 7D20 WAVEFORM"5155Key$="F6"5160Call path_lab5165Call aqtimout5170Actcod$="DW"5175Rep$(path$,pos(path$,"ACQUIRE",1),21)=""5180Prin"
Warning: Waveform acquire negates use of keys 1, 2, and 4
"5185Old_lu$=ask$("lu",log_unit)5190Open#log_unit:seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",tim="&gptmout$&",eom=<0>,eoa=<0>):"5195Inpu#old_lu$ prom"di? csw":memnum$5200Memnum=val(memnum$)5205Prin#old_lu$:"DA ME:"&str$(memnum)5210Inpu#old_lu$ prom"DA? ENC":mode$5215Mode$=seg$(mode$,pos(mode$,":",1)+1,len(mode$))5220Call getwfm20(log_unit,mode$,wfpre$,wfdata)5225Open#log_unit:old_lu$5230If not(grph and plot)then goto 52755235Prin"LI100"&page$&cmap$5240 GINIT 700,4113,15245Prin"
Waveform acquired!"5250Call norwfm20(wfdata,wfpre$,normdata)5255Call plotwf20(normdata,wfpre$,1,2,3,0,"7D20 WFM "&str$(memnum)&",TEST STEP "&str$(count+1)&",TIME,VOLTS,TEKTRONIX DLTPG S/W,")5260Call commrbyt5265Prin page$5270Call gkeydisp5275Prin"Specify file for waveform storage at runtime . . ."5280Call respond5285If filen$=""then goto 52955290Inpu prom"
Waveform requires "&str$(len(wfpre$)+val(seg$(ask$("var",wfdata),posn(ask$("var",wfdata),",",1,2),10))*5)&" bytes file size : enter desired file size : ":filsiz5295Lset$=filen$&"(OPEN=NEW,SIZE="&str$(filsiz)&")"5300Kset$=""5305L$="7D20 WFM "&str$(memnum)5310Inpu prom"

What do you want to call this waveform (15 character max) : ":lab$5315If lab$=""then label$=l$ else label$=lab$5320Call sav_data(proc$)5325Workspac=05330Jump_out=15335Retu5340Tlk_lsn:path$="  TALK & LISTEN"5345Key$="F7"5350Call path_lab5355Path$=""5360Prin usin"//FA":"ENTER Device command (terminate with <LINE FEED>) : ";5365Inpu#"comm0(eom=<10>):":blokbuf$5370Prin#log_unit:blokbuf$5375If not(pos(instr$(log_unit),"TEK",1))then goto 53855380If pos(blokbuf$,"?",1)then goto 5385 else goto donetalk5385Inpu#log_unit:blokbuf$5390If pos(blokbuf$,chr$(27),0)or pos(blokbuf$,chr$(28),0)or pos(blokbuf$,chr$(29),0)then prin usin"//fa":"Non-printable response, see strip printout."else goto prntabl5395Prin#200:blokbuf$5400Goto donetalk5405Prntabl:prin usin"//'DEVICE RESPONSE : 'fa":blokbuf$5410Donetalk:retu5415End5500Sub sav_data(var proc$)5505Putm buff proc$ usin"11(' ',fa)":actcod$,iocode$&log_unt$,str$(fn_num),str$(low),str$(up),label$,unit$,delay$,gptmout$,unlok$,lset$&kset$5510Retu5515End5600Sub extract(proc$)loca tmp$,low$,up$5605Getm buff proc$ dels" ":tmp$,actcod$,iocode$,fn_num$,low$,up$,label$,unit$,delay$,gptmout$,unlok$5610Lset$=seg$(proc$,posn(proc$," ",1,11)+1,len(proc$))5615Log_unt$=seg$(iocode$,3,2)5620Iocode$=seg$(iocode$,1,2)5625Delay=val(delay$)5630Low=val(low$)5635Up=val(up$)5640Kset$=""5645Retu5650End5700Func nxtlpnum loca lpstep,nxlpstep,lastlp5705Inte lpstep,nxlpstep,nxtlpnum5710For lpstep=1 to 105715If loop(lpstep,3)=0 then exit  to lastlp5720Next lpstep5725Lastlp:nxtlpnum=lpstep5730Retu5735End5800Sub query(qread$)5805Actcod$="MR"5810If qread$<>"DC"then goto 58305815Prin"
Do you wish to do a peak to peak?"5820Call y_nanswr5825If answer$="Y"then actcod$="PR"5830Call aqtimout5835If pos(ask$("path"),"fornxt",1)then goto 58555840Prin"
Do you wish to specify measurement limits?"5845Call y_nanswr5850If pos(answer$,"Y",1)then call limits5855Call meas_lab(qread$)5860Retu5865End5900Sub aqtimout5905Prin usin"/fa":"Enter Acquisition Timeout in seconds or press <RETURN> for default of           10 seconds : ";5910Inpu gptmout$5915If gptmout$=""then gptmout$="10"5920If asc(gptmout$)<48 or asc(gptmout$)>57 then prin"
Entry must be a number.....try again"else goto 59355925Wait 15930Goto 59055935If val(gptmout$)<=0 or val(gptmout$)>21474800. then prin"
Value entered is not legal ( must be > 0 and < 2.14748E+7) Try again"else goto 59505940Wait 15945Goto 59055950Retu5955End6000Sub limits6005Actcod$=seg$(actcod$,1,1)&"L"6010Inpu prom"

Enter lower limit. ":low6015Inpu prom"
Enter upper limit. ":up6020Retu6025End6100Sub output6105Prin"Select a device for output."6110Inpu prom"
S=Screen, P=4041 printer, "&seg$(ask$("sysdev"),1,1)&"="&sysdev$&", L=Line printer, or RETURN for none: ":outdata$6115If outdata$=""then retu6120Outdata$=seg$(outdata$,1,1)6125If pos("SsPpLlTtDd",outdata$,1)then retu else goto 61106130End6200Sub fornxt6205Enab abor6210Path$=path$&" LOOP: stimulus"6215Actcod$="FN"6220Flg1=16225Call instru(0,"
Select a stimulus instrument for measurement loop",0)6230Err=06235Rep$(path$,pos(path$,"LOOP:",1),14)=""6240Prin"

Will the loop be incrementing a stimulus parameter?"6245Call y_nanswr6250If answer$="n"then loop(fn_num,l_par)=1 else goto 62756255Prin"

Enter command(s).....e.g. MODE TRIG;MTRIG...or NEXT...DATA H0110...etc.."6260Prin"or use reference guides.
"6265Inpu kset$6270Goto 63356275Loop(fn_num,l_par)=06280Inpu prom"
Will the stimulus increment be :"&chr$(13)&"
 1. Logarithmic"&chr$(13)&" 2. Linear"&chr$(13)&"
Enter choice be number : ":answer$6285If answer$<>"1"and answer$<>"2"then inpu#700:answer$ else goto 62956290Goto 62856295If answer$="1"then loop(fn_num,llog)=1 else loop(fn_num,llog)=06300Prin"


Enter the command(s)... the last command must be the header (NO ARGUMENT)."6305Prin"  e.g. FUNC SINE;DISP FREQ;FREQ ...or VPOS... etc. "6310Inpu kset$6315If kset$=""then goto 63006320Prin"
NOTE:  The suffix entry is for non-Tektronix instrumentation that require a            suffix as part of the instrument command (IE: MZ as in FR100MZ). No             suffix is required for Tektronix devices."6325Inpu prom"
Enter a suffix to follow the numeric loop value"&chr$(13)&"or press <RETURN> for none :":suffix$6330Unit$=suffix$6335If loop(fn_num,l_par)=1 then inpu prom"

Enter number of loop iterations to be made: ":loops else goto 63656340If loops>100 then goto 63356345Start=16350Endval=loops6355Stepval=16360Goto 64306365If loop(fn_num,llog)=1 then prin"
NOTE:  Logarithmic loop starting and ending values may NOT be :"&chr$(13)&"       ZERO (0) ...or... OPPOSITE polarities (+ & -)."6370Inpu prom"

Enter starting value: ":start6375Inpu prom"
Enter ending value: ":endval6380If not(loop(fn_num,llog))then goto 64056385If start=0 or endval=0 then prin"Zero (0) values are not allowed"else goto 63956390Goto 63656395If(start*endval)<0 then prin"Loop values of opposite polarities are not allowed."else goto 64206400Goto 63656405Prin"
The minimum allowable increment value is ";((endval-(start))/(100-1));"."6410Inpu prom"
Enter loop increment value: ":stepval6415If abs(stepval)<(endval-start)/(100-1)then goto 6405 else goto 64306420Inpu prom"
Enter number of loop iterations to be made (100 is max). ":stepval6425If abs(stepval)>100 then goto 64206430Prin#102:"Testing loop limits"6435If loop(fn_num,l_par)=1 then prin#log_unit:kset$&suffix$ else prin#log_unit:kset$;str$(start)&suffix$6440Wait .56445If err then goto 62306450If loop(fn_num,l_par)=0 then prin#log_unit:kset$;str$(endval)&suffix$6455Wait .56460If err then goto 62306465Label$="LOOP STIMULUS  "6470Loop(fn_num,lstrt)=start6475Loop(fn_num,lstop)=endval6480Loop(fn_num,lstpitr)=stepval6485Inpu prom"
        Desired delay (in seconds) between stimulus device settings (if any)            and measurement device settings and/or response.                                Enter delay time ( 0 to 32000 ) or <RETURN> for none  : ":delay$6490If delay$=""then delay=0 else goto 65006495Goto 65406500If asc(delay$)>=48 and asc(delay$)<=57 then goto 65206505Prin"

Entry was not a valid number.....try again"6510Wait 26515Goto 64856520Delay=int(val(delay$)*100)/1006525If delay<=32000 then goto 6540 else prin"

Entered value too large.....try again."6530Wait 26535Goto 64856540Delay$=str$(delay)6545Call sav_data(proc$)6550Loop$(fn_num,lstim)=proc$6555Flg1=06560Path$=path$&" LOOP: meas."6565Call instru(0,"
Select a measurement instrument for measurement loop",0)6570Loop$(fn_num,lacqr)=proc$6575Retu6580End6600Sub text loca no_meas,ml,define6605Iocode$="TX"6610Init var lset$,kset$,label$,unit$6615Delay$="0"6620Unlok$="LOCKOUT"6625Gptmout$="0"6630Prin"

Add text: "6635Prin"
Specify prompting for operator interaction."6640Prin usin"lfa/5tfa/":"  -- Pressing the RETURN key allows multi-line prompting up to","550 characters (SPACE BAR generated spaces included)."6645Prin"  -- Pressing the <LINE FEED> key terminates the prompting."6650Prin"

e.g....Connect FG 5010 OUTPUT to DC 5010 CHA INPUT.<RETURN>"6655Prin"       Turn R_49 clockwise.<LINE FEED>"6660Prin"

Enter prompting:
"6665Inpu#"comm(EOM=<10>):":kset$6670If kset$=""then goto 66656675Prin 6680Prin"
Will the operator be required to enter measurement results?"6685Call y_nanswr6690If answer$="Y"then actcod$="MR"else goto no_meas6695Prin"
Is the resulting measurement to be compared to PASS/FAIL limits?"6700Call y_nanswr6705If answer$="Y"then call limits6710Goto ml6715No_meas:prin"
Will the operator be required to indicate PASS/FAIL via the keyboard?"6720Call y_nanswr6725If answer$<>"Y"then actcod$="NR"else actcod$="PF"6730If actcod$="NR"then goto define6735Ml:call meas_lab("TX")6740Define:call sav_data(proc$)6745Retu6750End6800Sub timerr6805Prin pagem$6810Prin"
Incorrect format!"6815Prin"
Enter date and time."6820Prin"Day-Month-Year Hour:Minute:Second e.g.....25-MAY-84 10:45:10"6825Inpu timdate$6830Retr6835End6900Sub timout6905Adva6910End7000Sub store7005Init var str_len7010Fn_num=nxtlpnum7015For i=1 to 1007020Str_len=str_len+len(newprcd$(i))+17025Next i7030For i=1 to 107035Str_len=str_len+len(loop$(i,lstim))+17040Str_len=str_len+len(loop$(i,lacqr))+17045Next i7050Filesize=3000+43*count9+str_len7055Tape$="TAPE(OPEN=NEW,SIZE="&str$(filesize)&",FOR=ITE)"7060Prin pagem$7065Prin"Store procedure on "&sysdev$&"."7070Call respond7075If filen$<>""then goto 70857080Retu7085Ftype$="REPLACE"7090Open#80:filen$7095If ftype$="NEW"then goto 71207100Prin"
WARNING:  File already exists!"&chr$(13)&"Do you wish to replace old file?"7105Call y_nanswr7110If answer$="n"then retu7115Rep$(tape$,11,3)="replace"7120Rep$(tape$,1,4)=filen$7125Newf=07130Open#80:tape$7140Prin#80 usin"I":count97145Prin#80 usin"I":instr$7150Prin#80 usin"I":newprcd$7155Prin#80 usin"I":loop$7160Prin#80 usin"I":loop7165Prin#80 usin"I":sequence7170Prin#80 usin"I":stp_ptr7175Clos 807180Prin"
Do you wish a list of the instruments required for this test printed to the     thermal printer?"7185Call y_nanswr7190If answer$="N"then retu7195Prin"

A list of instruments required for this test is being printed."7200Prin#200 usin" 4x9a//'FILE: '12a/":seg$(ask$("time"),1,9),filen$7205Prin#200 usin"'DEVICE'2X'PORT'2X'ADDR'":7210Prin#200 usin"13x'PRI;SEC'":7215For i=1 to count97220If seg$(instr$(i),10,2)="32"then prin#200 usin"6A3X1A4x2a":seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2)7225If seg$(instr$(i),10,2)<>"32"then prin#200 usin"6A3x1a4x2a';'2a":seg$(instr$(i),1,6),seg$(instr$(i),7,1),seg$(instr$(i),8,2),seg$(instr$(i),10,2)7230Next i7235Prin#200 usin"12L":7240Retu7245End7300Sub respond7305If newf then prin pagem$&"
Selected file ("&filen$&") not found.
"7310Prin 7315Dir"(LONG=YES)"7320Inpu prom"
Enter file name or press <RETURN> for none: ":filen$7325If filen$=""then goto 7335 else call tfilnam7330If filen$=""then goto 73157335Fsav$=filen$7340Init var newf7345Retu7350End7400Sub taperr17405Prin pagem$7410Prin"
Warning!"7415Inpu prom"
Insert "&sysdev$&" into drive and press <RETURN> : ":answer$7420Prin pagem$7425Retr7430End7500Sub file_eof7505Eof_err=17510Adva7515End7600Sub taperr27605Prin pagem$7610Prin"
Caution!"7615Prin"
Change write protect tab on tape to RECORD and press <RETURN> ."7620Inpu answer$7625Prin pagem$7630Retr7635End7700Sub taperr37705Newf=17710Ftype$="NEW"7715Adva7720End7800Sub file_is7805Oldfil=17810Adva7815End7900Sub taperr47905Prin"
"&sysdev$&" is full!"7910Inpu prom"Insert another "&sysdev$&" and press <RETURN> ":answer$7915Retr7920End8000Sub change loca deadkey,help_edt,bkmain,list_sk,deletk,alte_rk,insertk,add_k,gen_step,getstnum,chkrg,goodstep,steptyp,loop_s,gen_fn,dupe_s,bad,valid_s,dup_it,singldup,end_dupe,list_lk,lis1,gen_gsub,gsub1,gsub3,gen_rtn,seq_init,g_stptyp,altloop,cklp8005If count9=0 then call re_start8010Disa abor8015On abor then call chgabort8020B=count8025Ebranch=08030Prin pagem$8035Edit_lab:disa abor8040Init var keylab1$,keylab2$,keylab3$,keylab4$8045Cnt$=""8050Khead$="EDIT FUNCTIONS"8055Data"LIST","DUP  ","REPLA","INSRT","NEW  ","ALTER","HELP","MAIN","LIST","DELET"8060Data"STEPS","STEP ","STEP ","STEP","STEP ","STEP ","    ","MENU","HCOPY","STEPS"8065Rest 80558070Read keylab3$,keylab1$(1),keylab1$(2),keylab4$,keylab2$(1),keylab2$(2)8075Call gkeydisp8080Prin pagem$8085Prin"Press a function key"8090Keyflag=08095Wait 8100If keyflag=0 then goto 80958105Delay$="0"8110Gosu keyflag of list_sk,dupe_s,repl_ck,insertk,add_k,alte_rk,help_edt,bkmain,list_lk,deletk,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey8115Key$="N/A"8120If mbranch then enab abor else goto 81308125Retu8130If keyflag=0 then goto 80808135Goto edit_lab8140Help_edt:cnt$=""8145Path$=" HELP for EDIT MENU"8150Key$="F7"8155Call path_lab8160Helpfil$="HEDIT"8165Init var path$8170Call prinhelp8175Keyflag=08180Retu8185Bkmain:mbranch=18190Retu8195List_sk:path$=" LIST Steps"8200Key$="F1"8205Call path_lab8210Strem$="comm0:"8215Gosu lis18220Call commrbyt8225Retu8230Deletk:path$=" EDIT: DELETE Steps"8235Key$="F2"8240Call path_lab8245Prin"Enter step(s) to DELETE."8250Call num_in8255If count1=0 then goto 82758260For count=count1 to count28265If stp_ptr(count)<>0 then call del_ete(count)else prin"
No Step ";count;" to DELETE !"8270Next count8275Keyflag=08280Retu8285Alte_rk:path$=" EDIT: ALTER Step"8290Key$="F6"8295Call path_lab8300Prin pagem$8305Inpu prom"
Enter step # to ALTER (1 to 100) or press <RETURN> for none : ":cnt$8310If cnt$=""then retu else call chkrng(1,100,cnt$)8315If cnt$=""then goto 8305 else count=val(cnt$)8320If stp_ptr(count)then goto alt_gd else prin"
Step "&cnt$&" non-existent."8325Goto 83058330Alt_gd:proc$=newprcd$(stp_ptr(count))8335Call extract(proc$)8340If not(sequence(stp_ptr(count),ret_rn))then goto cklp else prin usin"/fa/":"illegal ALTER of a GOSUB or RETURN step type."8345Goto 83858350Cklp:if actcod$="FN"then goto altloop8355Alt1:prin usin"/fa6(20tfa/)s":"You may ALTER","1 Step label","2 Unit label","3 Lower limit","4 Upper limit","5 Delay time","6 GPIB time out"8360Prin usin"3(20tfa/)":"7 Lockout/Local","8 Branching","9 RETURN to EDIT menu"8365Inpu prom"
Enter ALTER # : ":altn8370Goto altn of stlab,unlab,lolim,uplim,alt_dly,alt_gp,alt_lok,br_nch8375Call sav_data(proc$)8380Newprcd$(stp_ptr(count))=proc$8385Retu8390Stlab:prin"Current Step label is : ";label$8395Inpu prom"Enter new label : ":lab$8400Label$=lab$8405Goto cklp8410Unlab:prin"Current Unit label is : ";unit$8415Inpu prom"Enter new label : ":unit$8420Goto alt18425Lolim:if not(pos(actcod$,"L",1))then goto nolim8430Prin"Current lower limit is : ";low8435Inpu prom"Enter new lower limit : ":low8440Goto alt18445Uplim:if not(pos(actcod$,"L",1))then goto nolim8450Prin"Current upper limit is : ";up8455Inpu prom"Enter new upper limit : ":up8460Goto alt18465Nolim:prin"No limits given."8470Goto alt18475Alt_dly:prin"Current delay time is ";delay$8480Inpu prom"Enter new delay value ":delay8485Delay$=str$(abs(delay))8490Goto alt18495Alt_gp:prin"Current Acquisition timeout value is ";gptmout$8500Inpu prom"Enter new value: ":gptmout$8505If gptmout$=""then gptmout$="10"8510If asc(gptmout$)<48 or asc(gptmout$)>57 then prin"
Entry must be a number.....try again"else goto 85258515Wait 18520Goto 85008525If val(gptmout$)<=0 or val(gptmout$)>2.14748E+7 then prin"
Value entered is not legal ( must be > 0 and < 2.14748E+7) Try again"else goto alt18530Wait 18535Goto 85008540Alt_lok:prin"The front panel is in ";unlok$8545Prin"Should it be changed?"8550Call y_nanswr8555If answer$="n"then goto alt18560If unlok$="LOCAL"then unlok$="LOCKOUT"else unlok$="LOCAL"8565Goto alt18570Altloop:prin usin"/fa6(20tfa/)s":"You may ALTER","1 Step label","2 RETURN to EDIT menu"8575Inpu prom"
Enter ALTER # : ":altn8580Goto altn of stlab8585Call sav_data(proc$)8590Newprcd$(stp_ptr(count))=proc$8595Retu8600Br_nch:call sequencr(count)8605Goto alt18610Insertk:path$=" EDIT: INSERT Step"8615Key$="F4"8620Call path_lab8625Call xpand(cnt$)8630If cnt$=""then retu8635Gosu g_stptyp8640Retu8645Deadkey:keyflag=08650Retu8655Add_k:path$=" EDIT: ADD New Step"8660Key$="F5"8665Call path_lab8670Prin pagem$8675Init var fn_num8680Gosu getstnum8685If cnt$=""or pos(cnt$,"ex",1)then retu8690Gosu g_stptyp8695Retu8700Gen_step:stp_ptr(count)=nxseqndx8705Proc$=null$8710Call instru(1,"
Press a Function Key",1)8715Call sequencr(count)8720Newprcd$(stp_ptr(count))=proc$8725Retu8730Getstnum:call clr_bufr8735Inpu prom"
Enter step # to ADD (1 to 100), press <RETURN> for AUTO NUMBER or               Enter <exit> to return to edit menu:  ":cnt$8740If pos(cnt$,"ex",1)then retu8745If cnt$=""then cnt$=str$(count+1)else goto chkrg8750Prin"
AUTO STEP ";cnt$8755Chkrg:call chkrng(1,100,cnt$)8760If cnt$<>""then goto goodstep else prin"
STEP # OUT OF RANGE"8765Wait 38770Retu8775Goodstep:count=val(cnt$)8780If stp_ptr(count)=0 then retu8785Cnt$=""8790Prin"
STEP ALREADY EXISTS."8795Goto getstnum8800Steptyp:prin usin"/fa4(20tfa/)/fa1xs":"You may produce","S SINGLE Step","L LOOP step","G GOSUB step","R RETURN step","enter S, L, G, or R :"8805Inpu styp$8810If not(pos("SLGR",styp$,1))or styp$=""then goto steptyp8815Retu8820Loop_s:fn_num=nxtlpnum8825If fn_num>10 then prin"
ALL LOOP STEPS USED - use other EDIT keys."else goto gen_fn8830Retu8835Gen_fn:call fornxt8840Actcod$="FN"8845Iocode$="FN"8850Init var low,up8855Unlok$="LOCKOUT"8860Call sav_data(proc$)8865Stp_ptr(count)=nxseqndx8870Newprcd$(stp_ptr(count))=proc$8875Call sequencr(count)8880Retu8885Dupe_s:path$=" EDIT: DUPLICATE Step"8890Key$="F10"8895Call path_lab8900Inpu prom"
Enter step # to DUPLICATE (1 to 100)  or  press <RETURN> for none : ":cnt$8905If cnt$=""then retu8910Call chkrng(1,100,cnt$)8915Bad:if cnt$=""then prin"
INVALID Step #"else goto valid_s8920Goto 89008925Valid_s:o_count=val(cnt$)8930If stp_ptr(o_count)then goto dup_it8935Prin"
STEP ";o_count;"  non-existent."8940Goto 89008945Dup_it:if sequence(stp_ptr(o_count),ret_rn)=0 then goto singldup else prin usin"/fa/":"Illegal DUPE of a GOSUB or RETURN Step Type."8950Goto end_dupe8955Singldup:gosu getstnum8960If cnt$=""or pos(cnt$,"ex",1)then retu8965Stp_ptr(count)=nxseqndx8970Newprcd$(stp_ptr(count))=newprcd$(stp_ptr(o_count))8975Call sequencr(count)8980Proc$=newprcd$(stp_ptr(o_count))8985Call extract(proc$)8990Fn_num=val(fn_num$)8995If actcod$<>"FN"then goto end_dupe else proc$=loop$(fn_num,lstim)9000Call extract(proc$)9005Low=low+19010Call sav_data(proc$)9015Loop$(fn_num,lstim)=proc$9020End_dupe:keyflag=09025Prin"Duplication of step ";o_count;" to step ";count;" completed."9030Retu9035List_lk:path$=" HARDCOPY LIST Steps"9040Key$="S1"9045Call path_lab9050Call x_printr9055Strem$=com$9060Gosu lis19065Keyflag=09070Retu9075Lis1:prin"Enter step(s) to LIST."9080Call num_in9085If count1<>0 then call list_s(strem$,count1,count2)9090Retu9095Gen_gsub:stp_ptr(count)=nxseqndx9100Gosu seq_init9105Prin"
Enter step # to GOSUB (1 to 100) : ";9110Inpu cnt$9115Call chkrng(1,100,cnt$)9120If cnt$<>""then goto gsub1 else prin"
STEP # OUT OF RANGE"9125Goto gen_gsub9130Gsub1:sequence(stp_ptr(count),brchstrt)=val(cnt$)9135Gsub3:inpu prom"
Enter step to branch to or press <RETURN> for next step  : ":cnt$9140If cnt$=""then cnt$="0"9145Call chkrng(0,100,cnt$)9150If cnt$=""then goto gsub39155Sequence(stp_ptr(count),brchnxt)=val(cnt$)9160Newprcd$(stp_ptr(count))=null$&"gosub"9165Sequence(stp_ptr(count),ret_rn)=19170Retu9175Gen_rtn:stp_ptr(count)=nxseqndx9180Gosu seq_init9185Sequence(stp_ptr(count),ret_rn)=19190Sequence(stp_ptr(count),brchnxt)=09195Newprcd$(stp_ptr(count))=null$&"return"9200Retu9205Seq_init:sequence(stp_ptr(count),brchnxt)=count+19210Sequence(stp_ptr(count),brchfail)=09215Sequence(stp_ptr(count),iterates)=09220Sequence(stp_ptr(count),brchstrt)=09225Sequence(stp_ptr(count),lg_lin)=09230Sequence(stp_ptr(count),incr)=09235Sequence(stp_ptr(count),ret_rn)=09240Retu9245Repl_ck:path$=" EDIT: REPLACE Step"9250Key$="F3"9255Call path_lab9260Repstp:inpu prom"
Enter the step # to REPLACE (1 to 100) or press <RETURN> for none : ":cnt$9265If cnt$=""then retu9270Call chkrng(1,100,cnt$)9275If cnt$=""then goto repstp else count=val(cnt$)9280If stp_ptr(count)=0 then prin"
No step to replace"else goto replacit9285Goto repstp9290Replacit:call del_ete(count)9295Gosu g_stptyp9300Retu9305G_stptyp:enab abor9310Gosu steptyp9315Gosu pos("SLGR",styp$,1)of gen_step,loop_s,gen_gsub,gen_rtn9320Disa abor9325Retu9330End9400Sub chgabort9405Prin usin"//fa2X3D"#102:"ABORT STEP",count9410Prin usin"//FA2X3D":"ABORT STEP",count9415Call del_ete(count)9420Flg1=09425Bran edit_lab9430End9500Sub stakpush(var ret_step)9505Substp=sequence(stp_ptr(ret_step),brchstrt)9510If sequence(stp_ptr(ret_step),brchnxt)=0 then ret_step=ret_step+1 else ret_step=sequence(stp_ptr(ret_step),brchnxt)9515If stak_pt=20 then retu9520Stak_pt=stak_pt+19525Ret_stak(stak_pt)=ret_step9530Ret_step=substp9535Retu9540End9600Sub stakpop(var ret_step)9605If stak_pt=0 then ret_step=ret_step+1 else ret_step=ret_stak(stak_pt)9610If stak_pt>0 then stak_pt=stak_pt-19615Retu9620End9700Sub num_in loca first,second,again,count$9705Again:inpu prom"  Enter one or two numbers (1,3 or 1 3) or press <RETURN> for none ":count$9710If count$<>""then goto first else count1=09715Count2=09720Retu9725First:count1=val(count$)9730If ask("chpos")<len(count$)then goto second else cnt1$=str$(count1)9735Call chkrng(1,100,cnt1$)9740If cnt1$=""then goto again else count2=count19745Retu9750Second:count2=valc(count$,ask("chpos"))9755Cnt1$=str$(count1)9760Cnt2$=str$(count2)9765Call chkrng(1,100,cnt1$)9770If cnt1$=""then goto again else call chkrng(count1,100,cnt2$)9775If cnt2$=""then goto again else retu9780End9800Sub chkrng(bottom,top var num$)loca num9805Inte num9810Num$=numin$(num$)9815If num$=""then retu9820Num=val(num$)9825If num<bottom or num>top then num$=""9830Retu9835End9900Func numin$(num$)loca nogo,num,numerr9905Inte num9910Numerr=09915On erro(101)then gosu nogo9920On erro(80)then gosu nogo9925On erro(89)then gosu nogo9930Num=val(num$)9935If numerr=0 then numin$=str$(num)else numin$=""9940Off erro(101)9945Retu9950Nogo:numerr=19955Adva9960End10000Sub cmprss(begstep)loca i,ii,renumseq10005Inte i,ii10010Xrfrnc=010015Newrfrnc=010020Ii=010025For i=1 to 10010030Ii=ii+110035If stp_ptr(i)=0 and i>=begstep then ii=ii+110040If ii>100 then exit  to renumseq10045Newrfrnc(i)=stp_ptr(ii)10050Xrfrnc(ii)=i10055Next i10060Renumseq:call seq_ren10065Stp_ptr=newrfrnc10070Retu10075End10100Sub seq_ren loca n,i,seq1,seq2,seq3,nexti,noprin10105Inte n,i,b10110Prin"
Do you wish a record of steps renumbered listed to the thermal printer? "10115Call y_nanswr10120If answer$="n"then noprin=1 else noprin=010125For i=1 to 10010130N=newrfrnc(i)10135B=010140If n=0 then goto seq310145If sequence(n,brchnxt)<1 then goto seq110150If sequence(n,brchnxt)=xrfrnc(sequence(n,brchnxt))then goto seq1 else sequence(n,brchnxt)=xrfrnc(sequence(n,brchnxt))10155B=110160Seq1:if sequence(n,brchfail)<1 then goto seq210165If sequence(n,brchfail)=xrfrnc(sequence(n,brchfail))then goto seq2 else sequence(n,brchfail)=xrfrnc(sequence(n,brchfail))10170B=110175Seq2:if sequence(n,brchstrt)<1 then goto seq310180If sequence(n,brchstrt)=xrfrnc(sequence(n,brchstrt))then goto seq3 else sequence(n,brchstrt)=xrfrnc(sequence(n,brchstrt))10185B=110190Seq3:if noprin then goto nexti10195If b then prin#"prin:":"REN step ";i;" Branch"10200If i<xrfrnc(i)then prin#"prin:":"REN Branch step ";i;"    to  ";xrfrnc(i)10205Nexti:next i10210Retu10215End10300Sub del_ete(count)loca delproc,dexit10305If stp_ptr(count)=0 then goto dexit10310Proctmp$=newprcd$(stp_ptr(count))10315Call extract(proctmp$)10320Fn_num=val(fn_num$)10325If actcod$<>"FN"then goto delproc10330Proctmp$=loop$(fn_num,lstim)10335Call extract(proctmp$)10340If low=0 then goto delloop else low=low-110345Call sav_data(proctmp$)10350Loop$(fn_num,lstim)=proctmp$10355Goto delproc10360Delloop:loop$(fn_num,lstim)=null$10365Loop$(fn_num,lacqr)=null$10370Loop(fn_num,lstrt)=010375Loop(fn_num,lstop)=010380Loop(fn_num,lstpitr)=010385Loop(fn_num,l_par)=010390Loop(fn_num,llog)=010395Delproc:newprcd$(stp_ptr(count))=null$10400Sequence(stp_ptr(count),brchnxt)=010405Sequence(stp_ptr(count),brchfail)=010410Sequence(stp_ptr(count),iterates)=010415Sequence(stp_ptr(count),brchstrt)=010420Sequence(stp_ptr(count),incr)=010425Sequence(stp_ptr(count),ret_rn)=010430Sequence(stp_ptr(count),lg_lin)=010435Stp_ptr(count)=010440Dexit:retu10445End10500Sub xpand(var cnt$)loca stpmx,i,skip,renumseq,insrtstp,xpandit,xexit10505Inte stpmx,skip,i10510Stpmx=maxstep(1)10515If stpmx<100 then goto insrtstp else prin"
NO ROOM FOR INSERT"10520Cnt$=""10525Goto xexit10530Insrtstp:inpu prom"
Enter step # to INSERT before (1 to 100) : ":cnt$10535Call chkrng(1,100,cnt$)10540If cnt$=""then prin"
INVALID STEP #"10545If cnt$=""then goto xexit else count=val(cnt$)10550If stp_ptr(count)=0 then goto xexit10555Stpmx=maxstep(count)10560If stpmx<101-count then goto xpandit else prin"
NO INSERT POSSIBLE after step ";cnt$;" , use DELETE key to make space."10565Cnt$=""10570Goto xexit10575Xpandit:xrfrnc=010580Newrfrnc=010585Skip=010590For i=1 to 10010595If i=count then skip=110600If skip+i>100 then exit  to renumseq10605Newrfrnc(i+skip)=stp_ptr(i)10610Xrfrnc(i)=i+skip10615If stp_ptr(i)=0 and skip=1 then skip=0 else goto 1062510620Xrfrnc(i)=i10625Next i10630Renumseq:call seq_ren10635Stp_ptr=newrfrnc10640Xexit:enab abor10645Retu10650End10700Func nxseqndx loca nxndx,ndx10705Inte ndx,nxseqndx10710For ndx=1 to 10010715If newprcd$(ndx)=null$ then exit  to nxndx10720Next ndx10725Nxndx:nxseqndx=ndx10730Retu10735End10800Func fitstep(start)loca i10805Inte i,maxstep,fitstep10810For i=start to 10010815If stp_ptr(i)then maxstep=maxstep+110820Next i10825If maxstep<101-start then fitstep=1 else fitstep=010830Retu10835End10900Sub sequencr(countr)loca iter,loopstrt,brchout,looper,brancher,failbrch10905Sequence(stp_ptr(countr),brchnxt)=010910Sequence(stp_ptr(countr),brchfail)=010915Sequence(stp_ptr(countr),iterates)=010920Sequence(stp_ptr(countr),brchstrt)=010925Prin usin"fa=72a":pagem$,"Branching menu"10930Prin usin"/fa2(20tfa/)s":"You may CREATE","1 Multi-step loop ( repeat step(s) 'n' times )","2 Unconditional branch ( branch out of sequence )"10935If pos(actcod$,"L",1)or actcod$="PF"then prin usin"20tfa":"3 Conditional branch ( branch on failed measurement )"10940Inpu prom"
Enter a number or press <RETURN> to continue :":answer$10945If answer$=""then retu10950If asc(answer$)<49 or asc(answer$)>51 then goto 1094010955Gosu val(answer$)of looper,brchout,failbrch10960Goto 1092510965Looper:inpu prom"
How many iterations to complete this loop? (1 to 32000) ":bstep$10970Call chkrng(1,32000,bstep$)10975If bstep$=""then goto looper else sequence(stp_ptr(countr),iterates)=val(bstep$)10980Loopstrt:inpu prom"
What is the beginning step # of this multi-step loop? (1 to 100) ":bstep$10985Call chkrng(1,100,bstep$)10990If bstep$=""then goto loopstrt10995If val(bstep$)>countr then goto loopstrt else sequence(stp_ptr(countr),brchstrt)=val(bstep$)11000Retu11005Brchout:inpu prom"
Enter step number (1 to 100) to branch to after this step or press <RETURN> for next step. ":bstep$11010If bstep$=""then bstep$="0"11015Call chkrng(0,100,bstep$)11020If bstep$=""and countr+1>100 then prin"
Procedure terminates with this step."11025If bstep$=""and countr+1<=100 then goto brchout else sequence(stp_ptr(countr),brchnxt)=val(bstep$)11030Retu11035Failbrch:if pos(actcod$,"L",1)>0 or actcod$="PF"then inpu prom"
What step # should be branched to if this measurement fails limits?  Enter step number or press <RETURN> for next step : ":bstep$ else retu11040If bstep$=""then bstep$="0"11045Call chkrng(0,100,bstep$)11050If bstep$=""then goto failbrch else sequence(stp_ptr(countr),brchfail)=val(bstep$)11055Retu11060End11100Sub list_s(iostrem$,begstep,endstp)loca nxi,list_stp,list_fn,list_typ,whos_it,list_act,loop_par,list_seq,loopseq,out_frmt,nxoutchr,go_ret11105Inte j,i11110Init var j,i11115Open#500:iostrem$11120Prin pagem$11125For i=begstep to endstp11130If stp_ptr(i)=0 then goto nxi11135J=stp_ptr(i)11140Proctmp$=newprcd$(j)11145Call extract(proctmp$)11150Lab$=label$11155Prin#500 usin"'# '3DS":i11160If iocode$="FN"then gosu list_fn else gosu list_stp11165Prin#500 usin"37('. ')/":11170Nxi:next i11175If j then goto 1118511180If begstep=endstp then prin"No STEP ";begstep;" to list"else prin"No STEPS to list in the range of ";begstep;" to ";endstp11185If pos(iostrem$,"comm1",1)then prin#500:chr$(12)11190Retu11195List_stp:gosu list_typ11200Gosu list_act11205If iocode$="TX"then prin#500:lset$ else gosu out_frmt11210Gosu list_seq11215Retu11220List_fn:fn_num=val(fn_num$)11225Proc$=loop$(fn_num,lstim)11230Call extract(proc$)11235Gosu list_typ11240Gosu list_act11245Gosu loop_par11250Prin#500 usin"/=80A/":"-   -   -   LOOP ACQUISITION   -   -   -"11255Proc$=loop$(fn_num,lacqr)11260Call extract(proc$)11265Label$=lab$11270Gosu list_typ11275Gosu list_act11280Gosu out_frmt11285Gosu list_seq11290Retu11295List_typ:ty$=iocode$11300If ty$=""then retu11305Prin#500 usin"10t15A5x/":label$11310If ty$="PS"then prin#500:"POWER SUPPLY -- ";11315If ty$="DM"then prin#500:"MULTI-METER -- ";11320If ty$="DC"then prin#500:"COUNTER -- ";11325If ty$="MI"then prin#500:"MULTI INTERFACE -- ";11330If ty$="SI"then prin#500:"SIGNAL SCANNER -- ";11335If ty$="FG"then prin#500:"FUNCTION GENERATOR -- ";11340If ty$="CG"then prin#500:"SCOPE CAL GENERATOR -- ";11345If ty$="7D"then prin#500:"DIGITIZER -- ";11350If ty$="AA"then prin#500:"DISTORTION ANALYZER -- ";11355If ty$="SG"then prin#500:"SIGNAL GENERATOR -- ";11360If ty$="24"then prin#500:"PORTABLE OSCILLOSCOPE -- ";11365If ty$="XX"then prin#500:"GPIB DEVICE --";11370If ty$="TX"then prin#500:"OPERATOR PROMPT -- ";else goto whos_it11375Retu11380Whos_it:v=val(log_unt$)11385If seg$(instr$(v),10,2)<>"32"then prin#500 usin"'ID '6a'  PORT '1a'  ADDRESS '2a'  SECONDARY '2a/":seg$(instr$(v),1,6),seg$(instr$(v),7,1),seg$(instr$(v),8,2),seg$(instr$(v),10,2)else goto 1139511390Retu11395Prin#500 usin"'ID '6a'  PORT '1a'  ADDRESS '2a/":seg$(instr$(v),1,6),seg$(instr$(v),7,1),seg$(instr$(v),8,2)11400Retu11405List_act:if actcod$=""then retu11410If actcod$="DW"then prin#500:"ACQUIRE WAVEFORM ON FILE"11415If actcod$="BA"then prin#500:"ACQUIRE DATA BLOCK ON FILE"11420If actcod$="PR"then prin#500:"P-P VOLTS MEASUREMENT"11425If actcod$="MR"and ty$<>"TX"then prin#500:"MEASUREMENT"11430If actcod$="NR"then prin#500:"DEVICE SETUP - NO MEASUREMENT"11435If actcod$="PL"then prin#500 usin"fa/fak5XfakS":"P-P VOLTS with LIMITS:","LOW = ",low,"HIGH = ",up11440If actcod$="ML"and ty$<>"TX"then prin#500 usin"fa2xfak5xfaks":"MEASUREMENT LIMITS:","LOW = ",low,"HIGH = ",up11445If actcod$="ML"and ty$="TX"then prin#500 usin"fa/fak5xfak":"OPERATOR ENTERS DATA with LIMITS:","LOW = ",low,"HIGH = ",up11450If actcod$="MR"and ty$="TX"then prin#500:"OPERATOR ENTERS DATA"11455If actcod$="PF"then prin#500:"OPERATOR ENTERS  PASS/FAIL"11460If not(pos("NR PF",actcod$,1))and ty$<>"TX"then prin#500 usin"/'ACQUISITION TIMEOUT: '2X10A":gptmout$11465If not(actcod$="NR"or ty$="TX")then prin#500 usin"/'MEASUREMENT UNITS: '20t5as":unit$11470Prin#500 usin"30t'TIME DELAY: '42t10a60t'PANEL MODE: '7a/":delay$,unlok$11475Retu11480Loop_par:prin#500 usin"/'PARAMETER: ""'FA'""'5X'UNITS: ""'FA'""'/":lset$,unit$11485Prin#500:"INCREMENT : ";11490If loop(fn_num,l_par)=0 and loop(fn_num,llog)=0 then prin#500:loop(fn_num,lstrt);" to ";loop(fn_num,lstop);" in increments of ";loop(fn_num,lstpitr)11495If loop(fn_num,llog)=1 then prin#500:loop(fn_num,lstrt);" to ";loop(fn_num,lstop);" for ";loop(fn_num,lstpitr);" iterations."11500If loop(fn_num,l_par)=1 then prin#500:int(loop(fn_num,lstop));" iterations."11505Retu11510List_seq:prin#500 usin"/":"
BRANCH Sequences"11515If sequence(j,ret_rn)then goto go_ret11520If sequence(j,iterates)then goto loopseq11525Shgl:prin#500:"Branch to : ";11530If sequence(j,brchnxt)=0 then prin#500:"Next Step"else prin#500:sequence(j,brchnxt)11535If not(pos(actcod$,"L",1)>0 or actcod$="PF")then retu11540Prin#500:"FAIL Branch to : ";11545If sequence(j,brchfail)=0 then prin#500:"Next Step"else prin#500:sequence(j,brchfail)11550Retu11555Loopseq:prin#500:"Loop to : ";sequence(j,brchstrt);11560Prin#500:"   for ";sequence(j,iterates);" iterations"11565Gosu shgl11570Retu11575Go_ret:if sequence(j,brchstrt)then prin#500:"GOSUB to : ";sequence(j,brchstrt)else prin#500:"RETURN"11580If sequence(j,brchstrt)then gosu shgl11585Retu11590Out_frmt:if actcod$=""or len(lset$)=0 then retu11595If actcod$<>"DW"and actcod$<>"BA"then prin#500:"INSTRUMENT SETTINGS:"else prin#500:"ACQUISITION FILE PARAMETERS:"11600If pos(lset$,"%",1)=0 and pos(lset$,"@",1)=0 and pos(iostrem$,"COMM0",1)then prin#500:lset$ else goto 1161011605Retu11610Line$=""11615Linelen=011620For outchr=1 to len(lset$)11625C$=seg$(lset$,outchr,1)11630If asc(c$)<32 or asc(c$)>126 then c$="_"11635Linelen=linelen+111640Line$=line$&c$11645If linelen>78 or outchr=len(lset$)then prin#500:line$ else goto nxoutchr11650Linelen=011655Line$=""11660Nxoutchr:next outchr11665Prin#500:11670Retu11675End11700Func maxstep(count)loca stp11705Maxstep=011710For stp=count to 10011715If stp_ptr(stp)<>0 then maxstep=maxstep+111720Next stp11725Retu11730End11800Sub infile loca respd,verr,brnchout,ins_list,inptdata,missing,wrngdata,linkfile,endlink,tek$,lu$11805Init var mis_ins,mis,newf,gport0,gport1,inslab1$,inslab2$,inslab3$,inslab4$11810I$=",EOU=<0>,EOA=<0>,EOH=<0>,EOM=<10>"11820Dim lu$ to 2,tek$ to 311825On erro(812)then gosu missing11830On erro(101)then gosu verr11835On erro(1000)then gosu brnchout11840Prin#102:"check configuration"11845Respd:if filelnk$=chr$(13)then call respond else gosu linkfile11850Newf=011855If filen$=""then retu11860Open#80:filen$&"(FOR=ITE)"11865If newf=1 then goto respd11870If type(80)=5 then inpu#80 usin"I":count9 else goto wrngdata11875For i=1 to count911880If type(80)=4 then inpu#80 usin"I":lab$ else goto wrngdata11885Instr$(val(seg$(lab$,12,2)))=lab$11890If len(lab$)=13 then call ckid11895Next i11900For i=count9+1 to 2811905If type(80)=4 then inpu#80 usin"I":instr$(i)else goto wrngdata11910Next i11915If filelnk$<>chr$(13)then goto 1196511920Ins_list:prin pagem$11925Init var mis,mis_ins11930Prin"

The following instruments must be at the listed port and address!"11935Prin usin"2l20T'DEVICE'5X'PORT'5X'ADDRESS'5x'SECONDARY'//":11940For i=1 to count911945Getm buff instr$(i)usin"6a1a2a2a":dev$,prt$,pri$,sec$11950If sec$<>"32"then prin usin"20T6A6X1A10X2A8x2a":dev$,prt$,pri$,sec$ else prin usin"20t6a6x1a10x2a":dev$,prt$,pri$11955Next i11960Call commrbyt11965For i=1 to count911970Getm buff instr$(i)usin"6a1a2a2a2a3a":dev$,prt$,pri$,sec$,lu$,tek$11975Gpib$="GPIB"&prt$&"(PRI="&pri$&",SEC="&sec$&",TIM=10"11980If not(pos(tek$,"TEK",1))then open#i:gpib$&i$&"):"else open#i:gpib$&",EOM=<0>):"11985If prt$="0"then gport0=1 else gport1=111990If pos(tek$,"TEK",1)then inpu#i prom"ID?":id$ else prin#i:11995Wait .512000If pos(id$,"CG551AP",1)then id$="CG5001"12005Wait .0112010If not((pos(dev$,"XX",1)=0 and pos(id$,trim(dev$),1)=0))and not(mis_ins)then goto 1202512015If sec$="32"then prin"
          The "&dev$&" at address "&pri$&" on PORT "&prt$&" is missing"else prin"
          The "&dev$&" at address "&pri$&","&sec$&" on PORT "&prt$&" is missing"12020Mis=mis+112025Mis_ins=012030Next i12035If mis then inpu prom"
Add the missing instruments and enter ""CONT"" or press <RETURN> to abort the test: ":ret$ else prin"
     All instruments present and accounted for . . . "12040If mis and ret$="CONT"then goto ins_list12045If mis=0 then goto inptdata12050Init var count9,inslab1$,inslab2$,inslab3$,inslab4$12055Retu12060Inptdata:prin usin"2L=40A2X=12A ":"LOADING PROCEDURE FROM "&sysdev$&" FILE ",fsav$12065If type(80)=4 then inpu#80 usin"I":newprcd$ else goto wrngdata12070If type(80)=4 then inpu#80 usin"I":loop$ else goto wrngdata12075If type(80)=6 then inpu#80 usin"I":loop else goto wrngdata12080If type(80)=5 then inpu#80 usin"I":sequence else goto wrngdata12085If type(80)=5 then inpu#80 usin"I":stp_ptr else goto wrngdata12090If type(80)<>1 then goto wrngdata12095Clos 8012100Call setins12105Prin pagem$12110Retu12115Missing:mis_ins=112120Adva12125Wrngdata:prin usin"lfa/fa//":"Warning!","Selected data file was not generated with this software!"12130Trap12135Brnchout:prin#"frtp:":"WARNING:"12140Wait 312145If pos(ask$("path"),"r_main",1)then bran run_lab else bran main_lab12150Linkfile:cr0=pos(filelnk$,chr$(13),cr1)12155Cr1=pos(filelnk$,chr$(13),cr0+1)12160If cr1=0 then goto endlink12165Filen$=seg$(filelnk$,cr0+1,cr1-cr0-1)12170Fsav$=filen$12175Retu12180Verr:prin usin"lfa/fa//":"Warning!","Selected data file was not generated with this software!"12185Goto brnchout12190Endlink:filen$=""12195Retu12200End12300Sub err_88812305Prin#102:bell$;"INVALID BAUD VALUE"12310Wait 212315Prin"%!1[2A%!0"12320Bran set_baud12325End12400Sub abormenu12405Set cons"FRTP:"12410Prin#102:bell$;"HANDLING AN ABORT"12415Bran clr_mem12420End12500Sub gkeydisp loca ll1$12505If termid=4105 then ll1$="LLA4"else ll1$="LLA5"12510If verflag then comp 12515Prin"%!0";12520Prin bmap$;12525Prin bell$&ll1$&"LBC1RW `` @8so?_RV `` @7o"&chr$(127)&"?_";12530If pos(ask$("path"),"pfkey",1)then goto 1254012535Prin page$12540Prin"MC0MT5KA0"&pagew$&"     
"&khead$12545Imag 7X4(7A)7X4(7A)12550Imag 7X4(7A)7X2(7A)52T12A12A12555Prin"LF6n @"12560Prin usin 12545:keylab1$12565Prin usin 12545:keylab2$12570Prin"LF3v @MT3ML1LT:"12575Prin usin"8X'F1'5X'F2'5X'F3'5X'F4'12X'F5'5X'F6'5X'F7'5X'F8'":12585Prin"LF3l""ULG4l""ULG4l$[LG3l$[LG3l""U"12590Prin"LF3l%TLG4l%TLG4l'ULG3l'ULG3l%T"12595Prin"LF3l(NLG4l(NLG4l*OLG3l*OLG3l(N"12600Prin"LF3l+HLG4l+HLG4l-NLG3l-NLG3l+H"12605Prin"LF3l0RLG4l0RLG4l2XLG3l2XLG3l0R"12610Prin"LF3l3QLG4l3QLG4l5RLG3l5RLG3l3Q"12615Prin"LF3l6KLG4l6KLG4l8QLG3l8QLG3l6K"12620Prin"LF3l9JLG4l9JLG4l;KLG3l;KLG3l9J"12625Prin"MT5LF3f @"12630Imag 6x7a1x3(7a)7x4(7a)12635If pos(ask$("path"),"instru",1)then prin usin 12630:keylab3$ else goto 1265012640If pos(ask$("path"),"instru",1)then prin usin 12630:keylab4$ else goto 1265012645Goto 1266012650If keylab3$(7)="MT3PASS "then prin usin 12550:keylab3$ else prin usin 12545:keylab3$12655If keylab3$(7)="MT3PASS "then prin usin 12550:keylab4$ else prin usin 12545:keylab4$12660Prin"MPH8LP/j @1LG0| @LG0|?_LG/j?_LEKA1"12665Retu12670End12700Sub map_key12705Prin"KDH82@6C9KDH92@6C0KDH:2@4C1KDH;2@4C2KDH<2@4C3KDH=2@4C4KDH>2@4C5KDH?2@4C6";12710Prin"KDH02@6C1KDH12@6C2KDH22@6C3KDH32@6C4KDH42@6C5KDH52@6C6KDH62@6C7KDH72@6C8";12715Prin"KDG-24C0";12720Retu12725End12800Sub tm_conf loca sel_port,next_pri,all_done,check_id,devlist0,tek_inst,new_id,tm_inst,err_811,err_812,err_818,getout,sec,second12805Imag <6a1a>2a>2a>2a>3a12810Prin usin"2L=72A/":"Make sure all GPIB connections have been made"12815Prin usin"=72A/":"and that the power has been turned on."12820Inpu prom"                      Press <RETURN> when ready ":ret$12825Prin"
Do you wish to check secondary addresses during the GPIB configuration"&chr$(13)&"process?"12830Call y_nanswr12835If answer$="y"then nosec=0 else nosec=112840Prin pagem$12845Prin"KA1LV1"&ll$12850Ret2prt$=ask$("select")12855Inte stb,pri,prim,sec,bus,try,err818,port,count9,err812,cntr12860Init var try,stb,pri,instr$,port,id$,bus,count9,gport0,gport1,inslab1$,inslab2$,inslab3$,inslab4$12865On erro(811)then gosu err_81112870On erro(812)then gosu err_81212875On erro(818)then gosu err_81812880Sel_port:gpib$="GPIB"&str$(port)12885Sele gpib$&"(SPE=.1,TIME=.2):"12890Set driv gpib$&"(ma=30):"12895Init var bus,try12900Poll stb,pri,sec;012905Prin bell$12910Prin#102:"POLLING "&gpib$12915Bus=112920Prin usin"L=75A ":"* * * POLLING PORT "&gpib$&" * * *"12925Prin usin"5t65('-')/ 25t'DEVICE'22x'ADDRESS'":12930Prin usin"26t'""ID""'18x'PRIMARY'3x'SECONDARY'/5t65('-')/":12935Rem LOOK FOR VALID PRIMARY ADDRESSES12940For prim=0 to 2912945Sec=3212950Seek:err812=012955Wbyt atn(mta,32+prim,96+sec),chr$(10),eoi,atn(unt,unl)12960If not(err812)and sec<32 then cntr=cntr+1 else goto 1297012965Goto 1297512970If not(err812)and sec=32 then cntr=cntr+1 else goto second12975If cntr>14 then goto getout else gosu check_id12980If sec=32 then goto next_pri12985Second:if nosec then goto next_pri12990Sec=sec*(sec<32)+1*(sec<>32)12995If sec<32 then goto seek13000Next_pri:next prim13005All_done:port=port+113010Cntr=013015If pos(ask$("driver"),"GPIB1",1)and port=1 then goto sel_port13020If not(pos(ask$("driver"),"GPIB1",1))and term then prin usin"L2(=75A/)/=75A":"GPIB1 NOT AVAILABLE","ON THIS 4041  ","* * * * *"13025Sele ret2prt$13030Prin#102:"POLLING IS COMPLETE"13035Prin usin"/=75a//=75a":"AUTO-CONFIGURE IS COMPLETE","Press <RETURN> to continue"13040Inpu ret$13045Call setins13050Retu13055Getout:prin"

WARNING :   The number of instruments on GPIB port : ",port,"  exceeds the EZ-TEST recommended maximum of 14."13060Prin"
Reconfigure the port and try again"13065Inpu prom"

Press <RETURN> to exit to MAIN MENU":ret$13070Retu13075Check_id:count9=count9+113080Wbyt sdc(prim,sec+96),atn(unt,unl)13085If pos(gpib$,"GPIB0",1)then gport0=113090If pos(gpib$,"GPIB1",1)then gport1=113095Open#count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOM=<10>,tim=10):"13100Id$=""13105Inpu#count9 prom"ID?":id$13110Wbyt sdc(prim,sec+96),atn(unt,unl)13115If pos(id$,"TEK/",1)then goto tek_inst13120Inpu prom"
PORT "&str$(port)&",ADDRESS "&str$(prim)&";"&str$(sec)&" - Enter Instrument Name (4 characters) : ":id$13125If len(id$)<4 then id$=id$&"    "13130Goto new_id13135Devlist0:if id$=""then instr$(count9)="  N/A "else putm buff instr$(count9)usin 12805:seg$(id$,pos(id$,"/",1)+1,pos(id$,",",1)-pos(id$,"/",1)-1),str$(port),str$(pri),str$(sec),str$(count9),"   "13140Tek_inst:id$=seg$(id$,pos(id$,"/",1)+1,pos(id$,",",1)-pos(id$,"/",1)-1)13145If id$="CG551AP"then id$="CG5001"13150If id$="2465"or id$="2445"then id$=id$&"  "13155If len(id$)>5 then goto 1316513160Putm buff id$ usin"fa6t":id$13165If pos("DM5010DC5009DC5010AA5001MI5010SI5010FG5010SG5010PS5010CG5001PS50042465  2445  7D20  ",id$,1)then goto tm_inst13175Id$="XX"&seg$(id$,1,4)13180Open#count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOH=<0>,EOA=<0>,EOU=<0>,EOM=<0>,TIM=10):"13185Putm buff instr$(count9)usin 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"TEK"13190Goto 1321013195New_id:id$="XX"&seg$(id$,1,4)13200Tm_inst:if not(pos(seg$(id$,1,2),"XX",1))then putm buff instr$(count9)usin 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"TEK"else putm buff instr$(count9)usin 12805:id$,str$(port),str$(prim),str$(sec),str$(count9),"   "13205If pos(id$,"XX",1)then open#count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOH=<0>,EOA=<0>,EOU=<0>,EOM=<10>,TIM=10):"else open#count9:gpib$&"(PRI="&str$(prim)&",SEC="&str$(sec)&",EOM=<0>,TIM=10):"13210If sec<>32 then prin usin"25T<20A5X2D9x2d":id$,prim,sec else prin usin"25t<20a5x2d":id$,prim13215Retu13220Err_811:prin 13225Adva13230Err_812:err812=113235If bus=0 then goto 1324513240Adva13245If try and not(bus)then bran all_done13250Prin bell$13255If term then prin usin"2L=75A//=75A":"THERE ARE NO ACTIVE DEVICES AT "&gpib$13260Try=113265Retr13270Err_818:err818=113275Adva13280End13300Sub r_main loca deadkey,nu_test,run_test,step_tst,run_link,go2main,runhelp,plotwfrm,get_data,plotfn,run_seg,rseg1,logdat,wrngdata13305On abor then call abort2ex13310On erro(703 to 752)then gosu wrngdata13315On erro(858)then gosu wrngdata13320Log_all=113325Init var tnam$,opname$,t_dev$13330Outdata$="S"13335Prin pagem$13340Run_lab:khead$="TEST EXECUTION MENU"13345Data"LOG","RUN","","","RETRV","","",""13350Data"FAIL","SEG","","","DATA","","","HELP"13355Data"SETUP","RUN  ","STEP ","RUN  ","STORE","PULSE","PLOT ","MAIN"13360Data"TEST ","TEST ","TEST ","LINK ","DATA ","PARAM","LOOPS","MENU"13365Init var keylab1$,keylab2$,keylab3$,keylab4$,s_tep13370Rest 1334513375Read keylab1$,keylab2$,keylab3$,keylab4$13380If log_all=0 then keylab2$(1)="ALL"13385Call gkeydisp13390Enab keys13395Prin pagem$13400Prin"Press a function key"13405Keyflag=013410Wait 13415Gosu keyflag of nu_test,run_test,step_tst,run_link,stor_dat,plotwfrm,plotfn,go2main,logdat,run_seg,deadkey,deadkey,get_data,deadkey,deadkey,runhelp13420Map$=bmap$13425If mbranch then retu13430If keyflag=0 then goto 1339013435Goto run_lab13440Nu_test:init var filelnk$,cr0,cr113445Data_lu=10013450Outdata$="S"13455Filelnk$=chr$(13)13460Prin pagem$13465Prin usin"=75A":"TEST SET-UP"13470Prin"
Do you want to get a test from "&sysdev$&"?"13475Call y_nanswr13480If answer$="N"then goto 13575 else prin"
Do you want to link multiple files?"13485Call y_nanswr13490If answer$="Y"then goto 1351513495Call infile13500Filex$=filen$13505Fsav$=filen$13510Goto 1357513515Dir"(lon=yes)"13520Newf=013525Cr0=013530Inpu prom"Enter filename or press <RETURN> to end the sequence : ":filen$13535If len(filen$)then open#80:filen$&"(for=ite)"else goto 1357513540If newf=1 then prin"
File ";filen$;" not found on "&sysdev$&" . . ."else goto 1355013545Goto 1352013550Inpu#80 usin"I":count9,instr$,newprcd$13555If newf then goto 1352013560Filelnk$=filelnk$&filen$&chr$(13)13565Cr0=cr0+113570If cr0<10 then goto 1353013575Call output13580If outdata$<>""then call storset13585Outset$=outdata$13590Datlutmp=data_lu13595Inpu prom pagem$&"

Enter Test Name: ":tnam$13600Inpu prom"

Enter operator name: ":opname$13605Inpu prom"

Enter the test device ID name or number: ":t_dev$13610Prin"
Will test be run with operator interaction (IE: Failure menu displayed if step  fails limits during execution)?"13615Call y_nanswr13620If answer$="y"then f_flag$="YES"else f_flag$="NO"13625Keyflag=113630Retu13635Wrngdata:prin usin"lfa/fa//":"Warning!","Selected data file was not generated with this software!"13640Newf=113645Adva13650Run_test:prin pagem$13655Call sdc_all13660Begstp=113665Init var me_data$,mecount,start,start$,finish,finish$,date$13670Endstp=10013675If mis=0 then call begin else prin#"prin(ind=0):":"TEST ";filen$;" ABORTED","MISSING INSTRUMENTS"13680Data_lu=70013685Outdata$=""13690Keyflag=213695Call sdc_all13700Retu13705Step_tst:s_tep=113710Call sdc_all13715Init var me_data$,mecount13720Gosu run_seg13725Keyflag=313730Call sdc_all13735Retu13740Run_link:if filelnk$=chr$(13)then retu13745Call sdc_all13750Begstp=113755Endstp=10013760Init var me_data$,mecount,start,start$,finish,finish$,date$13765If cr1=0 then goto 1378513770If verflag then comp 13775Prin pagem$13780If mis=0 then call begin else prin#"prin(ind=0):":"TEST ";filen$;" ABORTED ","MISSING INSTRUMENTS"13785If cr1<len(filelnk$)then call infile else goto 1379513790Goto 1376513795Init var cr0,cr113800Clos data_lu13805Data_lu=70013810Keyflag=413815Call sdc_all13820Retu13825Go2main:wipe=113830Mbranch=113835Retu13840Deadkey:keyflag=013845Retu13850Runhelp:path$=" HELP for TEST EXECUTION MENU"13855Key$="F7"13860Call path_lab13865Helpfil$="HEXECU"13870Init var path$13875Call prinhelp13880Keyflag=013885Retu13890Plotwfrm:newf=013895Map$=cmap$13900Prin"Specify file name for waveform retrieval . . ."13905Call respond13910If filen$=""then retu13915Open#80:filen$&"(EOU=<13>)"13920If newf=1 then prin"
File not found !"else goto 1393013925Goto plotwfrm13930Inpu#80:id$13935If pos(id$,"7D20",1)=0 then prin"
FILE DOES NOT CONTAIN 7D20 WAVEFORM ! "else goto 1394513940Goto 1390013945Inpu#80:label$,wfpre$13950Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))13955Inte wfdata(wfpts)13960Inpu#80:wfdata13965If grph and plot then goto 13980 else prin"
Graphics Rompacks Not Installed !"13970Dsp_flg=013975Goto 1401013980Dsp_flg=113985 GINIT 700,4113,113990Prin"LI100"&page$&cmap$13995Prin"
Waveform retrieved !"14000Call norwfm20(wfdata,wfpre$,normdata)14005Call plotwf20(normdata,wfpre$,1,2,3,0,"7D20 WFM "&" File : "&filen$&"   "&label$&",TEKTRONIX  EZ-TEST   S/W,TIME,VOLTS,,")14010If sgpr then goto 14025 else prin"
PULSE PARAMETERS Not Available - Signal Processing Rompack Not Installed !"14015Call commrbyt14020Goto 1416514025Prin"
Enter Pulse analysis parameter requirements . . ."14030Prin"
Beginning point on waveform (0 to "&str$(wfpts)&") : ";14035Inpu bgn14040Prin"
Ending point on waveform (0 to "&str$(wfpts)&") : ";14045Inpu e_nd14050Prin"
Base level % (0 to 100) : ";14055Inpu base14060Prin"
Top level % (0 to 100) : ";14065Inpu top14070Prin"
% Level for period (0 to 100) : ";14075Inpu perlvl14080Prin pagem$14085Call pulse(wfdata,wfpre$,bgn,e_nd,base,top,perlvl,dsp_flg,ans)14090Data"WAVEFORM  MAX  ","WAVEFORM  MIN  ","WAVEFORM  MID  ","WAVEFORM  P-P  ","WAVEFORM  TOP  ","WAVEFORM  90% ","WAVEFORM  50% ","WAVEFORM  10% ","WAVEFORM  BASE ","OVERSHOOT  (%) ","UNDERSHOOT (%) ","RISETIME ","FALLTIME ","WIDTH ","PERIOD "14095Rest 1409014100Prin"Want a strip printout?"14105Call y_nanswr14110If answer$="N"then goto 1414514115Prin#"PRIN:"usin"//3(=20A/)":id$,label$,"PULSE PARAMETERS"14120For i=1 to 1514125Read lab$14130Prin#"PRIN:"usin"FA/N/":lab$,ans(i)14135Next i14140Prin#"PRIN:"usin"10L":14145Prin"Want further analysis?"14150Call y_nanswr14155If answer$="Y"and dsp_flg then goto 1400514160If answer$="Y"and dsp_flg=0 then goto 1402514165Prin page$&"LLA>"14170Workspac=014175Retu14180Get_data:newf=014185Path$=" Retrieve Test Data File"14190Key$="F5"14195Call path_lab14200Prin"Specify file name for test data retrieval . . ."14205Call respond14210If filen$=""then prin pagem$ else goto 1422014215Goto 1431014220Open#81:filen$14225If newf then prin"
File not found! "else goto 1424014230Clos 8114235Goto get_data14240Inpu prom"
Output device? (S=Screen, L=Line printer or M=Memory) :":outdev$14245If outdev$<>"L"then goto 1426514250Call x_printr14255Copy filen$ to ask$("lu",800)14260Goto 1431014265If outdev$<>"S"then goto 1428514270Prin pagem$14275Copy filen$ to ask$("console")14280Goto 1431014285If outdev$<>"M"then goto 1430014290Call fillmed14295Goto 1431014300Prin"
WHAT !"14305Goto 1424014310Clos 8114315Init var path$14320If filen$<>""then call commrbyt14325Retu14330Plotfn:if grph and plot then goto 14345 else prin"
NO LOOP DATA AVAILABLE  or  GRAPHICS ROMS NOT INSTALLED"14335Keyflag=014340Retu14345Path$="  Plot LOOP Test Data"14350Key$="S8"14355Call path_lab14360Call graphfn14365Prin pagem$14370Init var path$14375Retu14380Run_seg:prin pagem$14385If mis=0 then goto rseg1 else prin#"prin:":"Test ";filen$;" ABORTED","Missing Instruments"14390Retu14395Rseg1:prin"Enter step(s) to RUN."14400Call num_in14405If count1=0 then goto 1443514410Call sdc_all14415Init var me_data$,mecount14420Begstp=count114425Endstp=count214430Call begin14435Data_lu=70014440Outdata$=""14445Keyflag=1014450Call sdc_all14455Retu14460Stor_dat:call output14465Call storset14470Call stordata14475Retu14480Logdat:if log_all=0 then log_all=1 else log_all=014485If log_all then prin"
All measurement data will be saved."else prin"
Only failure data will be saved."14490Wait 214495Retu14500End14600Sub begin loca outdev14605Init var stp,logd,fntest,out$,count,repeat,stimset$,stak_pt14610If cr1=0 then init var me_data$,mecount else mecount=mecount+114615If cr1=0 then goto 14620 else putm buff me_data$(mecount)usin"'Proc '12a58t":filen$14620Avg=114625Me_max=val(seg$(ask$("var",me_data$),4,6))14630For kk=1 to 10014635Seqr(kk)=sequence(kk,iterates)14640Next kk14645If start$<>""then goto 1466014650Start=ask("time")14655Start$=seg$(ask$("time"),11,8)14660If gport0 then sele"GPIB0:"else goto 1467014665Wbyt llo14670If gport1 then sele"GPIB1:"else goto 1468014675Wbyt llo14680Call r_runit14685Finish=ask("time")14690Date$=ask$("time")14695Finish$=seg$(date$,11,8)14700If cr1>1 and cr1<len(filelnk$)then retu14705Data_lu=70014710Outdev:outdata$=outset$14715Call stordata14720Retu14725End14800Sub r_runit loca r_run0,r_run1,r_run2,r_run3,r_run4,run_nofn,lp_step,next_lp,seq_bad,ret_sub,singl,st_sngl14805Prin#"FRTP(rate=.05,vie=.05):":"TEST FILE ";fsav$14810Stp=begstp14815Nxstp=begstp14820R_run0:if stp=0 or stp>100 or nxstp>100 or nxstp>endstp then retu14825If mecount<me_max then goto r_run114830Prin"KA0LF7f-N                                     LFf-NProcedure Terminated after "&str$(me_max)&" AcquisitionsKA1"14835Retu14840R_run1:if nxstp>=begstp then stp=nxstp14845If stp_ptr(stp)=0 then stp=stp+1 else goto r_run214850Nxstp=stp14855Goto r_run014860R_run2:if sequence(stp_ptr(stp),ret_rn)=1 then goto ret_sub14865Proc$=newprcd$(stp_ptr(stp))14870If proc$=null$ then goto r_run314875Call extract(proc$)14880Call run_step14885If actcod$="FN"then call fornext else gosu run_nofn14890R_run3:if p_f$="FAIL"then goto seq_bad14895If sequence(stp_ptr(stp),brchstrt)then goto lp_step14905If sequence(stp_ptr(stp),brchnxt)then nxstp=sequence(stp_ptr(stp),brchnxt)else nxstp=stp+114910Goto r_run414915Lp_step:if seqr(stp_ptr(stp))>1 then goto next_lp14925Seqr(stp_ptr(stp))=sequence(stp_ptr(stp),iterates)14930If sequence(stp_ptr(stp),brchnxt)then nxstp=sequence(stp_ptr(stp),brchnxt)else nxstp=stp+114935Goto r_run414940Next_lp:seqr(stp_ptr(stp))=seqr(stp_ptr(stp))-114945Nxstp=sequence(stp_ptr(stp),brchstrt)14950Goto r_run414955Seq_bad:if sequence(stp_ptr(stp),brchfail)then nxstp=sequence(stp_ptr(stp),brchfail)else nxstp=stp+114960R_run4:gosu singl14965Goto r_run014970Run_nofn:if iocode$="TX"then call r_text else call setit14975Retu14980Ret_sub:if sequence(stp_ptr(stp),brchstrt)then call stakpush(nxstp)else call stakpop(nxstp)14985Gosu singl14990Goto r_run014995Singl:if s_tep then prin"
"else goto st_sngl15000Prin"Press ""STEP TEST"" key (3) for next test step ";((nxstp max begstp)max stp+1)15005Keyflag=015010If keyflag<>3 then goto 1501015015Prin pagem$15020St_sngl:keyflag=015025P_f$="PASS"15030Retu15035End15100Sub blok_get loca eompos,commapos15105Init var blokbuf$,acqblok$15110Blocklu$=ask$("lu",outadd)15115Eompos=pos(blocklu$,"EOM",1)15120Commapos=pos(blocklu$,",",eompos)15125Rep$(blocklu$,eompos,commapos-eompos)="EOM=<0>"15130Init var oldfil,eof_err15135Prin"
Acquiring data block . . . "15140Inpu#blocklu$ buff blokbuf$:acqblok$15145Call storem15150Retu15155End15200Sub setit loca nopause15205If actcod$="FN"then goto nopause15210Outadd=val(log_unt$)15215Outadd$=ask$("lu",outadd)15220Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15225Open#outadd:outadd$15230If actcod$="NR"then prin#outadd:lset$ else goto nopause15235Call progwat15240Retu15245Nopause:init var rdata,rdata$15250If actcod$="DW"then call fn7dwv(outadd)else goto 1526015255Retu15260If actcod$="BA"then call blok_get else goto 1527015265Retu15270If pos("SG SI FG PS 7D MI 24 XX",iocode$,1)then call fnmi(outadd)15275If iocode$="DC"then call fndc(outadd)15280If iocode$="CG"then call fncg(outadd)15285If pos("DM AA",iocode$,1)then call fndm(outadd)15290Retu15295End15400Sub fornext loca stepsize,n_steps,n,frn0,sign,temp$,dely15410Logd=015415Fn_num=val(fn_num$)15420Temp$=label$15425Proctmp$=loop$(fn_num,lstim)15430Call extract(proctmp$)15435Dely1=delay15440Ins1=val(log_unt$)15445Outadd$=ask$("lu",ins1)15450Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15455Open#ins1:outadd$15460Suffix$=unit$15465Set1$=lset$15470If loop(fn_num,l_par)then goto acqrdev15475Frn0:getm buff lset$ dels";":stimset$15480Lset$=seg$(lset$,ask("buffer")+1,len(lset$))15485If lset$=""then goto acqrdev else goto frn015490Acqrdev:proctmp$=loop$(fn_num,lacqr)15495Call extract(proctmp$)15500Label$=temp$15505Ins2=val(log_unt$)15510Outadd$=ask$("lu",ins2)15515Rep$(outadd$,pos(outadd$,"):",1),0)=",TIM="&gptmout$15520Call storem15525Open#ins2:outadd$15530Stepsize=loop(fn_num,lstpitr)15535N_steps=loop(fn_num,lstpitr)-115540If loop(fn_num,llog)then sign=sgn(loop(fn_num,lstrt))15545If loop(fn_num,llog)then stepsize=(lgt(sign*loop(fn_num,lstop))-lgt(sign*loop(fn_num,lstrt)))/n_steps else n_steps=(loop(fn_num,lstop)-loop(fn_num,lstrt))/stepsize15550If n_steps<>int(n_steps)then n_steps=int(n_steps)+115555For n=0 to n_steps15560If loop(fn_num,llog)then fntest=sign*10^(lgt(sign*loop(fn_num,lstrt))+n*stepsize)else fntest=loop(fn_num,lstrt)+n*stepsize15565If n=n_steps then fntest=loop(fn_num,lstop)15570If loop(fn_num,l_par)then prin#ins1:set1$ else prin#ins1:set1$;str$(fntest)&suffix$15575Logd=logd+115580Gosu dely15585Call setit15590Next n15595Retu15600Dely:if dely1=0 then retu else strt=ask("time")15605If ask("time")-strt>=dely1 then retu else goto 1560515610Retu15615End15700Sub fndc(outadd)loca timeout15705Init var repeat,rdtemp15710For m=1 to avg15715If len(lset$)then prin#outadd:lset$15720Call progwat15725If seg$(actcod$,1,1)="P"then goto 1574015730If pos(lset$,"?",1)then inpu#outadd:rdata else inpu#outadd prom"SEND":rdata15735Goto 1574515740Call dcp_pk(outadd,rdata)15745Rdtemp=rdtemp+rdata15750Next m15755Rdata=rdtemp/avg15760Call storem15765If repeat then goto 1570515770Avg=115775Retu15780End15800Sub fndm(outadd)15805Init var repeat,rdtemp15810For m=1 to avg15815If len(lset$)then prin#outadd:lset$15820Call progwat15825If pos(lset$,"?",1)then inpu#outadd:rdata else inpu#outadd prom"SEND":rdata15830Rdtemp=rdtemp+rdata15835Next m15840Rdata=rdtemp/avg15845Call storem15850If repeat then goto 1580515855Avg=115860Retu15865End15900Sub fn7dwv(outadd)15905Old_lu$=ask$("lu",outadd)15910Open#outadd:seg$(old_lu$,1,pos(old_lu$,")",1)-1)&",eom=<0>,eoa=<0>):"15915Init var oldfil,eof_err,memnum$,mode$15920Inpu#old_lu$ prom"di? csw":memnum$15925Memnum=val(memnum$)15930Prin"
Acquiring waveform . . . "15935Prin#old_lu$:"DA ME:"&str$(memnum)15940Inpu#old_lu$ prom"WFM? ENC":mode$15945Mode$=seg$(mode$,pos(mode$,":",1)+1,len(mode$))15950Call getwfm20(outadd,mode$,wfpre$,wfdata)15955Call storem15960Retu15965End16000Sub fncg(outadd)loca ctr,ret,temp$16005On erro(811)then gosu err81116010Sele ask$("lu",outadd)16015Init var rdtemp,repeat,cgdata$,status,address,dev,ctr,temp$16020Wait 116025Gptmout=valc(ask$("lu",outadd),pos(ask$("lu",outadd),"TIM=",1))16030For m=1 to avg16035If len(lset$)then prin#outadd:lset$16040Prin"
Press CG 5001 CONTINUE button to take the measurement."16045Call progwat16050Inpu#outadd prom"read?":cgdata$16055Rdata=val(cgdata$)16060Prin"
Measurement acquired !"16065If pos(ask$("path"),"fornext",1)then goto 1609016070U_d=valc(cgdata$,pos(cgdata$,"D",1))16075Putm buff u_d$ usin"5J":u_d16080Unitspc$=u_d$16085Unit$=trim(unitspc$)16090Rdtemp=rdtemp+rdata16095Next m16100Rdata=rdtemp/avg16105Rdata=roun(rdata*1.0E+10)/1.0E+1016110Ret:call storem16115If repeat then goto 1601516120Avg=116125Retu16130Err811:ctr=ctr+116135Ctrend=60/gptmout16140If ctr>=ctrend then inpu prom"

It has now been one(1) minute since the prompt.  Do you wish to continue or abort the measurement <c> or <a>: ":temp$ else retr16145If temp$<>"c"and temp$<>"a"then goto 1614016150If temp$="a"then goto 16160 else ctr=016155Retr16160Rdata=016165Bran ret16170End16200Sub dcp_pk(digcntr var p_pampl)loca att1_tes,pk_pk16205Init var n_pk,p_pk16210If seg$(instr$(digcntr),1,6)="DC5010"then range=2 else range=316215Prin#digcntr:"CHA A;ATT 5;COU DC;"16220Prin#digcntr:"AUTO;"16225Inpu#digcntr prom"CHA A;MIN?;MAX?;":n_pk,p_pk16230If n_pk>-5*range and p_pk<5*range then goto att1_tes16235Prin#digcntr:"COU AC;"16240Wait .516245Prin#digcntr:"AUTO;"16250Inpu#digcntr prom"CHA A;MIN?;MAX?;":n_pk,p_pk16255Att1_tes:if not(n_pk>-range and p_pk<range)then goto pk_pk16260Inpu#digcntr prom"ATT 1;AUTO;CHA A;MIN?;MAX?;":n_pk,p_pk16265Pk_pk:p_pampl=p_pk-n_pk16270Retu16275End16300Sub fnmi(outadd)loca space1,binget,hexget,decget,arg_end,fnmi_out,valerr16305Init var rdtemp,repeat16310For m=1 to avg16315On erro(101)then gosu valerr16320If len(lset$)then prin#outadd:lset$16325Call progwat16330Inpu#outadd:rdata$16335If iocode$="MI"then goto 1635016340Rdata=val(rdata$)16345Goto arg_end16350Space1=pos(rdata$," ",1)16355Semicol=pos(rdata$,";",space1)16360If pos(rdata$," ",space1+1)then space1=space1+1 else goto 1637516365Goto 1636016370Space1=space1+116375Binget:if pos(rdata$,"B",space1)then rdata$=seg$(rdata$,space1+2,semicol-space1-2)else goto hexget16380Getm buff rdata$ usin"20B":rdata16385Goto arg_end16390Hexget:if pos(rdata$,"H",space1)then rdata$=seg$(rdata$,space1+2,semicol-space1-2)else goto decget16395Getm buff rdata$ usin"5H":rdata16400Goto 1642016405Decget:rdata$=seg$(rdata$,space1+1,semicol-space1+1)16410If asc(seg$(rdata$,1,1))>=48 and asc(seg$(rdata$,1,1))<=57 or asc(seg$(rdata$,1,1))=45 then rdata=val(rdata$)else rdata=016415Arg_end:rdtemp=rdtemp+rdata16420Next m16425Rdata=rdtemp/avg16430Call storem16435If repeat then goto 1630516440Avg=116445Fnmi_out:off erro(101)16450Retu16455Valerr:rdata=016460Adva16465End16500Sub r_text loca txagain16505Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))16510If ty<>0 then call clr_bufr16515Init var lab$,repeat16520If pos(ask$("path"),"FAILURE",1)then goto txagain16525Call run_step16530Txagain:prin pagem$16535Prin usin"30A//  FA//":"OPERATOR INSTRUCTIONS: ",lset$16540If actcod$="NR"then call commrbyt else goto 1655516545Prin pagem$16550Retu16555If actcod$="PF"then call pfkey else goto 1657016560Prin pagem$16565Retu16570Inpu prom"
Enter measurement result from keyboard (must be a number). ":rdata16575Call storem16580If repeat then goto 1651516585Prin pagem$16590Retu16595End16700Sub storem loca limit1,bloc_dat,stuffit,fndat16705Hilmt$="---   "16710Lolmt$="---   "16715Rdata$="   ---"16720Putm buff step$ usin"1an4t15a":"#",stp,label$16725If actcod$="DW"or actcod$="BA"then goto bloc_dat16730If actcod$="PF"then goto stuffit16735Putm buff rdata$ usin"I9t5a":rdata,unit$16740If pos(ask$("path"),"fornext",1)then gosu fndat16745If pos(actcod$,"L",1)then goto limit1 else p_f$="---"16750Goto stuffit16755Limit1:putm buff hilmt$ usin"I":up16760Putm buff lolmt$ usin"I":low16765If low>up then goto revlmt16770If rdata>=low and rdata<=up then p_f$="PASS"else p_f$="FAIL"16775Goto 1678516780Revlmt:if rdata<=low and rdata>=up then p_f$="PASS"else p_f$="FAIL"16785If p_f$="FAIL"then call failure16790If repeat then retu16795Goto stuffit16800Bloc_dat:if pos(lset$,"(",1)<>1 then goto 1681516805Lset$="Acquire ONLY"16810Goto 1686016815Prin"Checking data file . . ."16820Rep$(lset$,len(lset$),0)=",EOU=<13>"16825Open#80:lset$16830If oldfil then rep$(lset$,pos(lset$,"=",1)+1,3)="REP"else goto 1684016835Open#80:lset$16840Prin"Storing data . . ."16845Prin#80:instr$(outadd),label$16850If actcod$="DW"then prin#80:wfpre$,wfdata else prin#80:acqblok$16855Clos 8016860If eof_err then p_f$="FAIL"else p_f$="PASS"16865If pos(lset$,"(",1)then rdata$="File"&seg$(lset$,1,pos(lset$,"(",1)-1)else rdata$="File"&lset$16870Imag 20a20t16a36t<9a45t<9a54t4a16875Stuffit:if log_all or p_f$="FAIL"then mecount=mecount+1 else retu16880Putm buff me_data$(mecount)usin 16870:step$,rdata$,lolmt$,hilmt$,p_f$16885Retu16890Fndat:if logd=0 then putm buff rdata$ usin"4a4t<10a":"Loop",stimset$ else putm buff step$ usin"i9t4a":fntest,"ITEM"16895Retu16900End17000Sub record loca loopmea,fld1$,fld2$,fld3$,fld4$,fld5$,metemp$17005If mecount=0 then retu17010If pos(ask$("lu",data_lu),"COMM0",1)then prin pagem$17015Imag 25TFA25A17020Prin#data_lu usin 17015:"TEST NAME: ",tnam$17025Prin#data_lu usin 17015:"OPERATOR: ",opname$17030Prin#data_lu usin 17015:"ID: ",t_dev$17035Prin#data_lu usin 17015:"DATE: ",seg$(date$,1,9)17040Prin#data_lu usin"2L78('-')":17045If verflag then comp 17050For i=1 to mecount17055Metemp$=me_data$(i)17060Call parse(metemp$,fld1$,fld2$,fld3$,fld4$,fld5$)17065Prin#data_lu usin"<22a30t'|'32t26a":fld1$,fld2$17070If pos(fld5$,"PAS",1)or pos(fld5$,"FAI",1)then prin#data_lu usin"4t'Low '<22a30t'| Hi '<22a56t'|'s":fld3$,fld4$ else goto 1708017075If pos(fld5$,"FAIL",1)and data_lu=700 then prin#data_lu:"LI262    "&fld5$&"    LI122"else prin#data_lu:"    "&fld5$17080Next i17085Prin#data_lu usin"78('-')2/":17090Prin#data_lu usin"T'START TIME: '8A4X'COMPLETION TIME: '8A4X'TOTAL TIME: '7.2G2L":start$,finish$,finish-start17095Retu17100End17200Sub parse(temp$ var fld1$,fld2$,fld3$,fld4$,fld5$)17205Imag 20a16a9a9a4a17210Getm buff temp$ usin 17205:fld1$,fld2$,fld3$,fld4$,fld5$17215If seg$(fld1$,1,4)="Proc"then retu17220If seg$(temp$,10,4)="ITEM"then getm buff fld1$ usin"I":fntest else goto 1723017225Putm buff fld1$ usin"4tk":fntest17230If pos(fld2$,"---",1)or pos(fld2$,"File",1)then goto 1725517235If pos(fld2$,"Loop",1)then goto 17250 else getm buff fld2$ usin"I5a":rdata,unit$17240Putm buff fld2$ usin"kx5a":rdata,unit$17245Goto 1726017250Rep$(fld2$,5,0)="on: "17255Rep$(fld2$,5,0)=" "17260If pos(fld3$,"---",1)then goto 17270 else getm buff fld3$ usin"I":low17265Putm buff fld3$ usin"k":low17270If pos(fld4$,"---",1)then goto 17280 else getm buff fld4$ usin"I":up17275Putm buff fld4$ usin"k":up17280Retu17285End17300Sub precord loca ploopmea17305If mecount=0 then retu17310Imag /'STIMULUS'/=20A17315Imag 'LO LIMIT:'/=20A/'HI LIMIT:'/=20A/'PASS/FAIL: '>8A17320Prin#100 usin"'TEST NAME:'FA2/'OPERATOR:'FA2/'ID:'FA2/'DATE:'FA/20('-')/20('-')":tnam$,opname$,t_dev$,seg$(ask$("time"),1,9)17325If verflag then comp 17330For i=1 to mecount17335Metemp$=me_data$(i)17340Call parse(metemp$,plab$,rdata$,lolmt$,hilmt$,p_f$)17345If pos("P#",seg$(plab$,1,1),1)then prin#100 usin"/<20A":plab$ else prin#100 usin 17310:trim(plab$)17350If pos(rdata$,"Loop",1)or pos(rdata$,"File",1)then goto 1736517355If pos(rdata$,"       ",1)then goto 17375 else getm buff rdata$ dels" ":rdata$,unit$17360Prin#100:"READING in: ";unit$17365Prin#100 usin"=20A":rdata$17370If pos(p_f$,"PAS",1)or pos(p_f$,"FAI",1)then prin#100 usin 17315:lolmt$,hilmt$,p_f$17375Next i17380Prin#100 usin"/20('-')/20('-')/2l/'START TIME: '>fa/'STOP TIME:  '>fa/'TOTAL TIME:  '7.2g":start$,finish$,finish-start17385Prin#100 usin"12L":17390Retu17395End17500Sub save_it loca redif,nofi17505Newf=017510Filesize=80*(mecount+14)17515Tape$="(OPEN=NEW,SIZE="&str$(filesize)&")"17520Call respond17525If filen$=""then goto nofi17530Ftype$="REPLACE"17535Open#100:filen$17540If ftype$="NEW"then goto redif17545Prin"
Warning file already exist!"17550Prin"
Do you wish to replace old file?"17555Call y_nanswr17560If answer$="N"then retu17565Redif:rep$(tape$,7,3)="REPLACE"17570Filed$=filen$&tape$17575Newf=017580Retu17585Nofi:outdata$=""17590Newf=017595Retu17600End17700Sub failure loca deadkey,rev_lmts,fail_lab,redo,onward,go_on,average,abrt_tes17705Q=117710Avg=117715Repeat=017720If f_flag$<>"YES"then retu17725Prin pagem$17730Prin usin"faj2/'  Lo Limit: 'e3x'Hi Limit: 'e":"Failed measurement is : ",rdata,low,up17735Fail_lab:khead$="FAILURE PROMPTING"17740Data"","","","","CON-","RPEAT","AVG","ABORT"17745Data"","","","","TINUE","MEAS","MEAS","TEST"17750Init var keylab1$,keylab2$,keylab3$,keylab4$17755Rest 1774017760Read keylab3$,keylab4$17765Call gkeydisp17770Call run_step17775Prin"Press a function key"17780Keyflag=017785Wait 17790Gosu keyflag of deadkey,deadkey,deadkey,deadkey,onward,redo,average,abrt_tes,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey,deadkey17795If keyflag=0 then goto 1778517800If repeat or avg>1 or q=0 then retu17805Goto fail_lab17810Redo:rem MAKE MEASUREMENT AGAIN17815Repeat=117820Retu17825Onward:q=017830Retu17835Average:repeat=117840If iocode$="TX"then prin"

** Averaging not permitted with keyboard input. **"else goto 1785517845Q=117850Retu17855Inpu prom"
Enter number of measurements to be averaged for this test: ":avg17860Retu17865Deadkey:keyflag=017870Retu17875Abrt_tes:prin#102:"TEST ABORTED"17880Mbranch=117885Trap17890End17900Sub abort2mn17905Prin#102:bell$&"Handling an abort"17910Prin pagem$17915Cnt$=str$(count)17920Bran main_lab17925End18000Sub meas_lab(qread$)loca lab$18005Dim lab$ to 1518010L$=qread$&" meas"18015Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))18020If ty<>0 then call clr_bufr18025Prin"%!1"18030Inpu prom"


What do you want to call this step (15 character max)? ":lab$18035If lab$=""then label$=l$ else label$=lab$18040If not(qread$="CG"and pos(ask$("path"),"fornxt",1))then goto 18050 else unit$="% err"18045Goto 1806018050If qread$="CG"or qread$="GL"then unit$="     "else goto 1806518055Prin"%!0"18060Retu18065Inpu prom"

Enter units of measurement (5 character max) : ":unit$18070Prin"%!0"18075Retu18080End18100Sub x_printr18105If not(pos(ask$("driver"),"COMM1",1))then prin"

Optional comm driver (COMM1) not present in this system!"else goto 1812518110Com$="COMM0:"18115Call commrbyt18120Retu18125Phypar$=seg$(ask$("lu",800),pos(ask$("lu",800),"(",1)+1,pos(ask$("lu",800),"ech",1)-8)18130Logpar$=seg$(ask$("lu",800),pos(ask$("lu",800),"ech",1),pos(ask$("lu",800),"):",1)-len(phypar$)-8)18135Prin usin"2Lfa//fa":"COMM1 PHYSICAL PARAMETERS ARE:",phypar$18140Prin"
Enter physical parameters for COMM1 or <RETURN> for no change: "18145Inpu prom"
  e.g. baud=1200,fla=bid,typ=2000 (see 4041 Ref. Guide)        %!1[2A%!0":phy$18150If phy$=""then phy$=phypar$18155Set driv"comm1:"18160Set driv"COMM1("&phy$&"):"18165Prin usin"4Lfa//fa ":"COMM1 LOGICAL PARAMETERS ARE:",logpar$18170Prin"

Enter logical parameters for COMM1 or <RETURN> for no change:"18175Inpu prom"
  e.g. cr=cr,con=yes  (see 4041 Ref. Guide)                   %!1[2A%!0":com$18180If com$=""then com$=logpar$18185Com$="COMM1"&"("&com$&"):"18190Open#800:com$18195If keyflag<>7 then prin pagem$18200Retu18205End18300Sub pfkey18305Khead$="PASS/FAIL KEYS"18310Init var keylab1$,keylab2$,keylab3$,keylab4$18315Data"MT3PASS ","MT3KEY  ","MT2FAIL ","MT2KEY  "18320Rest 1831518325Read keylab3$(7),keylab4$(7),keylab3$(8),keylab4$(8)18330Call gkeydisp18335Call run_step18340Prin"Press PASS or FAIL key"18345Keyflag=018350Wait 18355If keyflag=7 then p_f$="PASS"18360If keyflag=8 then p_f$="FAIL"18365If keyflag<>7 and keyflag<>8 then goto 1834518370Call storem18375Retu18380End18400Sub path_lab18405Prin"MG0";18410If cnt$=""then stplab$=""else stplab$="STEP: "&cnt$18415If key$=""then keyl$=""else keyl$=" KEY: "&key$18420Prin"KA0LF7f-N                                           LFf-N"&stplab$&keyl$&path$&"KA1";18425Retu18430End18500Sub all_errs18505Prin"The system reported: ";ask$("error")18510Adva18515End18600Sub pollerrs18605Prin"SERIAL POLL ERROR REPORTED: "&ask$("error")18610Prin#200 usin"FA/FA//":"SERIAL POLL ERROR:",ask$("error")18615Adva18620End18700Sub y_nanswr18705Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))18710If ty<>0 then call clr_bufr18715Answer$="z"18720Inpu#700 prom"     Enter <y> for 'yes'  or  <RETURN> for 'no' : ":answer$18725If answer$=""then answer$="n"18730If answer$<>"Y"and answer$<>"N"then goto 1870518735Retu18740End18800Sub prinhelp loca again,linec,line$,a$18805Inte linec18810Dim line$ to 8018815Newf=018820Linec=018825Open#405:helpfil$18830If newf then prin"Help file not available"else goto again18835Wait 218840Goto 1891518845Again:if eof(405)then goto 1888518850Linec=linec+118855Inpu#405:line$18860Prin line$18865If linec=18 then inpu prom"
     Press <RETURN> for more or enter <q> to stop ":a$ else goto again18870If a$="q"then goto 18885 else linec=018880Goto again18885Clos 40518890Prin"
Do you want to print the HELP information to an external printer?"18895Call y_nanswr18900If answer$<>"Y"then goto 1891518905Call x_printr18910Copy helpfil$ to com$18915Prin pagem$18920Retu18925End19000Sub run_step19005If label$=""and out$<>"TX"and out$<>"FN"and actcod$="NR"then label$="INSTR. SET-UP"19010If label$=""and out$="TX"then label$="OPERATOR PROMPT"19015Prin"KA0LF7f-N                                     LFf-NMT7STEP: "&str$(stp)&" "&label$&"KA1"19020Prin#"frtp(rate=.05,view=.05):":stp;"  ";label$19025Retu19030End19100Sub exitest19105Bran run_lab19110End19200Sub abort2ex19205If gport0 then sele"gpib0:"else goto 1921519210Wbyt atn(unt,unl),ren(0),ren(1)19215If gport1 then sele"gpib1:"else goto 1922519220Wbyt atn(unt,unl),ren(0),ren(1)19225Prin#102 usin"/fa":"ABORT"19230Prin page$19235Finish=ask("time")19240Date$=ask$("time")19245Finish$=seg$(date$,11,8)19250Cr1=019255Bran run_lab19260End19300Sub progwat loca strt19305If unlok$="LOCAL"then sele ask$("lu",outadd)else goto 1931519310     If seg$(instr$(outadd),10,2)="32" then wbyte gtl(val(seg$(instr$(outadd),8,2))) else wbyte gtl(val(seg$(instr$(outadd),8,2)),val(seg$(instr$(outadd),10,2)))19315If delay=0 then retu else strt=ask("time")19320If ask("time")-strt>=delay then retu else goto 1932019325End19400Sub clr_bufr19405Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))19410If ty=0 then retu19415Sele"COMM0:"19420For xx=1 to ty19425Rbyt answer$19430Next xx19435Retu19440End19500Sub getwfm20(log_unit,mode$ var wfpre$,wfdata)loca temp$,wfpts,get_asc,get_rtn19560Dele var wfdata19565Init var blokbuf$,wfpre$,wfdata,wfpts19570Prin#log_unit:"lo off;da encdg:"&mode$19575Inpu#log_unit prom"wfmpre?":wfpre$19580Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))19585Prin#log_unit:"curve?"19590If mode$="asc"then goto get_asc19595Inte wfdata(wfpts)19600Inpu#log_unit buff blokbuf$:bufr$19605Getm buff blokbuf$ usin"5A,+8%":temp$,wfdata19610Goto get_rtn19615Get_asc:dim wfdata(wfpts)19620Inpu#log_unit buff blokbuf$:wfdata19625Get_rtn:dele var temp$,wfpts19630Retu19635End19700Sub norwfm20(wfdata,wfpre$ var normdata)loca mode$,norm_asc19740Prin"Normalizing waveform.....wait"19745Dele var normdata19750Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))19755Yzero=valc(wfpre$,pos(wfpre$,"yz",1))19760Mode$=seg$(wfpre$,pos(wfpre$,":",pos(wfpre$,"enc",1))+1,3)19765Ymult=valc(wfpre$,pos(wfpre$,"ym",1))19770Dim normdata(wfpts)19775If mode$="asc"then goto norm_asc19780Normdata=(((wfdata-128)/25)*ymult)+yzero19785Retu19790Norm_asc:normdata=(wfdata*ymult)+yzero19795Retu19800End19900Sub graphfn loca x1,x2,size,dec,inc,count,ylo,yhi,xtype,ele1,xx1,xx2,y1,y2,yy1,yy2,autoflag,lxw,hxw,lyw,hyw,lxv,hxv,lyv,hyv,a,b19905On erro(80)then gosu err8019910Inte x1,x2,size19915Prin pagew$19920 GINIT 700,4113,119925Call fnmenu(x1,x2)19930If x2=0 then goto 2014519935If x2=1 then size=1 else size=x2-x119940Long xplt(size),yplt(size)19945Dim a(size),b(size)19950For point=1 to size19955Metemp$=me_data$(x1+point)19960Getm buff metemp$ usin"I11aI":xplt(point),fld1$,yplt(point)19965A(point)=xplt(point)19970B(point)=yplt(point)19975Next point19980Prin"LI700"19985Prin pagem$19990Prin usin"2L=75A":"PLOTTING "&grlab$19995Rcal"xlog",020000If size<3 then goto 2003020005If(xplt(1)-xplt(2))<>(xplt(2)-xplt(3))and(xplt(1)min xplt(size))>0 then rcal"xlog",120010Rcal"ask xlog",xtype20015Ele1=xplt(1)20020If xtype then rcal"XRANGE",10^int(lgt(ele1)),xplt(size)else XRANGE20025If xtype then rcal"xtic",int(lgt(xplt(1))),1 else XTIC20030 LINESTYL 020035 SYMBOL 2,120040 XGRID 120045 YGRID 120050Prin pagew$20055 COLOR 120060 XYPLOT xplt,yplt20065 COLOR 320070 SYMBOL 0,120075 LINESTYL 120080 XYADD xplt,yplt20085 COLOR 520090Rcal"ask viewport",xx1,xx2,yy1,yy220095Rcal"ask window",x1,x2,y1,y220100If xtype then gosu ticmark20105 VIEWPORT xx1,xx2,yy1,yy220110 WINDOW x1,x2,y1,y220115 TITLE grlab$20120 SUBTITLE date$20125 MOVE 65,1520130 GTEXT"STIMULUS: "&stimset$20135 YTITLE"MEASUREMENT : "&grunit$20140Goto 1992520145 COLOR 120150Prin"LI122"20155Dele var xplt,yplt20160Pkhead$=""20165Retu20170Ticmark:rcal"ask yrange",ylo,yhi,autoflag20175Rcal"ask plot",lxw,hxw,lyw,hyw,lxv,hxv,lyv,hyv20180 WINDOW lxw,hxw,lyw,hyw20185 VIEWPORT lxv,hxv,lyv,hyv20190 LINESTYL 220195For dec=int(lgt(xplt(1)))to int(lgt(xplt(size)))+120200Inc=10^int(dec)20205For count=10^dec+inc to 10^(dec+1)-inc step inc20210 MOVE lgt(count),ylo20215 DRAW lgt(count),yhi20220Next count20225Next dec20230 LINESTYL 120235Retu20240Err80:inpu prom"Unable to plot loop"&chr$(13)&"Selected loop has a value that is outside the range of the graph routine."&chr$(13)&"Press <RETURN> to continue.":ans$20245Bran 1991520250End20300Sub plotwf20(ydata,wfpre$,axis_col,wfm_col,labl_col,ty_pe,label$)loca start,sto_p,titl$,i,seg_labl,seg_done,plot_et,plot_at,plot_pt,plot_gr20380Dim titl$(5)20385For i=0 to 420390If i=0 then start=1 else start=posn(label$,",",1,i)+120395Sto_p=posn(label$,",",1,i+1)20400If sto_p<>-1 then goto seg_labl20405Sto_p=len(label$)+120410Exit  to segdone20415Seg_labl:titl$(i+1)=seg$(label$,start,(sto_p-start))20420Next i20425Segdone:VIEWPORT20430 OFFSET20435Xincr=valc(wfpre$,pos(wfpre$,"xi",1))20440Ymult=valc(wfpre$,pos(wfpre$,"ym",1))20445Yzero=valc(wfpre$,pos(wfpre$,"yz",1))20450Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))20455 YRANGE-((10*ymult)/2)+yzero,((10*ymult)/2)+yzero20460Gosu ty_pe+1 of plot_et,plot_at,plot_pt20465Goto plot_gr20470Plot_et:tpos=valc(wfpre$,pos(wfpre$,"pt.o",1))*xincr20475 XRANGE-(tpos),(xincr*(wfpts-1))-tpos20480 OFFSET-tpos,xincr20485Retu20490Plot_at:XRANGE 0,(wfpts-1)*xincr20495 OFFSET 0,xincr20500Retu20505Plot_pt:XRANGE 0,(wfpts-1)20510Retu20515Plot_gr:XGRID 120520 YGRID 120525 PAGE20530 COLOR axis_col20535 YPLOT20540 COLOR wfm_col20545 YADD ydata20550 COLOR labl_col20555 TITLE titl$(1)20560 SUBTITLE titl$(2)20565 XTITLE titl$(3)20570 YTITLE titl$(4)20575Retu20580End20600Sub pulse(wfm,pre$,bgn,e_nd,base,top,perlvl,dsp_flg var ans)loca proc1,proc3,proc4,proc5,proc6,proc7,ck_rgt,not_frst,cross_ck,inc_i_cr,cross1,ck_slope,cr_done,ck_done,nxt_edge,inc_i_1,inc_i_2,slp_done,init_i_1,inc_i_3,ck_1,period2,wfpts,label$20645If dsp_flg=0 then goto proc120670 VIEWPORT20675Rcal"ask viewport",vx1,vx2,vy1,vy220720Char_h=vy2/3020725Char_w=vx2/8020730 PAGE20735 MOVE 10*char_w,25*char_h20740 COLOR 720745Prin"MC1F41"20750 GTEXT"Computing Pulse Parameters "20755 MOVE 20*char_w,20*char_h20760 GTEXT"BUSY"20765Prin"MC111"20790Proc1:dim ans(16),label$(7),fifloc(1)20795Inte wmin,wmax,maxloc,minloc20800Init var rise,fall,wfm_per,wfm_wid,ans,fifloc,strtpt,r10,r90,f10,f90,edge20805Init var rgt,lft,test,edge20810Wfpts=valc(pre$,pos(pre$,"nr",1))20815Ymult=valc(pre$,pos(pre$,"ym",1))20820Xinc=valc(pre$,pos(pre$,"xi",1))20825Yzero=valc(pre$,pos(pre$,"yz",1))20830Tpos=valc(pre$,pos(pre$,"pt.o",1))*xinc20835Encdg$=seg$(pre$,pos(pre$,":",pos(pre$,"enc",1))+1,3)20840Yunit$=seg$(pre$,pos(pre$,":",pos(pre$,"yu",1))+1,1)20845Xunit$=seg$(pre$,pos(pre$,":",pos(pre$,"xu",1))+1,1)20850If bgn<1 or bgn>wfpts or bgn>=e_nd then bgn=120855If e_nd>wfpts or e_nd<1 or e_nd<=bgn then e_nd=wfpts20860If base<0 or base>100 then base=020865If top<0 or top>100 then top=10020870If perlvl<=0 or perlvl>=100 then perlvl=5020905Vres=25620910Vrtscale=ymult/2520930If encdg$="asc"then wfm=(wfm+5.12)*2520960If not((e_nd-bgn-1)<>wfpts and dsp_flg=2)then goto proc320965Inte tmpwfm(wfpts)20970Tmpwfm=wfm20995Proc3:if(e_nd-bgn)=wfpts then goto proc521000Proc4:for i=bgn to e_nd21005Wfm(i-bgn+1)=wfm(i)21010Next i21015Inte wfm(e_nd-bgn)21020Proc5:AMAX wfm,wmax,maxloc21025Ans(1)=(wmax-vres/2)*vrtscale+yzero21030 AMIN wfm,wmin,minloc21035Ans(2)=(wmin-vres/2)*vrtscale+yzero21040Range=wmax-wmin21045If range<25 then goto proc821050If(base=0 and top=0)then goto histo21055Top=top/100*range+wmin21060Base=base/100*range+wmin21065Goto proc621105Histo:dim hstwfm(vres),temp(vres)21110Init var hstwfm,temp,wmin_flg21115 AMIN wfm,wmin,minloc21120If wmin>=1 then goto histo121145Wmin_flg=121150Wfm=wfm+121155Histo1:for i=1 to e_nd-bgn21160Hstwfm(wfm(i))=hstwfm(wfm(i))+121165Next i21170 AMAX wfm,wmax,maxloc21175 AMIN wfm,wmin,minloc21210Temp(2)=-121215Temp(((wmax-wmin)/2)+wmin)=221220 INTEGRAT temp,temp21225Temp(1)=-121230Hstwfm=hstwfm*temp21235 AMAX hstwfm,hmax,maxloc21260If wmin_flg=1 then top=maxloc-1 else top=maxloc21265 AMIN hstwfm,hmax,minloc21270If wmin_flg=1 then base=minloc-1 else base=minloc21275If wmin_flg=1 then wfm=wfm-121310Proc6:ans(5)=(top-vres/2)*vrtscale+yzero21315Ans(9)=(base-vres/2)*vrtscale+yzero21320Center=(top-base)/2+base21325Ans(7)=(center-vres/2)*vrtscale+yzero21330L10=(top-base)*.1+base21335Ans(8)=(l10-vres/2)*vrtscale+yzero21340L90=(top-base)*.9+base21345Ans(6)=(l90-vres/2)*vrtscale+yzero21365Slope=121370 CROSS wfm,center,l,121375Fifloc(1)=l21380If l<1 then goto slp_done21385Edge=121420Ck_rgt:if rgt+int(fifloc(1))<(e_nd-bgn+1)then rgt=rgt+121425If int(fifloc(1))-lft>1 then lft=lft+121430Test=wfm(int(fifloc(1))+rgt)-wfm(int(fifloc(1))-lft)21435If abs(test)<5 then goto ck_rgt21440Slope=sgn(test)21445Not_frst:if((slope=1 and rise>=1)or(slope=-1 and fall>=1))then goto nxt_edge21465Lev=l1021470Gosu cross_ck21475If slope=1 then r10=loc else f10=loc21495Lev=l9021500Gosu cross_ck21505If slope=1 then r90=loc else f90=loc21525Goto ck_done21560Cross_ck:init var old_loc,loc,i21565Inc_i_cr:i=i+121570 CROSS wfm,lev,loc,i21575Cross1:if loc=-1 and old_loc=0 then goto cr_done21580If loc>fifloc(edge)or loc=-1 then goto ck_slope21585Old_loc=loc21590Goto inc_i_cr21595Ck_slope:if((lev=l10 and slope=-1)or(lev=l90 and slope=1))then goto cr_done21600Loc=old_loc21605Cr_done:retu21625Ck_done:if r10>=1 and r90>=1 then rise=edge21630If f10>=1 and f90>=1 then fall=edge21635If rise and fall then goto slp_done21660Nxt_edge:i=021665Inc_i_1:i=i+121670 CROSS wfm,(top-1)*(slope=1)+(base+1)*(slope=-1),l,i21675If l<1 then goto slp_done21680Temploc=l21685If l<=fifloc(edge)then goto inc_i_121690I=021695Inc_i_2:i=i+121700 CROSS wfm,center,l,i21705If l<1 then goto slp_done21710If l<=temploc then goto inc_i_221730Dim fifloc(edge+1)21735Fifloc(edge+1)=l21740Edge=edge+121745Slope=-slope21750Goto not_frst21755Slp_done:if rise then ans(12)=(r90-r10)*xinc21760If fall then ans(13)=(f10-f90)*xinc21765If edge<2 then goto proc721770Wfm_wid=fifloc(2)-fifloc(1)21775Ans(14)=wfm_wid*xinc21780Rem find the period if available21785Proc7:dim perloc(3)21790Perlvl=perlvl/100*range+wmin21795Level=perlvl21800J=121805Init_i_1:i=021810Inc_i_3:i=i+121815 CROSS wfm,level,l,i21820Perloc(j)=l21825If perloc(j)<1 then goto proc821830If j>1 then goto period221835J=221840Init var rgt,lft,test21845Ck_1:if rgt+int(perloc(1))<(e_nd-bgn+1)then rgt=rgt+121850If int(perloc(1))-lft>1 then lft=lft+121855Test=wfm(int(perloc(1))+rgt)-wfm(int(perloc(1))-lft)21860If abs(test)<5 then goto ck_121865Slope=sgn(test)21900I1=i21905Discrim=521910Level=perlvl-slope*discrim21915If level>wmax then level=wmax21920If level<wmin then level=wmin21925Goto init_i_121930Period2:if perloc(j)<=perloc(j-1)then goto inc_i_321935If j=3 then goto per_done21940J=321945I=i121970Level=perlvl21975Goto inc_i_321980Per_done:wfm_per=perloc(3)-perloc(1)21985Ans(15)=wfm_per*xinc22005Wsum=022010For i=perloc(1)to perloc(3)22015Prod=(wfm(i)-vres/2)*vrtscale+yzero22020Wsum=prod*prod+wsum22025Next i22030Ans(16)=sqr(wsum/wfm_per)22040Proc8:ans(3)=(ans(1)-ans(2))/2+ans(2)22045Ans(4)=abs(ans(1)-ans(2))22050If rise>=1 then ans(10)=abs((wmax-top)*100/(top-base))22055If fall>=1 then ans(11)=abs((wmin-base)*100/(top-base))22060If dsp_flg=0 then goto re_turn22065Dim results$ to 20022070Results$=";MAX:   ,"&yunit$&";MIN:   ,"&yunit$&";MID:   ,"&yunit$&";P-P:   ,"&yunit$&";100 %: ,"&yunit$22075Results$=results$&";90 %:  ,"&yunit$&";50 %:  ,"&yunit$&";10 %:  ,"&yunit$&";0 %:   ,"&yunit$&";+O.S.: ,%"22080Results$=results$&";-O.S.: ,%;RISE:  ,"&xunit$&";FALL:  ,"&xunit$&";WIDTH: ,"&xunit$&";PERIOD:,"&xunit$22085Results$=results$&";RMS:   ,"&yunit$22090Dsp_wfm:if dsp_flg=1 then wfpts=e_nd-bgn22095If dsp_flg=1 then strtpt=bgn22100 XRANGE-tpos+(strtpt*xinc),xinc*(wfpts-1)-tpos+(strtpt*xinc)22105 OFFSET-tpos+(strtpt*xinc),xinc22110 YRANGE-(5.12*ymult)+yzero,5.08*ymult+yzero22115 PAGE22120 VIEWPORT22125 WINDOW22130 MOVE 17*char_w,28*char_h22135 VIEWPORT 40,140,1,9522140 COLOR 122145Rcal"linestyle",122150 YGRID 022155 XGRID 022160 YPLOT22165 YTITLE"AMPLITUDE volts"22170 XTITLE"Time Relative To Trigger"22175Rcal"ask plot",pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy222180Dim ploc(11)22185Ploc(1)=wmax22190Ploc(2)=top22195Ploc(3)=l9022200Ploc(4)=center22205Ploc(5)=l1022210Ploc(6)=base22215Ploc(7)=wmin22220Label$(1)=" Max"22225Label$(2)="100%"22230Label$(3)=" 90%"22235Label$(4)=" 50%"22240Label$(5)="10%"22245Label$(6)="0%"22250Label$(7)="Min "22255 COLOR 322275Rcal"linestyle",222280Dele var temp22285 VIEWPORT pvx1,pvx2,pvy1,pvy222290 WINDOW pwx1,pwx2,pwy1,pwy222295For i=1 to 722300If ploc(i)<1 then goto 2241022305Temp=vrtscale*(ploc(i)-vres/2)+yzero22310 MOVE pwx1,temp22315 DRAW pwx2,temp22320 VIEWPORT vx1,vx2,pvy1,pvy222325 WINDOW22330Rcal"linestyle",122335 RMOVE char_w,022340If i<5 then RDRAW int((((i+2)*char_w)+pvx2)/char_w)*char_w-pvx2,022345If i>4 then RDRAW int((((9-(i-2))*char_w)+pvx2)/char_w)*char_w-pvx2,022350 WINDOW pwx1,pwx2,pwy1,pwy222355If i<5 then RDRAW 0,pwy2-((ploc(i)-vres/2)*vrtscale+yzero)22360If i>4 then RDRAW 0,pwy1-((ploc(i)-vres/2)*vrtscale+yzero)22365 VIEWPORT22370 WINDOW22375If i<5 then RDRAW 0,int((((5-i)*char_h)+pwy2)/char_h)*char_h-pwy2+(char_h/2)else RDRAW 0,-(int((pwy1-((3-i)*char_h))/char_h)*char_h-pwy1)+(char_h/2)22380 RDRAW char_w,022385 RMOVE 0,-(char_h/2)22390 GTEXT label$(i)22395 VIEWPORT pvx1,pvx2,pvy1,pvy222400 WINDOW pwx1,pwx2,pwy1,pwy222405Rcal"linestyle",222410Next i22435 COLOR 422440Rcal"linestyle",122445Inte wpt_pt,loc(2)22450Init var wpt_pt,loc,done22455Wpt_pt=wfpts/(pvx2-pvx1)22480If rise<1 then goto dr_fall22485If dsp_flg=1 then loc(1)=int(r10)else loc(1)=int(r10)+bgn22490If dsp_flg=1 then loc(2)=int(r90)else loc(2)=int(r90)+bgn22495Loc$="RISE"22500Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-.5)22540If max_char>len(loc$)then pass=0 else pass=122545If(loc(1)>f90+strtpt and fall>=1 and loc(2)<wfpts-100)then pass=222550For i=1 to 222555 VIEWPORT pvx1,pvx2,pvy1,pvy222560 WINDOW 1,wfpts,0,vres22565If(i=2 and loc(2)-loc(1)<wpt_pt)then goto 2268022570If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i))+1 else MOVE loc(i),wfm(loc(i)+1)22575 DRAW loc(i),vres22580 VIEWPORT22585 WINDOW22605 RMOVE 0,char_h/222610 RDRAW 0,char_h22615If(pass=2 or i=2)then goto 2268022620If pass=1 then RMOVE-char_w*(len(loc$)+1),0 else RMOVE char_w,022625If pass>0 then goto 2267022630If(max_char-len(loc$))/2<1 then goto 2267022655For i1=1 to int((max_char-len(loc$))/2-.5)22660Rep$(loc$,0,0)=chr$(32)22665Next i122670 GTEXT loc$22675Goto 2270522680If(i=1 or pass<2)then goto 2270522685 VIEWPORT22690 WINDOW22695 RMOVE char_w,022700 GTEXT loc$22705Next i22710Dr_fall:if(done=1 or fall=0)then goto dr_time22715Done=122720If dsp_flg=1 then loc(1)=int(f90)else loc(1)=int(f90)+strtpt22725If dsp_flg=1 then loc(2)=int(f10)else loc(2)=int(f10)+strtpt22730Loc$="FALL"22735Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-.5)22740If max_char>len(loc$)then pass=0 else pass=122745If(loc(1)>r90+strtpt and rise>=1 and loc(2)<wfpts-100 and pass=1)then pass=222750Goto 2255022770Dr_time:if edge<2 then goto lst_parm22775If dsp_flg=1 then loc(1)=int(fifloc(1))else loc(1)=int(fifloc(1))+bgn22780If dsp_flg=1 then loc(2)=int(fifloc(2))else loc(2)=int(fifloc(2))+bgn22785Loc$="WIDTH"22790Done=022795N=122800Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-.5)22805If max_char+1>len(loc$)then pass=0 else pass=122810If(pass=1 and((loc(1)<wfpts/2 and loc(2)<wfpts-100 and int((perloc(3)+strtpt-loc(2))/wpt_pt/char_w)>len(loc$))or(loc(1)>perloc(1)+strtpt and perloc(1)+strtpt<>0)))then pass=222815For i=1 to 222820 VIEWPORT pvx1,pvx2,pvy1,pvy222825 WINDOW 1,wfpts,0,vres22830If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i)-1 max 1)else MOVE loc(i),wfm(loc(i)-1 max 1)22835 DRAW loc(i),022840 VIEWPORT22845 WINDOW22850 RMOVE 0,-3*char_h22855 RDRAW 0,-1.5*char_h*n22860If(pass=2 or i=2)then goto 2290522865If pass=1 then RMOVE-char_w*(len(loc$)+1),0 else RMOVE char_w,022870If pass>=1 then goto 2289522875If(max_char-len(loc$))/2<1 then goto 2289522880For i1=1 to int((max_char-len(loc$))/2-.5)22885Rep$(loc$,0,0)=chr$(32)22890Next i122895 GTEXT loc$22900Goto 2292022905If(i=1 or pass<2)then goto 2292022910 RMOVE char_w,022915 GTEXT loc$22920Next i22925If(done=1 or wfm_per=0)then goto lst_parm22930N=222935Done=122940If dsp_flg=1 then loc(1)=int(perloc(1))else loc(1)=int(perloc(1))+strtpt22945If dsp_flg=1 then loc(2)=int(perloc(3))else loc(2)=int(perloc(3))+strtpt22950Loc$="PERIOD"22955Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-.5)22960If max_char+1>len(loc$)then pass=0 else pass=122965If(pass=1 and loc(1)<wfpts/2 and loc(2)<(wfpts-100))then pass=222970Goto 2281522975Lst_parm:COLOR 222980If dsp_flg=2 then YADD vrtscale*(tmpwfm-vres/2)+yzero else YADD vrtscale*(wfm-vres/2)+yzero22985 VIEWPORT22990 WINDOW22995 COLOR 323000 MOVE 2*char_w,26*char_h23005 GTEXT"Pulse Parameters:"23010 MOVE 2*char_w,24*char_h23015Sp=023020For i=1 to 1623025If ans(i)=0 then goto dsp_pro223030Sp=sp+123035If i>=12 then COLOR 423040If i>=12 then MOVE 2*char_w,(24*char_h)-(char_h*sp)else MOVE 2*char_w,(25*char_h)-(char_h*sp)23045Putm buff msg$ usin"fa,x,4j,fa":seg$(results$,posn(results$,";",1,i)+1,7),ans(i),seg$(results$,posn(results$,",",1,i)+1,1)23050 GTEXT msg$23055Dsp_pro2:next i23060Re_turn:dele var loc,ploc,wfm,tmpwfm,rise,vx1,vx2,vy1,vy2,pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy2,char_w,char_h,wmax,wmin,maxloc,minloc,wfpts,ymult,xinc,yzero,tpos,encdg$,xunit$,yunit$,vres,vrtscale,range,hstwfm,temp,wmin_flg,center,l1023065Dele var l90,r10,r90,f10,f90,edge,slope,i,rgt,lft,l,old_loc,loc,temploc,wfm_wid,level,i1,discrim,perloc,wfm_per,wsum,prod,results$,loc$,strtpt,ploc,wpt_pt,done,max_char,pass,sp,wfm23070Retu23075End23100Sub stordata loca n_dev,t_ck,l_ck,p_ck,s_ck23105If mecount=0 then prin"
NO DATA ! "else goto n_dev23110Retu23115N_dev:if outdata$=""then prin"

Test data acquired. Use ""STORE DATA"" to view."else goto t_ck23120Retu23125T_ck:data_lu=datlutmp23130If outdata$="T"or outdata$="D"then open#100:filed$ else goto p_ck23135Call record23140Clos 10023145Newf=023150Retu23155P_ck:if outdata$="P"then open#100:"PRIN(IND=0):"else goto l_ck23160Call precord23165Clos 10023170Retu23175L_ck:if outdata$="L"then open#100:com$ else goto s_ck23180Call record23185If val(com$)then prin#com$:chr$(12)23190Clos 10023195Retu23200S_ck:if outdata$="S"then data_lu=70023205Call record23210Call commrbyt23215Retu23220End23300Sub storset loca t_ck,l_ck23305If pos("TtDd",outdata$,1)then goto t_ck23310If outdata$="L"then goto l_ck23315Retu23320T_ck:call save_it23325Retu23330L_ck:call x_printr23335Retu23340End23400Sub fnmenu(var x1,x2)loca fllab$,flpnt,i,j,j1,levnam$,found,getchce,none23405Inte f,i,j,j1,x1,x223410X1=123415X2=mecount23420J=023425For i=1 to mecount23430If seg$(me_data$(i),1,4)="Proc"then j=j+123435Next i23440If j=0 then goto 2353523445Dim fllab$(j)to 1523450Inte flpnt(j+1)23455J=123460Flpnt(1)=123465For i=1 to mecount23470If seg$(me_data$(i),1,4)<>"Proc"then goto 2349023475Fllab$(j)=seg$(me_data$(i),6,10)23480Flpnt(j)=i23485J=j+123490Next i23495If j=1 then flpnt(j+1)=mecount else flpnt(j)=mecount23500F=123505If j=1 then goto 2352523510Levnam$="File Name"23515Gosu getchce23520If f<=0 then goto nodo23525X1=flpnt(f)23530X2=flpnt(f+1)23535J=023540For i=x1 to x223545If pos(me_data$(i),"Loop",20)then j=j+123550Next i23555If j=0 then goto none23560Dim fllab$(j)to 1523565Fllab$=""23570Inte flpnt(j+1)23575Flpnt=023580J=123585For i=x1 to x223590If not(pos(me_data$(i),"Loop",20))then goto 2363023595For j1=1 to j23600If fllab$(j1)=seg$(me_data$(i),5,15)then exit  to found23605Next j123610If j1>j then fllab$(j)=seg$(me_data$(i),5,15)23615J1=j23620J=j+123625Found:flpnt(j1)=flpnt(j1)+123630Next i23635Levnam$="Loop Step"23640Gosu getchce23645If f<=0 then goto nodo23650I=flpnt(f)23655If i=1 then goto 2368523660Prin"There are ";i;" occurrences of Loop ";fllab$(f)23665Inpu prom"Which Loop do you want ":i23670If i<=0 then goto nodo23675If i>flpnt(f)then prin"Invalid Selection"else goto 2368523680Goto 2365023685J1=i23690For j=x1 to x223695If seg$(me_data$(j),5,15)=fllab$(f)and pos(me_data$(j),"Loop",20)then j1=j1-1 else goto 2370523700If j1=0 then exit  to jstart23705Next j23710Jstart:x1=j+123715For j=x1 to x223720If pos("P#",seg$(me_data$(j),1,1),1)then exit  to jfinish23725Next j23730Jfinish:x2=j-123735If flpnt(f)=1 then grlab$=fllab$(f)else grlab$=trim(fllab$(f))&" #"&str$(i)23740Stimset$=trim(seg$(me_data$(x1-1),25,10))23745Grunit$=seg$(me_data$(x1),30,5)23750X1=x1-123755Retu23760Getchce:j=j-123765For i=1 to j23770Prin usin"2d2x<16as":i,fllab$(i)23775Next i23780Prin 23785F=9923790Inpu prom"            Select "&levnam$&" by Number or 0 for none :":f23795If f>j then prin"Invalid Selection"else goto 2381023800Wait 123805Goto 2376523810Retu23815Nodo:x1=023820X2=023825Retu23830None:prin"No loop data to plot
"23835Call commrbyt23840X1=023845X2=023850Retu23855End23900Func linein$ loca line$23905Dim line$ to 8023910Inpu#81:line$23915Linein$=trim(seg$(line$,pos(line$,":",1)+2,len(line$)-pos(line$,":",1)+2))23920Retu23925End24000Sub fillmed loca line$,lpmeas,dproc,dloop,dfile,dmeas,dout,dtime,dlim,again,done,stimset$24005Dim line$ to 80,stimset$ to 1224010Imag   20A20t4A24t<12A36T>9A45T>9A54T4A24015Imag   I9T4A20TI29T<5A36T>9A45T>9A54T4A24020Imag   20A20tI29t<5A36T>9A45T>9A54T4A24025Imag   36a<9A45T<9A54T4A24030Init var me_data$,mecount24035Open#81:filen$24040Tnam$=linein$24045Opname$=linein$24050T_dev$=linein$24055Date$=linein$24060Start=024065Again:if eof(81)then goto done24070Inpu#81:line$24075If seg$(line$,1,4)="Proc"then goto dproc24080If pos(line$,"Loop",20)then goto dloop24085If pos(line$,"File",20)then goto dfile24090If seg$(line$,1,1)="#"then goto dmeas24095If seg$(line$,1,2)="  "then goto lpmeas24100If pos(line$,"START TIME:",1)then goto dtime24105Goto again24110Lpmeas:if seg$(line$,5,3)="Low"and seg$(line$,33,2)="Hi"then goto dlim24115Fntest=val(line$)24120Rdata=valc(line$,pos(line$,"|",1)+1)24125Unit$=seg$(line$,ask("chpos")+1,5)24130Putm buff line$ usin 24015:fntest,"ITEM",rdata,unit$,"---   ","---   ","---"24135Goto dout24140Dlim:if pos(line$,"---",1)then goto 24165 else low=valc(line$,pos(line$,"Low",1))24145Putm buff low$ usin"I":low24150Up=valc(line$,pos(line$,"Hi",1))24155Putm buff up$ usin"I":up24160Goto 2417524165Low$="---   "24170Up$="---   "24175P_f$=seg$(line$,posn(line$,"|",1,2)+5,4)24180Line$=seg$(me_data$(mecount),1,36)24185Putm buff line$ usin 24025:line$,low$,up$,p_f$24190Me_data$(mecount)=line$24195Goto again24200Dproc:putm buff line$ usin"17a56t":seg$(line$,1,17)24205Goto dout24210Dloop:getm buff line$ usin"20a21x10a":label$,stimset$24215Putm buff line$ usin 24010:label$,"Loop",stimset$,"---   ","---   ","---"24220Goto dout24225Dfile:getm buff line$ usin"20a17x14a":label$,stimset$24230Putm buff line$ usin 24010:label$,"File",stimset$,"---   ","---   ","---"24235Goto dout24240Dmeas:getm buff line$ usin"20a":label$24245Rdata=valc(line$,pos(line$,"|",1))24250Unit$=seg$(line$,ask("chpos")+1,5)24255Putm buff line$ usin 24020:label$,rdata,unit$,"---   ","---   ","---"24260Dout:mecount=mecount+124265Me_data$(mecount)=line$24270Goto again24275Dtime:line$=seg$(line$,pos(line$,"START",1),80)24280Getm buff line$ usin"12x8a21x8a15x9a":start$,finish$,fin$24285Finish=val(fin$)24290Goto again24295Done:clos 8124300Retu24305End24400Sub disk_err loca err$,err,temp$,e1201,e1203,e1208,e1209,e1210,e1211,e1212,e1213,e1214,e1216,e121724405Err$=ask$("error")24410Prin"ERROR : "&err$&" has occured.
"24415Err=val(err$)-120024420Goto err of e1201,na,e1203,na,na,na,na,e1208,e1209,e1210,e1211,e1212,e1213,e1214,na,e1216,e1217,no,no,no,conte,conte,conte,conte,conte,conte,conte,conte,conte24425Goto hdwarerr24430E1201:inpu prom"
The file name you specified contained illegal character(s).  Press <RETURN>     to continue.":temp$24435Adva24440E1203:inpu prom"
The number of files in the directory exceeds the maximum allowed.  Press        <RETURN> to continue.":temp$24445Adva24450E1208:inpu prom"
Input data type did not match with input.  Press <RETURN> to continue.":temp$24455Adva24460E1209:inpu prom"
Rbyte or Wbyte number out of range.  Press <RETURN> to continue.":temp$24465Adva24470E1210:inpu prom"
Rbyte or Wbyte while disk in logical mode.  Press <RETURN> to continue.":temp$24475Na:prin"Disk error : "&err$&"...This error should have been handled elsewhere."24480Adva24485E1211:inpu prom"
An attempt was made to format a disk specifying more directory entries than can be placed on 1/16th of the disk.  Press <RETURN> to continue. ":temp$24490Adva24495E1212:inpu prom"
Illegal physical mode operation.  Press <RETURN> to continue. ":temp$24500Adva24505E1213:inpu prom"
An attempt was made to write to a file on a disk that has a write protect tab   inplace.  Remove write protect tab or insert another disk and press <RETURN>    to try again. ":temp$24510Retr24515E1214:inpu prom"
The data read back, from a sector just written, was incorrect.  Press <RETURN>  to try again or <CTRL C> to abort. ":temp$24520Retr24525E1216:inpu prom"
The data transferred to/from the disk caused a parity error.  Press <RETURN> to try again or <CTRL C> to abort. ":temp$24530Retr24535E1217:inpu prom"
An attempt was made to rename a file to an existing file name on the same disk. Press <RETURN> to try again. ":temp$24540Renamerr=124545Adva24550Conte:inpu prom"A disk error has occured and was caused by the SCSI hardware contained on the   option 3 board.  This may indicate a hardware problem.  Press <RETURN> to       continue. ":temp$24555Adva24560Hdwarerr:inpu prom"This error is sent from the disk controller card.  This may indicate a problem  with the disk drive.  Press <RETURN> to continue. ":temp$24565Adva24570No:inpu prom"An error has occured that did not exist at the time of this software.  Press    <RETURN> to continue. ":temp$24575Adva24580End24600Sub sys_dev loca temp$,sysd,dev$,lu$,dev,lu,device$24605Device$=ask$("sysdev")24610On erro(1200 to 1400)then gosu err122224615Dim dev$ to 1,lu$ to 124620Prin"WARNING:  The system device you select must be connected and fully operational  or an error will be generated."24625Prin"
Present system device is,   "&device$&chr$(13)&" 
Do you wish to change it?"24630Call y_nanswr24635If answer$<>"y"then retu24640Inpu prom"

Enter system device, tape or disk. <t> or <d> ":temp$24645If temp$<>"t"and temp$<>"d"then goto 2464024650If temp$="d"then goto dev24655Device$="tape:"24660Goto ret24665Dev:inpu prom"

Enter the disk device # : ":dev$24670If asc(dev$)<48 or asc(dev$)>54 then prin"
Invalid device number...try again"else goto lu24675Goto dev24680Lu:inpu prom"

Enter the disk logical unit # : ":lu$24685If asc(lu$)<48 or asc(lu$)>50 then prin"
Invalid logical unit number...try again."else goto setdev24690Goto lu24695Setdev:device$="Disk(dev="&dev$&",uni="&lu$&"):"24700Ret:set sysd device$24705Wait .524710If pos(ask$("sysdev"),"TAPE",1)then dim filen$ to 6 else dim filen$ to 1224715Sysdev$=seg$(device$,1,4)24720Retu24725Err1222:prin"
Invalid disk selection...try again."24730Bran dev24735End24800Sub compr24805Prin chr$(13)&"
Memory compress in progress.......wait"&chr$(13)24810Comp all24815Retr24820End24900Sub autobaud(var baud,termid)loca term_id$,baud$,i,e885,nexti,found,clse24905Fail=024910Termid=024915Baud=024920Dim baud$ to 4,term_id$ to 524925Init var baud$,term_id$,fail,termid,baud24930On erro(885)then gosu e88524935For i=1 to 1224940Data"9600","4800","2400","300","600","1200","1800","2000","150","134","110","75"24945Read baud$24950Set driv"comm0(iba="&baud$&"):"24955Open#2:"comm0(tim=2):"24960Inpu#2 prom chr$(27)&"%!0"&chr$(27)&"NU^@"&chr$(27)&"IQ?T":term_id$24965If len(term_id$)<>5 then goto nexti24970If pos("$ 9$ :$ ;$ =",seg$(term_id$,3,3),1)<>0 then exit  to found24975Nexti:next i24980Fail=124985Goto clse24990E885:adva24995Retu25000Found:termid=asc(seg$(term_id$,5,1))+404825005Baud=val(baud$)25010Clse:clos 225015Retu25020End25100Sub initerm(baud,termid)loca iw$,rv$,a$,b$,i,dalin,dta25105Prin#"frtp:":"Initializing ";termid25110Dim a$ to 300,b$ to 30025115S$="comm0(bau="&str$(baud)&",edi=ras):"25120Set driv s$25125Set cons s$25130Open#1:"comm0:"25135Prin#1:"NRIX0IX0"25140Set driv"comm0(bau=9600,edi=ras):"25145Set cons"comm0:"25150Prin#1:"LZ"&chr$(12);25155Prin#1:"%!1[?7h"25160Prin#1:"%!0";25165Prin#1:"KC";25170Wait .525175Prin#1:"KL1"25180Iw$="IW `` @?o"&chr$(127)&"?_"25185Rv$="RV `` @7o"&chr$(127)&"?_"25190If termid=4105 then ll$="LLA>"else ll$="LLB0"25195Dta:data"IH0","IM1","IA8","IJ84","IL0"25200Data"KE0","KL0","KW1","KYA0","KA1","KG1","KI0","KF0","KR0"25205Data"KS0","KT2","LBC1","LI100","LM0","LV1","MA00"25210Data"MB!!","MCB7C;<","MF0","MG1","ML1","MM0","MN0"25215Data"MP!","MQ2","MR00","MT1","MV0","NLIX0","NB1"25220Data"NDF4","NP0","NM0","NQR<","NF0","NC=:"25225Data"NT1=","NE0","NKL8","NU:","QA0","QD2","QL100","RA101"25230Data"RC1","RD14","RE0","RF6","RH#|w @","RI211","RJ0","RN211"25235Data"RQ0","RS `` @#ow$_","RU1;6","RW `` @8kn?_"25240Data"TC0F40","TB000","TD10","TF40000","TF410F40","TF42G8C2F4"25245Data"TF43O0C2F4","TF440C2F4","TF45R<C2F4","TF46C<C2F4","TF47K4C2F4"25250Data"TG140000","TG1410F40","TG142G8C2F4"25255Data"TG143O0C2F4","TG1440C2F4","TG145R<C2F4","TG146C<C2F4","TG147K4C2F4"25260Rest dta25265For i=1 to 8025270Read a$25275Prin#1:a$;25280Next i25285If termid=4105 then goto dalin25290Prin#1:"TG148I6C2F4TG149M2C2F4TG14:P>C2F4";25295Prin#1:"TG14;T:C2F4TG14<A>C2F4TG14=E:C2F4";25300Prin#1:"TG14>0B10TG14?0D20";25305Prin rv$&"TM311"&iw$25310Dalin:prin ll$25315Prin#1:"LZ"&chr$(12)&"KL0"25320Prin#1:"KDG#4A0A;D<E:";25325Clos 125330Retu25335End25400Sub tfilnam loca bad,ans$,nexti,i,hh25405For i=1 to len(filen$)25410Hh=asc(seg$(filen$,i,1))25415If i=1 then goto 2543525420If i=len(filen$)then goto 2543025425If hh=95 then goto nexti25430If hh>=48 and hh<=57 then goto nexti25435If hh>=65 and hh<=90 then goto nexti25440If hh>=97 and hh<=122 then goto nexti25445Exit  to bad25450Nexti:next i25455Retu25460Bad:prin"
The file name you entered contains illegal character(s) OR                      character(s) in disallowed position(s)."25465Call commrbyt25470Filen$=""25475Retu25480End25500Sub ckid loca pri$,sec$,prt$,nam$,lun$,tekid$,num25505Inte num25510Num=val(seg$(lab$,12,2))25515Getm buff instr$(num)usin"6a1a2a2a2a":nam$,prt$,pri$,sec$,lun$25520Sele"gpib"&prt$&":"25525Prim=val(pri$)25530Sec=val(sec$)25535Wbyt sdc(prim,sec),atn(unt,unl)25540Open#num:"gpib"&prt$&"(pri="&pri$&",sec="&sec$&",eom=<10>,tim=10):"25545Id$=""25550Inpu#num prom"id?":id$25555Wbyt sdc(prim,sec+96),atn(unt,unl)25560If pos(id$,"TEK/",1)then instr$(num)=instr$(num)&"TEK"else instr$(num)=instr$(num)&"   "25565Retu25570End25600Sub sdc_all loca err8,ret,err81225605On erro(812)then gosu err81225610If count9=0 then goto 2563525615For i=1 to count925620Sele"gpib"&seg$(instr$(i),7,1)&":"25625       If seg$(instr$(i),10,2)="32" then wbyte gtl(val(seg$(instr$(i),8,2))),atn(unl) else wbyte gtl(val(seg$(instr$(i),8,2)),val(seg$(instr$(i),10,2))+96),atn(unl)25630Next i25635Sele"gpib0:"25640Wbyt ren(0),ren(1),atn(unt,unl)25645If pos(ask$("driver"),"GPIB1",1)then sele"gpib1:"else goto ret25650Wbyt ren(0),ren(1),atn(unt,unl)25655Ret:retu25660Err812:adva25665End25700Sub commrbyt loca ans$25705Ty=val(seg$(ask$("console"),pos(ask$("console"),"#TY",1)+4,5))25710If ty<>0 then call clr_bufr25715Prin"Press any key to continue";25720Rbyt#700:ans$25725Prin 25730Retu25735End25800Sub setins loca i,ii25805Data"AA","SG","CG","PS","","XX","OPER",""25810Data"5001","5010","5001","5004","7D20","INSTR","PRMPT","HELP"25815Data"DC5010","2465","DM","FG","PS","MI","SI",""25820Data"DC5009","2445","5010","5010","5010","5010","5010",""25825Data 1,2,3,4,5,6,7,0,9,10,11,12,13,14,15,1625830Rest 2580525835Read keylab1$,keylab2$,keylab3$,keylab4$,validkey25840Xx=025845For i=1 to 525850Sel_cnt=025855For ii=1 to count925860If pos(instr$(ii),keylab1$(i)&keylab2$(i),1)then sel_cnt=125865If pos(instr$(ii),"XX",1)then xx=125870Next ii25875If sel_cnt then goto 25890 else keylab1$(i)=""25880Keylab2$(i)=""25885Validkey(i+8)=025890Next i25895If xx=1 then goto 25910 else validkey(14)=025900Keylab1$(6)=""25905Keylab2$(6)=""25910For i=1 to 725915Sel_cnt=025920For ii=1 to count925925If i<>1 then goto 2593525930If pos(instr$(ii),"DC50",1)then sel_cnt=125935If i<>2 then goto 2594525940If pos(seg$(instr$(ii),1,2),"24",1)then sel_cnt=125945If pos(instr$(ii),keylab3$(i)&keylab4$(i),1)then sel_cnt=125950Next ii25955If sel_cnt then goto 25970 else keylab3$(i)=""25960Keylab4$(i)=""25965Validkey(i)=025970Next i25975Inslab1$=keylab1$25980Inslab2$=keylab2$25985Inslab3$=keylab3$25990Inslab4$=keylab4$25995Inskey=validkey26000Retu26005End