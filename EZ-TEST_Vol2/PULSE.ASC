    4   !  *************************************************************    8   !  **                                                         **   12   !  **                 TEK EZ-TEST VOLUME II                   **   16   !  **                  DATA FILE PROCESSOR                    **   20   !  **              4105 COLOR GRAPHIC TERMINAL                **   24   !  **                      Version 4.0                        **   28   !  **                                                         **   32   !  **                       * * * * *                         **   36   !  **                                                         **   40   !  **          COPYRIGHT (c) 1984 by TEKTRONIX, INC.          **   44   !  **                   ALL RIGHTS RESERVED                   **   48   !  **                                                         **   52   !  **                       * * * * *                         **   56   !  **                                                         **   60   !  **   This  software may not be  copied, in  whole or in    **   64   !  **   part, without written permission of Tektronix, Inc.,  **   68   !  **   except for back-up and  archive  purposes.  Removal   **   72   !  **   of this Copyright and Disclaimer  statement will be   **   76   !  **   violation of the Copyright.                           **   80   !  **                                                         **   84   !  **                                                         **   88   !  *************************************************************  100 Begin:     init  105     Integer wfpts,bgn,e_nd,base,top,perlvl  110     Dim wfpre$ to 200  115     On abort then call abormenu  120     On error(842) then call mederr1 !storage media not in place  125     On error(1207) then call mederr1  130     On error(843) then call mederr2 !storage media is write protected  135     On error(850) then call mederr3 !file already exists  140     On error(1204) then call mederr3  145     On error(851) then call mederr4 !storage media is full  150     On error(1202) then call mederr4  155     On error(853) then call mederr5 !file doesn't exist  160     On error(1205) then call mederr5  165     On error(855) then call mederr6 !eof occurred on storage media  170     On error(1206) then call mederr6  175     Pagew$=""&chr$(12)  180     Pagem$="LZ"  185     Page$=pagem$&pagew$  190     Print "TG140R<00TG141G8C2F4TG142P4A>F4TG1430C2F4TG144G8C2F4TG145I6C<F4TG146P4C2F4TG147E:E:F4TF42O0C2F4"  195     Open #700:"comm:"  200     If pos(ask$("driver"),"comm1",1) then open #800:"comm1:" else open #800:"comm0:"  205     If pos(ask$("rompack"),"plot",1) then plot=1 else plot=0  210     If pos(ask$("rompack"),"grph",1) then grph=1 else grph=0  215     If pos(ask$("rompack"),"sgpr",1) then sgpr=1 else sgpr=0  220     Print page$  225     Print using "/=70a":"TEK EZ-TEST VOLUME II"  230     Print using "=70a":"7D20 WAVEFORM PLOTTER"  235     Print using "//=70a":"COPYRIGHT (c) 1984 by TEKTRONIX, INC."  240     Print using "=70a":"ALL RIGHTS RESERVED"  245     Wait 2  250 Prinmen:     print "
  
You may select one of the following:"  255     Print "
     1. Directory"  260     Print "     2. Graph 7D20 waveform"  265     Print "     3. Exit program"  270 Inprompt:     input prompt "
Enter choice by menu number : ":select$  275     If pos("123",select$,1)=0 or select$="" then print "
Invalid selection. Please try again." else goto valnum  280     Goto inprompt  285 Valnum:     gosub val(select$) of direct,plotwfrm  290     If select$="3" then goto gone else goto prinmen  295 Direct:     dir "(lon=yes)"  300     Return  305 Plotwfrm:     newf=0 ! reset new file error handler flag  310     Print "
Specify file name for waveform retrieval . . .

"  315     Call respond  320     If filen$="" then goto prinmen  325     Open #80:filen$&"(EOU=<13>)"  330     If newf=1 then print "
File not found !" else goto 340  335     Goto plotwfrm  340     Input #80:id$  345     If pos(id$,"7D20",1)=0 then print "
FILE DOES NOT CONTAIN 7D20 WAVEFORM ! " else goto 355  350     Goto 310 !  TRY FOR A PROPER FILE AGAIN  355     Input #80:label$,wfpre$  360     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))  365     Integer wfdata(wfpts)  370     Input #80:wfdata  375     If grph and plot then goto 390 else print "
Graphics Rompacks Not Installed !"  380     Dsp_flg=0 !  reset display graphing flag for pulse subprogram  385     Goto 420 !  so can't graph data - skip it.  390     Dsp_flg=1 !  set display graphing flag for pulse subprogram  395     GINIT 700,4113,1  400     Print "LI100"&page$ !  setup GRAPHICS colormap and transparent dialog area  405     Print "
Waveform retrieved !"  410     Call norwfm20(wfdata,wfpre$,normdata)  415     Call plotwf20(normdata,wfpre$,1,2,3,0,"7D20 WFM "&" File : "&filen$&"   "&label$&",TEKTRONIX  EZ-TEST   S/W,TIME,VOLTS,,")  420     If sgpr then goto 435 else print "
PULSE PARAMETERS Not Available - Signal Processing Rompack Not Installed !" !   Pulse analysis not possible it SGPR rom not installed.  425     Input prompt "
Press RETURN to continue . . . ":ret$  430     Goto 575 !  Exit this routine - no tools in this bag of tricks  435     Print "
Enter Pulse analysis parameter requirements . . ."  440     Print "
Beginning point on waveform (0 to "&str$(wfpts)&") : ";  445     Input bgn  450     Print "
Ending point on waveform (0 to "&str$(wfpts)&") : ";  455     Input e_nd  460     Print "
Base level % (0 to 100) : ";  465     Input base  470     Print "
Top level % (0 to 100) : ";  475     Input top  480     Print "
% Level for period (0 to 100) : ";  485     Input perlvl  490     Print pagem$  495     Call pulse(wfdata,wfpre$,bgn,e_nd,base,top,perlvl,dsp_flg,ans)  500     Data "WAVEFORM  MAX  ","WAVEFORM  MIN  ","WAVEFORM  MID  ","WAVEFORM  P-P  ","WAVEFORM  TOP  ","WAVEFORM  90% ","WAVEFORM  50% ","WAVEFORM  10% ","WAVEFORM  BASE ","OVERSHOOT  (%) ","UNDERSHOOT (%) ","RISETIME ","FALLTIME ","WIDTH ","PERIOD "  505     Restore 500  510     Print "
Want a strip printout?  (Y or N) ";  515     Call y_nanswr  520     If answer$="N" then goto 555  525     Print #"PRIN:" using "//3(=20A/)":id$,label$,"PULSE PARAMETERS"  530     For i=1 to 15  535       Read lab$  540       Print #"PRIN:" using "FA/N/":lab$,ans(i) !  PRINT PULSE PARAMETERS TO STRIP PRINTER  545       Next i  550     Print #"PRIN:" using "10L": !  EJECT PRINTOUT  555     Print "Want further analysis?  (Y or N) ";  560     Call y_nanswr  565     If answer$="Y" and dsp_flg then goto 415 !  re-plot and enter new parameter reqs.  570     If answer$="Y" and dsp_flg=0 then goto 435 !  re-enter new parameters,  no graph roms so don't plot  575     Print page$&"LLA>" ! ERASE GRAPHICS AREA AND RESET DIALOG AREA  580     Goto prinmen  585 Gone:     print "Thank you"  590     End  600 Sub respond !         ESTABLISH TAPE-DISK I/O  605     If newf then print pagem$&"
Selected file ("&filen$&") not found.
"  610     Dir "(LONG=YES)"  615     Input prompt "
Enter file name or RETURN for none: ":filen$  620     Fsav$=filen$ ! GET FILENAME ONLY FOR FSAV$  625     Init var newf  630     Return  635     End  700 Sub y_nanswr  705     Input answer$  710     If answer$<>"y" and answer$<>"n" then goto 705  715     Return  720     End  800 Sub norwfm20(wfdata,wfpre$ var normdata) local mode$,norm_asc  805   ! + ******************************************************** +  810   !          TEKTRONIX INSTRUMENTATION SOFTWARE LIBRARY  815   !                      UTILITY ROUTINE  820   ! NORWFM20 - Normalizd acquired waveform array to Volts.  825   ! May 5, 1983  830   !  835   ! Copyright [c] 1983, Tektronix, Inc. All rights reserved.  840   ! This software is provided on an "as is" basis without  845   ! warranty of any kind. It is not supported.  850   !  855   ! This utility software may be reproduced without prior  860   ! permission, in whole or in part, by the original purchaser.  865   ! Copies must include the above copyright and warranty notice.  870   !  875   ! - ******************************************************** -  880     Delete var normdata  885     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1))  890     Yzero=valc(wfpre$,pos(wfpre$,"yz",1))  895     Mode$=seg$(wfpre$,pos(wfpre$,":",pos(wfpre$,"enc",1))+1,3)  900     Ymult=valc(wfpre$,pos(wfpre$,"xm",1))  905     Dim normdata(wfpts)  910     If mode$="asc" then goto norm_asc  915     Normdata=(((wfdata-128)/25)*ymult)+yzero  920     Return  925 Norm_asc:     normdata=(wfdata*ymult)+yzero  930     Return  935     End 1000 Sub plotwf20(ydata,wfpre$,axis_col,wfm_col,labl_col,ty_pe,label$) local start,sto_p,titl$,i,seg_labl,seg_done,plot_et,plot_at,plot_pt,plot_gr,loc 1005   ! + ********************************************************* + 1010   !          TEKTRONIX INSTRUMENTATION SOFTWARE LIBRARY 1015   !                      UTILITY ROUTINE 1020   ! PLOTWF20 - Plot Normalized array on a TEK terminal. 1025   ! May 6, 1983 1030   ! 1035   ! Copyright [c] 1983, Tektronix, Inc. All rights reserved. 1040   ! This software is provided on an "as is" basis without 1045   ! warranty of any kind. It is not supported. 1050   ! 1055   ! This utility software may be reproduced without prior 1060   ! permission, in whole or in part, by the original purchaser. 1065   ! Copies must include the above copyright and warranty notice. 1070   ! 1075   ! - ******************************************************** - 1080     Dim titl$(5) 1085     For i=0 to 4 1090       If i=0 then start=1 else start=posn(label$,",",1,i)+1 1095       Sto_p=posn(label$,",",1,i+1) 1100       If sto_p<>-1 then goto seg_labl 1105       Sto_p=len(label$)+1 1110       Exit to segdone 1115 Seg_labl:       titl$(i+1)=seg$(label$,start,(sto_p-start)) 1120       Next i 1125 Segdone:     VIEWPORT 1130     OFFSET 1135     Xincr=valc(wfpre$,pos(wfpre$,"xi",1)) 1140     Ymult=valc(wfpre$,pos(wfpre$,"ym",1)) 1145     Yzero=valc(wfpre$,pos(wfpre$,"yz",1)) 1150     Wfpts=valc(wfpre$,pos(wfpre$,"nr",1)) 1155     YRANGE -((10*ymult)/2)+yzero,((10*ymult)/2)+yzero 1160     Gosub ty_pe+1 of plot_et,plot_at,plot_pt 1165     Goto plot_gr 1170 Plot_et:     tpos=valc(wfpre$,pos(wfpre$,"pt.o",1))*xincr 1175     XRANGE -(tpos),(xincr*(wfpts-1))-tpos 1180     OFFSET -tpos,xincr 1185     Return 1190 Plot_at:     XRANGE 0,(wfpts-1)*xincr 1195     OFFSET 0,xincr 1200     Return 1205 Plot_pt:     XRANGE 0,(wfpts-1) 1210     Return 1215 Plot_gr:     XGRID 1 1220     YGRID 1 1225     PAGE 1230     COLOR axis_col 1235     YPLOT 1240     COLOR wfm_col 1245     YADD ydata ! ,titl$(5)  omit the legend 1250     COLOR labl_col 1255     TITLE titl$(1) 1260     SUBTITLE titl$(2) 1265     XTITLE titl$(3) 1270     YTITLE titl$(4) 1275     Return 1280     End 1300 Sub pulse(wfm,pre$,bgn,e_nd,base,top,perlvl,dsp_flg var ans) local proc1,proc3,proc4,proc5,proc6,proc7,ck_rgt,not_frst,cross_ck,inc_i_cr,cross1,ck_slope,cr_done,ck_done,nxt_edge,inc_i_1,inc_i_2,slp_done,init_i_1,inc_i_3,ck_1,period2,wfpts,label$,loc 1305   !+ ******************************************************************** + 1310   !          TEKTRONIX INSTRUMENTATION SOFTWARE LIBRARY 1315   !                     UTILITY ROUTINE 1320   ! 1325   ! PULSE - 7D20/4041 - Compute Pulse Parameters. 1330   ! June 3, 1983 1335   ! 1340   ! Copyright [c] 1983, Tektronix, Inc. All rights reserved. 1345   ! This software is provided on an "as is" basis without 1350   ! warranty of any kind. It is not supported. 1355   ! 1360   ! This utility software may be reproduced without prior 1365   ! permission, in whole or in part, by the original purchaser. 1370   ! Copies must include the above copyright and warranty notice. 1375   ! 1380   !- ******************************************************************* - 1385     If dsp_flg=0 then goto proc1 1390   ! 1395   !  Clear the screen and print title indicating pulse parameters 1400   !  are being computed, and the system is busy. 1405   ! 1410     VIEWPORT 1415     Rcall "ask viewport",vx1,vx2,vy1,vy2 1420   ! 1425   !   Char_w and char_h are used to position text within the 1430   !  graphics region. Char_w is based on the viewports x-axis 1435   !  size / 80 characters per line. Char_h is based on the 1440   !  viewports y-axis size / 30 lines per screen. Both the 1445   !  80 characters and 30 lines are based on the display being 1450   !  initialized to the default values. 1455   ! 1460     Char_h=vy2/30 1465     Char_w=vx2/80 1470     PAGE 1475     MOVE 10*char_w,25*char_h 1480     COLOR 7 1485     Print "MC1F41" ! SET LARGE 4105 TEXT SIZE 1490     GTEXT "Computing Pulse Parameters " 1495     MOVE 20*char_w,20*char_h 1500     GTEXT "BUSY" 1505     Print "MC111" ! RESET SMALL 4105 TEXT SIZE 1510   ! 1515   !   Actual start of the routine, intialize most of the variables 1520   !  and extract the necessary values from the preamble. 1525   ! 1530 Proc1:     dim ans(16),label$(7),fifloc(1) 1535     Integer wmin,wmax,maxloc,minloc 1540     Init var rise,fall,wfm_per,wfm_wid,ans,fifloc,strtpt,r10,r90,f10,f90,edge 1545     Init var rgt,lft,test,edge 1550     Wfpts=valc(pre$,pos(pre$,"nr",1)) 1555     Ymult=valc(pre$,pos(pre$,"ym",1)) 1560     Xinc=valc(pre$,pos(pre$,"xi",1)) 1565     Yzero=valc(pre$,pos(pre$,"yz",1)) 1570     Tpos=valc(pre$,pos(pre$,"pt.o",1))*xinc 1575     Encdg$=seg$(pre$,pos(pre$,":",pos(pre$,"enc",1))+1,3) 1580     Yunit$=seg$(pre$,pos(pre$,":",pos(pre$,"yu",1))+1,1) 1585     Xunit$=seg$(pre$,pos(pre$,":",pos(pre$,"xu",1))+1,1) 1590     If bgn<1 or bgn>wfpts or bgn>=e_nd then bgn=1 1595     If e_nd>wfpts or e_nd<1 or e_nd<=bgn then e_nd=wfpts 1600     If base<0 or base>100 then base=0 1605     If top<0 or top>100 then top=100 1610     If perlvl<=0 or perlvl>=100 then perlvl=50 1615   ! 1620   !   The vres and vrtscale are digitizer resolution dependant. The 1625   !  vres is the number of discrete levels the digitizer can generate, 1630   !  and vrtscale is the current volts/div / levels/div to give the 1635   !  volts/level. 1640   ! 1645     Vres=256 1650     Vrtscale=ymult/25 1655   ! 1660   !   If the array is in ASCII format convert to BINARY. 1665   ! 1670     If encdg$="asc" then wfm=(wfm+5.12)*25 1675   ! 1680   !   If the array to be processed is less than the entire waveform and 1685   !  the dsp_flg=2 indicating the entire waveform is to be plotted then 1690   !  make a temporary array (tmpwfm) to be used in the plotting. 1695   ! 1700     If not((e_nd-bgn-1)<>wfpts and dsp_flg=2) then goto proc3 1705     Integer tmpwfm(wfpts) 1710     Tmpwfm=wfm 1715   ! 1720   !   If the section to be plotted is less than the entire array then 1725   !  resize the array down to hold only the points requested. 1730   ! 1735 Proc3:     if (e_nd-bgn)=wfpts then goto proc5 1740 Proc4:     for i=bgn to e_nd 1745       Wfm(i-bgn+1)=wfm(i) 1750       Next i 1755     Integer wfm(e_nd-bgn) 1760 Proc5:     AMAX wfm,wmax,maxloc 1765     Ans(1)=(wmax-vres/2)*vrtscale+yzero 1770     AMIN wfm,wmin,minloc 1775     Ans(2)=(wmin-vres/2)*vrtscale+yzero 1780     Range=wmax-wmin 1785     If range<25 then goto proc8 1790     If (base=0 and top=0) then goto histo 1795     Top=top/100*range+wmin 1800     Base=base/100*range+wmin 1805     Goto proc6 1810   ! 1815   !   If no base and top values were given then find them from a histo- 1820   !  gram. If the minimum value in the array is 0, offset the array by 1825   !  1 to avoid referencing array(0). If array must be offset, then set 1830   !  set wmin_flg=1 and adjust the results and array to normal before 1835   !  leaving the routine. 1840   ! 1845 Histo:     dim hstwfm(vres),temp(vres) 1850     Init var hstwfm,temp,wmin_flg 1855     AMIN wfm,wmin,minloc 1860     If wmin>=1 then goto histo1 1865   ! 1870   !   If the min value is 0, add one to each array element. The 4041 1875   !  does not allow for array subscripts of zero. 1880   ! 1885     Wmin_flg=1 1890     Wfm=wfm+1 1895 Histo1:     for i=1 to e_nd-bgn 1900       Hstwfm(wfm(i))=hstwfm(wfm(i))+1 1905       Next i 1910     AMAX wfm,wmax,maxloc 1915     AMIN wfm,wmin,minloc 1920   ! 1925   !   Creating a -1 to 1 step function with the step located at the 1930   !  hstwfm mid level. Hstwfm is then multiplied to invert the lower 1935   !  half of the array. This allows the AMIN function to find the 1940   !  baseline. 1945   ! 1950     Temp(2)=-1 1955     Temp(((wmax-wmin)/2)+wmin)=2 1960     INTEGRAT temp,temp 1965     Temp(1)=-1 1970     Hstwfm=hstwfm*temp 1975     AMAX hstwfm,hmax,maxloc 1980   ! 1985   !   If the array was normalized for zero levels, then correct the 1990   !  returned results by subtracting one from each result. 1995   ! 2000     If wmin_flg=1 then top=maxloc-1 else top=maxloc 2005     AMIN hstwfm,hmax,minloc 2010     If wmin_flg=1 then base=minloc-1 else base=minloc 2015     If wmin_flg=1 then wfm=wfm-1 2020   ! 2025   !   Done with histogram. 2030   ! 2035   !   Find the arrays max and min to compute: 2040   !      max  min  range  center  10%  90% 2045   ! 2050 Proc6:     ans(5)=(top-vres/2)*vrtscale+yzero 2055     Ans(9)=(base-vres/2)*vrtscale+yzero 2060     Center=(top-base)/2+base 2065     Ans(7)=(center-vres/2)*vrtscale+yzero 2070     L10=(top-base)*0.1+base 2075     Ans(8)=(l10-vres/2)*vrtscale+yzero 2080     L90=(top-base)*0.9+base 2085     Ans(6)=(l90-vres/2)*vrtscale+yzero 2090   ! 2095   !   Begin search for the center crossings and the number of edges. 2100   ! 2105     Slope=1 2110     CROSS wfm,center,l,1 2115     Fifloc(1)=l 2120     If l<1 then goto slp_done 2125     Edge=1 2130   ! 2135   !   Determine the slope of the crossing. To insure a valid 2140   !  test in the presence of noise, the nearest waveform value 2145   !  which is greater than five levels more than the crossing 2150   !  value is used. 2155   ! 2160 Ck_rgt:     if rgt+int(fifloc(1))<(e_nd-bgn+1) then rgt=rgt+1 2165     If int(fifloc(1))-lft>1 then lft=lft+1 2170     Test=wfm(int(fifloc(1))+rgt)-wfm(int(fifloc(1))-lft) 2175     If abs(test)<5 then goto ck_rgt 2180     Slope=sgn(test) 2185 Not_frst:     if ((slope=1 and rise>=1) or (slope=-1 and fall>=1)) then goto nxt_edge 2190   ! 2195   !   Begin loop to find the 10 and 90 pct levels. 2200   ! 2205     Lev=l10 2210     Gosub cross_ck 2215     If slope=1 then r10=loc else f10=loc 2220   ! 2225   !   Got the 10% level, now get the 90% 2230   ! 2235     Lev=l90 2240     Gosub cross_ck 2245     If slope=1 then r90=loc else f90=loc 2250   ! 2255   !   Got the 90%, now go check if both 10 and 90 were found. 2260   ! 2265     Goto ck_done 2270   ! 2275   !   Subroutine to find the crossing of the desired level. If the 2280   !  cross point found is within 3 levels of the 50% point the 2285   !  returned value is zero indicating not enough data points to 2290   !  ensure valid results. 2295   ! 2300 Cross_ck:     init var old_loc,loc,i 2305 Inc_i_cr:     i=i+1 2310     CROSS wfm,lev,loc,i 2315 Cross1:     if loc=-1 and old_loc=0 then goto cr_done 2320     If loc>fifloc(edge) or loc=-1 then goto ck_slope 2325     Old_loc=loc 2330     Goto inc_i_cr 2335 Ck_slope:     if ((lev=l10 and slope=-1) or (lev=l90 and slope=1)) then goto cr_done 2340     Loc=old_loc 2345 Cr_done:     return 2350   ! 2355   !   End of crossing subroutine. 2360   ! 2365 Ck_done:     if r10>=1 and r90>=1 then rise=edge 2370     If f10>=1 and f90>=1 then fall=edge 2375     If rise and fall then goto slp_done 2380   ! 2385   !   Don't have both edges, check if there are any more. If another 2390   !  edge is found then go back and see if there is a rise or fall. 2395   ! 2400 Nxt_edge:     i=0 2405 Inc_i_1:     i=i+1 2410     CROSS wfm,(top-1)*(slope=1)+(base+1)*(slope=-1),l,i 2415     If l<1 then goto slp_done 2420     Temploc=l 2425     If l<=fifloc(edge) then goto inc_i_1 2430     I=0 2435 Inc_i_2:     i=i+1 2440     CROSS wfm,center,l,i 2445     If l<1 then goto slp_done 2450     If l<=temploc then goto inc_i_2 2455   ! 2460   !   Redimension fifloc to hold one more crossing. 2465   ! 2470     Dim fifloc(edge+1) 2475     Fifloc(edge+1)=l 2480     Edge=edge+1 2485     Slope=-slope 2490     Goto not_frst 2495 Slp_done:     if rise then ans(12)=(r90-r10)*xinc 2500     If fall then ans(13)=(f10-f90)*xinc 2505     If edge<2 then goto proc7 2510     Wfm_wid=fifloc(2)-fifloc(1) 2515     Ans(14)=wfm_wid*xinc 2520   Rem find the period if available 2525 Proc7:     dim perloc(3) 2530     Perlvl=perlvl/100*range+wmin 2535     Level=perlvl 2540     J=1 2545 Init_i_1:     i=0 2550 Inc_i_3:     i=i+1 2555     CROSS wfm,level,l,i 2560     Perloc(j)=l 2565     If perloc(j)<1 then goto proc8 2570     If j>1 then goto period2 2575     J=2 2580     Init var rgt,lft,test 2585 Ck_1:     if rgt+int(perloc(1))<(e_nd-bgn+1) then rgt=rgt+1 2590     If int(perloc(1))-lft>1 then lft=lft+1 2595     Test=wfm(int(perloc(1))+rgt)-wfm(int(perloc(1))-lft) 2600     If abs(test)<5 then goto ck_1 2605     Slope=sgn(test) 2610   ! 2615   !   Look for the crossing of a value offset from the first 2620   !  period crossing by the value (discrim) following the first 2625   !  period crossing. This protects from noise or poor resoultion 2630   !  due to low amplitude of the signal. 2635   ! 2640     I1=i 2645     Discrim=5 2650     Level=perlvl-slope*discrim 2655     If level>wmax then level=wmax 2660     If level<wmin then level=wmin 2665     Goto init_i_1 2670 Period2:     if perloc(j)<=perloc(j-1) then goto inc_i_3 2675     If j=3 then goto per_done 2680     J=3 2685     I=i1 2690   ! 2695   !   Reset the level to the period level (perlvl) and find the 2700   !  third crossing. 2705   ! 2710     Level=perlvl 2715     Goto inc_i_3 2720 Per_done:     wfm_per=perloc(3)-perloc(1) 2725     Ans(15)=wfm_per*xinc 2730   ! 2735   !   Calculate RMS over the period. 2740   ! 2745     Wsum=0 2750     For i=perloc(1) to perloc(3) 2755       Prod=(wfm(i)-vres/2)*vrtscale+yzero 2760       Wsum=prod*prod+wsum 2765       Next i 2770     Ans(16)=sqr(wsum/wfm_per) 2775   ! Finish computing all of the parameters. 2780 Proc8:     ans(3)=(ans(1)-ans(2))/2+ans(2) 2785     Ans(4)=abs(ans(1)-ans(2)) 2790     If rise>=1 then ans(10)=abs((wmax-top)*100/(top-base)) 2795     If fall>=1 then ans(11)=abs((wmin-base)*100/(top-base)) 2800     If dsp_flg=0 then goto re_turn 2805     Dim results$ to 200 2810     Results$=";MAX:   ,"&yunit$&";MIN:   ,"&yunit$&";MID:   ,"&yunit$&";P-P:   ,"&yunit$&";100 %: ,"&yunit$ 2815     Results$=results$&";90 %:  ,"&yunit$&";50 %:  ,"&yunit$&";10 %:  ,"&yunit$&";0 %:   ,"&yunit$&";+O.S.: ,%" 2820     Results$=results$&";-O.S.: ,%;RISE:  ,"&xunit$&";FALL:  ,"&xunit$&";WIDTH: ,"&xunit$&";PERIOD:,"&xunit$ 2825     Results$=results$&";RMS:   ,"&yunit$ 2830 Dsp_wfm:     if dsp_flg=1 then wfpts=e_nd-bgn 2835     If dsp_flg=1 then strtpt=bgn 2840     XRANGE -tpos+(strtpt*xinc),xinc*(wfpts-1)-tpos+(strtpt*xinc) 2845     OFFSET -tpos+(strtpt*xinc),xinc 2850     YRANGE -(5.12*ymult)+yzero,5.08*ymult+yzero 2855     PAGE 2860     VIEWPORT 2865     WINDOW 2870     MOVE 17*char_w,28*char_h 2875   !      GTEXT "********** 7D20 Pulse Analysis Display **********" 2880     VIEWPORT 40,140,1,95 2885     COLOR 1 2890     Rcall "linestyle",1 2895     YGRID 0 2900     XGRID 0 2905     YPLOT 2910     YTITLE "AMPLITUDE volts" 2915     XTITLE "Time Relative To Trigger" 2920     Rcall "ask plot",pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy2 2925     Dim ploc(11) 2930     Ploc(1)=wmax 2935     Ploc(2)=top 2940     Ploc(3)=l90 2945     Ploc(4)=center 2950     Ploc(5)=l10 2955     Ploc(6)=base 2960     Ploc(7)=wmin 2965     Label$(1)=" Max" 2970     Label$(2)="100%" 2975     Label$(3)=" 90%" 2980     Label$(4)=" 50%" 2985     Label$(5)="10%" 2990     Label$(6)="0%" 2995     Label$(7)="Min " 3000     COLOR 3 3005   ! 3010   !   Draw the amplitude levels on the graph. 3015   ! 3020     Rcall "linestyle",2 3025     Delete var temp 3030     VIEWPORT pvx1,pvx2,pvy1,pvy2 3035     WINDOW pwx1,pwx2,pwy1,pwy2 3040     For i=1 to 7 3045       If ploc(i)<1 then goto 3155 3050       Temp=vrtscale*(ploc(i)-vres/2)+yzero 3055       MOVE pwx1,temp 3060       DRAW pwx2,temp 3065       VIEWPORT vx1,vx2,pvy1,pvy2 3070       WINDOW 3075       Rcall "linestyle",1 3080       RMOVE char_w,0 3085       If i<5 then RDRAW int((((i+2)*char_w)+pvx2)/char_w)*char_w-pvx2,0 3090       If i>4 then RDRAW int((((9-(i-2))*char_w)+pvx2)/char_w)*char_w-pvx2,0 3095       WINDOW pwx1,pwx2,pwy1,pwy2 3100       If i<5 then RDRAW 0,pwy2-((ploc(i)-vres/2)*vrtscale+yzero) 3105       If i>4 then RDRAW 0,pwy1-((ploc(i)-vres/2)*vrtscale+yzero) 3110       VIEWPORT 3115       WINDOW 3120       If i<5 then RDRAW 0,int((((5-i)*char_h)+pwy2)/char_h)*char_h-pwy2+(char_h/2) else RDRAW 0,-(int((pwy1-((3-i)*char_h))/char_h)*char_h-pwy1)+(char_h/2) 3125       RDRAW char_w,0 3130       RMOVE 0,-(char_h/2) 3135       GTEXT label$(i) 3140       VIEWPORT pvx1,pvx2,pvy1,pvy2 3145       WINDOW pwx1,pwx2,pwy1,pwy2 3150       Rcall "linestyle",2 3155       Next i 3160   ! 3165   !   Begin drawing the vertical lines indicating the rise, fall, width, 3170   !  period. 3175   ! 3180     COLOR 4 3185     Rcall "linestyle",1 3190     Integer wpt_pt,loc(2) 3195     Init var wpt_pt,loc,done 3200     Wpt_pt=wfpts/(pvx2-pvx1) 3205   ! 3210   !   Wpt_pt is the number of horizontal array elements contained 3215   !  within the line resolution of the display and viewport. 3220   ! 3225     If rise<1 then goto dr_fall 3230     If dsp_flg=1 then loc(1)=int(r10) else loc(1)=int(r10)+bgn 3235     If dsp_flg=1 then loc(2)=int(r90) else loc(2)=int(r90)+bgn 3240     Loc$="RISE" 3245     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5) 3250   ! 3255   !   Max_char is the maximum number of characters which will fit 3260   !  within the vertical lines to be displayed. Pass is used to 3265   !  indicate which side of the vertical lines to print the function 3270   !  title. Pass=0 to print between the lines, 1 to print on the left 3275   !  side and 2 to print on the right side. 3280   ! 3285     If max_char>len(loc$) then pass=0 else pass=1 3290     If (loc(1)>f90+strtpt and fall>=1 and loc(2)<wfpts-100) then pass=2 3295     For i=1 to 2 3300       VIEWPORT pvx1,pvx2,pvy1,pvy2 3305       WINDOW 1,wfpts,0,vres 3310       If (i=2 and loc(2)-loc(1)<wpt_pt) then goto 3425 3315       If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i))+1 else MOVE loc(i),wfm(loc(i)+1) 3320       DRAW loc(i),vres 3325       VIEWPORT 3330       WINDOW 3335   ! 3340   !  Reset the viewport and window to jump over the plots edge. 3345   ! 3350       RMOVE 0,char_h/2 3355       RDRAW 0,char_h 3360       If (pass=2 or i=2) then goto 3425 3365       If pass=1 then RMOVE -char_w*(len(loc$)+1),0 else RMOVE char_w,0 3370       If pass>0 then goto 3415 3375       If (max_char-len(loc$))/2<1 then goto 3415 3380   ! 3385   !   If more than enough room is between the vertical lines, center 3390   !  the label by adding spaces (chr$(32)) to the label. 3395   ! 3400       For i1=1 to int((max_char-len(loc$))/2-0.5) 3405         Rep$(loc$,0,0)=chr$(32) 3410         Next i1 3415       GTEXT loc$ 3420       Goto 3450 3425       If (i=1 or pass<2) then goto 3450 3430       VIEWPORT 3435       WINDOW 3440       RMOVE char_w,0 3445       GTEXT loc$ 3450       Next i 3455 Dr_fall:     if (done=1 or fall=0) then goto dr_time 3460     Done=1 3465     If dsp_flg=1 then loc(1)=int(f90) else loc(1)=int(f90)+strtpt 3470     If dsp_flg=1 then loc(2)=int(f10) else loc(2)=int(f10)+strtpt 3475     Loc$="FALL" 3480     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5) 3485     If max_char>len(loc$) then pass=0 else pass=1 3490     If (loc(1)>r90+strtpt and rise>=1 and loc(2)<wfpts-100 and pass=1) then pass=2 3495     Goto 3295 3500   ! 3505   !   Draw the vertical lines for width and period. 3510   ! 3515 Dr_time:     if edge<2 then goto lst_parm 3520     If dsp_flg=1 then loc(1)=int(fifloc(1)) else loc(1)=int(fifloc(1))+bgn 3525     If dsp_flg=1 then loc(2)=int(fifloc(2)) else loc(2)=int(fifloc(2))+bgn 3530     Loc$="WIDTH" 3535     Done=0 3540     N=1 3545     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5) 3550     If max_char+1>len(loc$) then pass=0 else pass=1 3555     If (pass=1 and ((loc(1)<wfpts/2 and loc(2)<wfpts-100 and int((perloc(3)+strtpt-loc(2))/wpt_pt/char_w)>len(loc$)) or (loc(1)>perloc(1)+strtpt and perloc(1)+strtpt<>0))) then pass=2 3560     For i=1 to 2 3565       VIEWPORT pvx1,pvx2,pvy1,pvy2 3570       WINDOW 1,wfpts,0,vres 3575       If dsp_flg=2 then MOVE loc(i),tmpwfm(loc(i)-1 max 1) else MOVE loc(i),wfm(loc(i)-1 max 1) 3580       DRAW loc(i),0 3585       VIEWPORT 3590       WINDOW 3595       RMOVE 0,-3*char_h 3600       RDRAW 0,-1.5*char_h*n 3605       If (pass=2 or i=2) then goto 3650 3610       If pass=1 then RMOVE -char_w*(len(loc$)+1),0 else RMOVE char_w,0 3615       If pass>=1 then goto 3640 3620       If (max_char-len(loc$))/2<1 then goto 3640 3625       For i1=1 to int((max_char-len(loc$))/2-0.5) 3630         Rep$(loc$,0,0)=chr$(32) 3635         Next i1 3640       GTEXT loc$ 3645       Goto 3665 3650       If (i=1 or pass<2) then goto 3665 3655       RMOVE char_w,0 3660       GTEXT loc$ 3665       Next i 3670     If (done=1 or wfm_per=0) then goto lst_parm 3675     N=2 3680     Done=1 3685     If dsp_flg=1 then loc(1)=int(perloc(1)) else loc(1)=int(perloc(1))+strtpt 3690     If dsp_flg=1 then loc(2)=int(perloc(3)) else loc(2)=int(perloc(3))+strtpt 3695     Loc$="PERIOD" 3700     Max_char=int(((loc(2)-loc(1))/wpt_pt/char_w)-0.5) 3705     If max_char+1>len(loc$) then pass=0 else pass=1 3710     If (pass=1 and loc(1)<wfpts/2 and loc(2)<(wfpts-100)) then pass=2 3715     Goto 3560 3720 Lst_parm:     COLOR 2 3725     If dsp_flg=2 then YADD vrtscale*(tmpwfm-vres/2)+yzero else YADD vrtscale*(wfm-vres/2)+yzero 3730     VIEWPORT 3735     WINDOW 3740     COLOR 3 3745     MOVE 2*char_w,26*char_h 3750     GTEXT "Pulse Parameters:" 3755     MOVE 2*char_w,24*char_h 3760     Sp=0 3765     For i=1 to 16 3770       If ans(i)=0 then goto dsp_pro2 3775       Sp=sp+1 3780       If i>=12 then COLOR 4 3785       If i>=12 then MOVE 2*char_w,(24*char_h)-(char_h*sp) else MOVE 2*char_w,(25*char_h)-(char_h*sp) 3790       Putmem buffer msg$ using "fa,x,4j,fa":seg$(results$,posn(results$,";",1,i)+1,7),ans(i),seg$(results$,posn(results$,",",1,i)+1,1) 3795       GTEXT msg$ 3800 Dsp_pro2:       next i 3805 Re_turn:     delete var loc,ploc,wfm,tmpwfm,rise,vx1,vx2,vy1,vy2,pwx1,pwx2,pwy1,pwy2,pvx1,pvx2,pvy1,pvy2,char_w,char_h,wmax,wmin,maxloc,minloc,wfpts,ymult,xinc,yzero,tpos,encdg$,xunit$,yunit$,vres,vrtscale,range,hstwfm,temp,wmin_flg,center,l10 3810     Delete var l90,r10,r90,f10,f90,edge,slope,i,rgt,lft,l,old_loc,loc,temploc,wfm_wid,level,i1,discrim,perloc,wfm_per,wsum,prod,results$,loc$,strtpt,ploc,wpt_pt,done,max_char,pass,sp,wfm 3815     Compress 3820     Return 3825     End 3900 Sub abormenu 3905     Print "Process aborted." 3910     Print "LLA>" !return dialog to 30 3915     Branch prinmen 3920     End 4000 Sub mederr1 !storage media not in place 4005     Print "
Warning" 4010     Print "Storage device is not in the drive." 4015     Input prompt "Insert and press RETURN to continue.":a$ 4020     Retry 4025     End 4100 Sub mederr2 !storage media is write protected 4105     Print "
Caution" 4110     Print "Storage device is write protected." 4115     Input prompt "Change to write enable and press RETURN to continue.":a$ 4120     RETYR 4125     End 4200 Sub mederr3 !file already exists 4205     Oldfil=1 4210     Advance 4215     End 4300 Sub mederr4 local a$ !storage media is full 4305     Print "
Storage device is full" 4310     Input prompt "Change the storage media and press RETURN to contine.":a$ 4315     Branch prinmen 4320     End 4400 Sub mederr5 !file does not exist 4405     Newf=1 4410     Ftype$="new" 4415     Advance 4420     End 4500 Sub mederr6 !eof occurred on the file 4505     Ftype$="rep" 4510     Retry 4515     End